/** 
 * ============================================================================
 * Copyright (c) 2011 Marvell International, Ltd. All Rights Reserved.
 *
 *                         Marvell Confidential
 * ============================================================================
 **/
 
#ifndef PIEHW_H
#define PIEHW_H

// auto generated by rereg.py @ 12:23:11 18-Mar-2011

/* this ASIC has no HalfPack support */
#define PIE_HP_BASE 0

#define PIE_CI_IENR               ((volatile uint32_t *)(ICE_BASE+0xc0000))
#define PIE_CI_WDMACMN_BIT   (0x1 << 12)
#define PIE_CI_WDMA2_BIT     (0x1 << 11)
#define PIE_CI_WDMA1_BIT     (0x1 << 10)
#define PIE_CI_WDMA0_BIT     (0x1 << 9)
#define PIE_CI_RDMACMN_BIT   (0x1 << 8)
#define PIE_CI_RDMA5_BIT     (0x1 << 7)
#define PIE_CI_RDMA4_BIT     (0x1 << 6)
#define PIE_CI_RDMA3_BIT     (0x1 << 5)
#define PIE_CI_RDMA2_BIT     (0x1 << 4)
#define PIE_CI_RDMA1_BIT     (0x1 << 3)
#define PIE_CI_RDMA0_BIT     (0x1 << 2)
#define PIE_CI_RDMA2_BIT     (0x1 << 4)
#define PIE_CI_RDMA1_BIT     (0x1 << 3)
#define PIE_CI_RDMA0_BIT     (0x1 << 2)
/* ASIC dropped support for staggered sensors but need these symbols to
 * compile (for now).
 */
#define PIE_CI_MONOHP_RDMA_BIT (0)
#define PIE_CI_MONOHP_WDMA_BIT (0) 

#define PIE_CI_IPR                ((volatile uint32_t *)(ICE_BASE+0xc0004))

#define PIE_CI_ITR                ((volatile uint32_t *)(ICE_BASE+0xc0008))

#define PIE_CI_CBIR               ((volatile uint32_t *)(ICE_BASE+0xc000c))
#define PIE_CI_CBIR_RESET         (0x1 << 0)

#define PIE_CI_PIPEORDER          ((volatile uint32_t *)(ICE_BASE+0xc0010))
#define PIE_CI_PIPEORDER_SCALESPACE(x) (((x) & 0x1) << 0)

#define PIE_RDMA_CCR              ((volatile uint32_t *)(ICE_BASE+0xc4000))
#define PIE_RDMA_CCR_ROWS(x)      (((x) & 0x3f) << 8)
#define PIE_RDMA_CCR_16BIT_PIXEL  (0x1 << 2)
#define PIE_RDMA_CCR_8BIT_PIXEL   (0x0 << 2)
#define PIE_RDMA_CCR_MONO         (0x1 << 0)
#define PIE_RDMA_CCR_COLOR        (0x0 << 0)
#define PIE_RDMA_CCR_GET_ROWS(x)     ( ((x)&0x3f00) >> 8) 

#define PIE_RDMA_CSR              ((volatile uint32_t *)(ICE_BASE+0xc4004))
#define PIE_RDMA_CSR_START        (0x1 << 0)

#define PIE_RDMA_CIR              ((volatile uint32_t *)(ICE_BASE+0xc4008))
#define PIE_RDMA_CIR_F(x)         (((x) & 0x1) << 5)
#define PIE_RDMA_CIR_E(x)         (((x) & 0x1) << 4)
#define PIE_RDMA_CIR_D(x)         (((x) & 0x1) << 3)
#define PIE_RDMA_CIR_C(x)         (((x) & 0x1) << 2)
#define PIE_RDMA_CIR_B(x)         (((x) & 0x1) << 1)
#define PIE_RDMA_CIR_A(x)         (((x) & 0x1) << 0)

#define PIE_RDMA_CHANNEL_OFFSET 0x80
#define PIE_RDMA_DCR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4040))
#define PIE_RDMA_DCR_CIE          (0x1 << 31)
#define PIE_RDMA_DCR_BURST_32     (0x1 << 4)
#define PIE_RDMA_DCR_RESET        (0x1 << 1)
#define PIE_RDMA_DCR_EN           (0x1 << 0)
#define PIE_RDMA_NUM_CHANNELS 3

#define PIE_RDMA_DAR1(x)          ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4044))

#define PIE_RDMA_DAR2(x)          ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4048))

#define PIE_RDMA_DRCR1(x)         ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc404c))

#define PIE_RDMA_DRCR2(x)         ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4050))

#define PIE_RDMA_DBCR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4054))

#define PIE_RDMA_DTCR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4058))

#define PIE_RDMA_DSTR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc405c))

#define PIE_RDMA_DASR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4060))

#define PIE_RDMA_DCSR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4064))

#define PIE_RDMA_DRCSR(x)         ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4068))

#define PIE_RDMA_DSR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc406c))
#define PIE_RDMA_DSR_CMPL         (0x1 << 31)
#define PIE_RDMA_DSR_READY        (0x1 << 1)
#define PIE_RDMA_DSR_ACTIVE       (0x1 << 0)

#define PIE_RDMA_DRR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4070))
#define PIE_RDMA_DRR_TERM(x)      (((x) & 0x1) << 23)
#define PIE_RDMA_DRR_ERROR(x)     (((x) & 0x1) << 22)
#define PIE_RDMA_DRR_XCNT(x)      (((x) & 0xfffff) << 0)

#define PIE_RDMA_DIR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_RDMA_CHANNEL_OFFSET*(x) + 0xc4074))
#define PIE_RDMA_DIR_CLEAR(x)     (((x) & 0x1) << 0)

#define PIE_BDE_CFG               ((volatile uint32_t *)(ICE_BASE+0xc8000))
#define PIE_BDE_CFG_MONO          (0x1 << 2)
#define PIE_BDE_CFG_COLOR         (0x0 << 2)
#define PIE_BDE_CFG_CPU           (0x1 << 1)
#define PIE_BDE_CFG_BYPASS        (0x1 << 0)

#define PIE_BDE_LUT               ((volatile uint32_t *)(ICE_BASE+0xc8400))
#define PIE_BDE_LUT_LUT(x)        (((x) & 0x3fff) << 0)

/* number of 32-bit fields in BDE LUT */
#define PIE_BDE_LUT_SIZE 256

/* each LUT entry is 14-bits wide */
#define PIE_BDE_LUT_ENTRY(x)  ((x)&0x03fff)

#define PIE_CSC_RGB_CCR           ((volatile uint32_t *)(ICE_BASE+0xcc000))
#define PIE_CSC_RGB_CCR_CPU       (0x1 << 4)
#define PIE_CSC_RGB_CCR_BYLUT     (0x1 << 3)
#define PIE_CSC_RGB_CCR_BYPASS    (0x1 << 0)

#define PIE_CSC_RGB_MUL           ((volatile uint32_t *)(ICE_BASE+0xcc100))
#define PIE_CSC_RGB_MUL_ENTRY(x)  (((x) & 0xffff) << 0)
#define PIE_CSC_MUL_SIZE   9  /* 3x3 32-bit matrix */

#define PIE_CSC_RED_OVERFLOW      ((volatile uint32_t *)(ICE_BASE+0xcc400))
#define PIE_CSC_RED_OVERFLOW_LUTVAL(x) (((x) & 0x3ff) << 0)

#define PIE_CSC_GREEN_OVERFLOW    ((volatile uint32_t *)(ICE_BASE+0xcc404))
#define PIE_CSC_GREEN_OVERFLOW_LUTVAL(x) (((x) & 0x3ff) << 0)

#define PIE_CSC_BLUE_OVERFLOW     ((volatile uint32_t *)(ICE_BASE+0xcc408))
#define PIE_CSC_BLUE_OVERFLOW_LUTVAL(x) (((x) & 0x3ff) << 0)

#define PIE_CSC_RGB_LUT           ((volatile uint32_t *)(ICE_BASE+0xce000))
#define PIE_CSC_RGB_LUT_LUTVAL(x) (((x) & 0x3ff) << 0)
/* davep 29-Oct-2007 ; This ASIC has one LUT for each R,G,B channel separated by
 * this offset in bytes 
 */
#define OFFSET_PIE_CSC_RED_LUT   0x000
#define OFFSET_PIE_CSC_GREEN_LUT 0x400
#define OFFSET_PIE_CSC_BLUE_LUT  0x800

#define PIE_CSC_RED_LUT   ((volatile uint32_t *) (ICE_BASE+0xce000+ OFFSET_PIE_CSC_RED_LUT ))
#define PIE_CSC_GREEN_LUT ((volatile uint32_t *) (ICE_BASE+0xce000+ OFFSET_PIE_CSC_GREEN_LUT ))
#define PIE_CSC_BLUE_LUT  ((volatile uint32_t *) (ICE_BASE+0xce000+ OFFSET_PIE_CSC_BLUE_LUT ))
/* only RGB to esRGB has a lookup table */
#define PIE_CSC_RGB_LUT_SIZE 257 /* number of 32-bit values (not bytes) */
                                 /* 257 is NOT a typo */

#define PIE_CSC_ESR_CCR           ((volatile uint32_t *)(ICE_BASE+0xd0000))
#define PIE_CSC_ESR_CCR_POSTOFFBYPASS (0x1 << 6)
#define PIE_CSC_ESR_CCR_OFFSETBYPASS (0x1 << 1)
#define PIE_CSC_ESR_CCR_BYPASS    (0x1 << 0)

#define PIE_CSC_ESR_MUL           ((volatile uint32_t *)(ICE_BASE+0xd0100))
#define PIE_CSC_ESR_MUL_ENTRY(x)  (((x) & 0x3fff) << 0)

#define PIE_NGA_CFG               ((volatile uint32_t *)(ICE_BASE+0xd4000))
#define PIE_NGA_CFG_METHOD(x)     (((x) & 0x1) << 2)
#define PIE_NGA_CFG_CPU(x)        (((x) & 0x1) << 1)
#define PIE_NGA_CFG_BYPASS(x)     (((x) & 0x1) << 0)

#define PIE_NGA_LUT               ((volatile uint32_t *)(ICE_BASE+0xd5000))
#define PIE_NGA_LUT_C1(x)         (((x) & 0xff) << 8)
#define PIE_NGA_LUT_C2(x)         (((x) & 0xff) << 0)

#define PIE_TCNS_CR               ((volatile uint32_t *)(ICE_BASE+0xd8000))
#define PIE_TCNS_CR_CPU           (0x1 << 1)
#define PIE_TCNS_CR_BYPASS        (0x1 << 0)

#define PIE_TCNS_LUT              ((volatile uint32_t *)(ICE_BASE+0xd9000))
#define PIE_TCNS_LUT_Y(x)         (((x) & 0xff) << 22)
#define PIE_TCNS_LUT_CR(x)        (((x) & 0xff) << 11)
#define PIE_TCNS_LUT_CB(x)        (((x) & 0xff) << 0)
/* number of 32-bit fields in lookup table; 10-bit input */
#define PIE_TCNS_LUT_SIZE  1024

#define PIE_TCNS_TUPLE(y,cb,cr)  (PIE_TCNS_LUT_Y(y) | PIE_TCNS_LUT_CB(cb) | PIE_TCNS_LUT_CR(cr))
#define PIE_TCNS_LUT_Y_SHIFT  22
#define PIE_TCNS_LUT_CR_SHIFT 11
#define PIE_TCNS_LUT_CB_SHIFT 0
#define PIE_TCNS_GET_Y(num) ( ((num)&(0xff<<22)) >> 22)
#define PIE_TCNS_GET_CB(num) ( ((num)&(0xff<<0)) >> 0)
#define PIE_TCNS_GET_CR(num) ( ((num)&(0xff<<11)) >> 11)
/* number of 32-bit fields in lookup table; 10-bit input */
#define PIE_TCNS_LUT_SIZE  1024

#define PIE_TCNS_TUPLE(y,cb,cr)  (PIE_TCNS_LUT_Y(y) | PIE_TCNS_LUT_CB(cb) | PIE_TCNS_LUT_CR(cr))

#define PIE_ALIGN_PACR            ((volatile uint32_t *)(ICE_BASE+0xdc000))
#define PIE_ALIGN_PACR_PIXELS(x)  (((x) & 0x3ffff) << 8)
#define PIE_ALIGN_PACR_LINES(x)   (((x) & 0x3f) << 0)

#define PIE_ALIGN_PASTR           ((volatile uint32_t *)(ICE_BASE+0xdc004))
#define PIE_ALIGN_PASTR_P(x)      (((x) & 0x3ffff) << 14)
#define PIE_ALIGN_PASTR_N(x)      (((x) & 0x3f) << 8)
#define PIE_ALIGN_PASTR_A         (0x1 << 0)

#define PIE_FILTER_LUT            ((volatile uint32_t *)(ICE_BASE+0xe0000))
#define PIE_FILTER_LUT_Y(x)       (((x) & 0xff) << 8)
#define PIE_FILTER_LUT_C(x)       (((x) & 0xff) << 0)
/* number of 32-bit longwords in lookup table */
#define PIE_FILTER_LUT_SIZE 64

/* ai lut is two 8-bit values; MSbyte is Y, LSbyte is CbCr */
#define PIE_FILTER_LUT_Y_SHIFT    8
#define PIE_FILTER_LUT_CBCR_SHIFT 0

#define PIE_FILTER_SCR1           ((volatile uint32_t *)(ICE_BASE+0xe0100))
#define PIE_FILTER_SCR1_OFFSET(x) (((x) & 0x1ff) << 23)
#define PIE_FILTER_SCR1_N_128     (0x3 << 20)
#define PIE_FILTER_SCR1_N_64      (0x2 << 20)
#define PIE_FILTER_SCR1_N_32      (0x1 << 20)
#define PIE_FILTER_SCR1_N_16      (0x0 << 20)
#define PIE_FILTER_SCR1_P_0       (0x3 << 16)
#define PIE_FILTER_SCR1_P_0_125   (0x2 << 16)
#define PIE_FILTER_SCR1_P_0_25    (0x1 << 16)
#define PIE_FILTER_SCR1_P_0_5     (0x0 << 16)
#define PIE_FILTER_SCR1_M_0       (0x3 << 12)
#define PIE_FILTER_SCR1_M_0_25    (0x2 << 12)
#define PIE_FILTER_SCR1_M_0_5     (0x1 << 12)
#define PIE_FILTER_SCR1_M_1       (0x0 << 12)
#define PIE_FILTER_SCR1_S_0_125   (0x3 << 8)
#define PIE_FILTER_SCR1_S_0_25    (0x2 << 8)
#define PIE_FILTER_SCR1_S_0_5     (0x1 << 8)
#define PIE_FILTER_SCR1_S_1       (0x0 << 8)
#define PIE_FILTER_SCR1_R_2       (0x2 << 4)
#define PIE_FILTER_SCR1_R_1_5     (0x1 << 4)
#define PIE_FILTER_SCR1_R_1       (0x0 << 4)
#define PIE_FILTER_SCR1_Y_2       (0x2 << 0)
#define PIE_FILTER_SCR1_Y_1_5     (0x1 << 0)
#define PIE_FILTER_SCR1_Y_1       (0x0 << 0)
#define PIE_FILTER_SCR1_OFFSET_SHIFT 23
    

#define PIE_FILTER_SCR2           ((volatile uint32_t *)(ICE_BASE+0xe0104))
#define PIE_FILTER_SCR2_CPU       (0x1 << 16)
#define PIE_FILTER_SCR2_MONO      (0x1 << 12)
#define PIE_FILTER_SCR2_BYPASS    (0x1 << 8)
#define PIE_FILTER_SCR2_TE_BYPASS (0x1 << 4)
#define PIE_FILTER_SCR2_TE_MATRIX (0x1 << 0)
#define PIE_FILTER_SCR2_EROSION   (0x1 << 28)
#define PIE_FILTER_SCR2_DILATION  (0x1 << 24)
#define PIE_FILTER_SCR2_VAR       (0x1 << 20)

#define PIE_FILTER_TEL1R          ((volatile uint32_t *)(ICE_BASE+0xe0108))
#define PIE_FILTER_TEL1R_CNTC(x)  (((x) & 0x7f) << 24)
#define PIE_FILTER_TEL1R_CNTBW(x) (((x) & 0x3f) << 16)
#define PIE_FILTER_TEL1R_CNTW(x)  (((x) & 0x1f) << 8)
#define PIE_FILTER_TEL1R_CNTB(x)  (((x) & 0x1f) << 0)

#define PIE_FILTER_TEL2R          ((volatile uint32_t *)(ICE_BASE+0xe010c))
#define PIE_FILTER_TEL2R_CMAX(x)  (((x) & 0x7f) << 0)

#define PIE_FILTER_TEL3R          ((volatile uint32_t *)(ICE_BASE+0xe0110))
#define PIE_FILTER_TEL3R_WCrCbMAX(x) (((x) & 0x7f) << 24)
#define PIE_FILTER_TEL3R_WYMIN(x) (((x) & 0x7f) << 16)
#define PIE_FILTER_TEL3R_BCrCbMAX(x) (((x) & 0x7f) << 8)
#define PIE_FILTER_TEL3R_BYMAX(x) (((x) & 0x7f) << 0)

#define PIE_FILTER_EC             ((volatile uint32_t *)(ICE_BASE+0xe0114))
#define PIE_FILTER_EC_EDGE_COUNT_COMPARE(x) (((x) & 0xff) << 24)
#define PIE_FILTER_EC_EDGE_COUNT(x) (((x) & 0xffffff) << 0)

#define PIE_CSC_YCC_CCR           ((volatile uint32_t *)(ICE_BASE+0xe4000))
#define PIE_CSC_YCC_CCR_PREOFFBYPASS (0x1 << 5)
#define PIE_CSC_YCC_CCR_OFFSETBYPASS (0x1 << 1)
#define PIE_CSC_YCC_CCR_BYPASS    (0x1 << 0)

#define PIE_CSC_YCC_MUL           ((volatile uint32_t *)(ICE_BASE+0xe4100))
#define PIE_CSC_YCC_MUL_ENTRY(x)  (((x) & 0x3fff) << 0)

#define PIE_SCALE_CFG             ((volatile uint32_t *)(ICE_BASE+0xe8000))
#define PIE_SCALE_CFG_ROUNDUP(x)  (((x) & 0x7) << 16)
#define PIE_SCALE_CFG_LM_MODE     (0x1 << 8)
#define PIE_SCALE_CFG_RAPR_MODE   (0x0 << 8)
#define PIE_SCALE_CFG_BYPASS      (0x1 << 0)
/* fields for PIE_SCALE_CFG_ROUNDUP */
#define PIE_SCALE_RUP_NONE          0   /* no roundup */
#define PIE_SCALE_RUP_MUX       (1<<0)  /* mux in 0.5 instead of zero into adder */
#define PIE_SCALE_RUP_RESET_ACC (1<<1)  /* reset accumulator value to 0.5 */
#define PIE_SCALE_RUP_RESET_INT (1<<2)  /* reset intermediate accumulators to 0.5 */
#define PIE_SCALE_RUP_ALL           7   /* do full rounding up */

#define PIE_SCALE_INXY            ((volatile uint32_t *)(ICE_BASE+0xe8004))
#define PIE_SCALE_INXY_LC(x)      (((x) & 0x1f) << 24)
#define PIE_SCALE_INXY_CC(x)      (((x) & 0x3ffff) << 0)

#define PIE_SCALE_OUTX            ((volatile uint32_t *)(ICE_BASE+0xe8008))
#define PIE_SCALE_OUTX_RM(x)      (((x) & 0x1) << 24)
#define PIE_SCALE_OUTX_CC(x)      (((x) & 0x3ffff) << 0)

#define PIE_SCALE_FILLC1C2        ((volatile uint32_t *)(ICE_BASE+0xe800c))
#define PIE_SCALE_FILLC1C2_F2(x)  (((x) & 0xff) << 16)
#define PIE_SCALE_FILLC1C2_F1(x)  (((x) & 0xff) << 0)

#define PIE_SCALE_FILLC0          ((volatile uint32_t *)(ICE_BASE+0xe8010))
#define PIE_SCALE_FILLC0_F0(x)    (((x) & 0xff) << 0)

#define PIE_SCALE_SCALEX          ((volatile uint32_t *)(ICE_BASE+0xe8014))
#define PIE_SCALE_SCALEX_EDGE(x)  (((x) & 0xf) << 24)
#define PIE_SCALE_SCALEX_SCALE(x) (((x) & 0xfffff) << 0)

#define PIE_SCALE_SCALEY          ((volatile uint32_t *)(ICE_BASE+0xe8018))
#define PIE_SCALE_SCALEY_SCALE(x) (((x) & 0xfffff) << 0)

#define PIE_SCALE_SXMN            ((volatile uint32_t *)(ICE_BASE+0xe801c))
#define PIE_SCALE_SXMN_S(x)       (((x) & 0xfffff) << 0)

#define PIE_SCALE_SYMN            ((volatile uint32_t *)(ICE_BASE+0xe8020))
#define PIE_SCALE_SYMN_S(x)       (((x) & 0xfffff) << 0)

#define PIE_SCALE_TX              ((volatile uint32_t *)(ICE_BASE+0xe8024))
#define PIE_SCALE_TX_DX(x)        (((x) & 0xfffff) << 0)

#define PIE_SCALE_TY              ((volatile uint32_t *)(ICE_BASE+0xe8028))
#define PIE_SCALE_TY_DY(x)        (((x) & 0xfffff) << 0)

#define PIE_SCALE_CURRDX          ((volatile uint32_t *)(ICE_BASE+0xe802c))
#define PIE_SCALE_CURRDX_DX(x)    (((x) & 0xfffff) << 0)

#define PIE_SCALE_CURRDY          ((volatile uint32_t *)(ICE_BASE+0xe8030))
#define PIE_SCALE_CURRDY_DY(x)    (((x) & 0xfffff) << 0)

#define PIE_SCALE_INITYPER        ((volatile uint32_t *)(ICE_BASE+0xe8034))
#define PIE_SCALE_INITYPER_P(x)   (((x) & 0xfffff) << 0)

#define PIE_SCALE_CURRXPER        ((volatile uint32_t *)(ICE_BASE+0xe8038))
#define PIE_SCALE_CURRXPER_P(x)   (((x) & 0xfffff) << 0)

#define PIE_SCALE_CURRYPER        ((volatile uint32_t *)(ICE_BASE+0xe803c))
#define PIE_SCALE_CURRYPER_P(x)   (((x) & 0xfffff) << 0)

#define PIE_SCALE_OBS             ((volatile uint32_t *)(ICE_BASE+0xe8040))
#define PIE_SCALE_OBS_GET_AY(x)   (((x) & 0xf) << 24)
#define PIE_SCALE_OBS_GET_LC(x)   (((x) & 0x1f) << 16)
#define PIE_SCALE_OBS_GET_SM(x)   (((x) & 0xff) << 8)
#define PIE_SCALE_OBS_GET_RY(x)   (((x) & 0x1) << 1)
#define PIE_SCALE_OBS_GET_RX(x)   (((x) & 0x1) << 0)

#define PIE_CS_CCSCR              ((volatile uint32_t *)(ICE_BASE+0xec000))
#define PIE_CS_CCSCR_COLHEIGHT(x) (((x) & 0x1f) << 4)
#define PIE_CS_CCSCR_ROUNDMODE(x) (((x) & 0x3) << 2)
#define PIE_CS_CCSCR_TWOLINE(x)   (((x) & 0x1) << 1)
#define PIE_CS_CCSCR_BYPASS       (0x1 << 0)

#define PIE_CS_CCSMMR             ((volatile uint32_t *)(ICE_BASE+0xec004))
#define PIE_CS_CCSMMR_BLUE(x)     (((x) & 0x3) << 8)
#define PIE_CS_CCSMMR_GREEN(x)    (((x) & 0x3) << 4)
#define PIE_CS_CCSMMR_RED(x)      (((x) & 0x3) << 0)

#define PIE_CS_CCSMWR             ((volatile uint32_t *)(ICE_BASE+0xec008))
#define PIE_CS_CCSMWR_BLUE(x)     (((x) & 0x1f) << 16)
#define PIE_CS_CCSMWR_GREEN(x)    (((x) & 0x1f) << 8)
#define PIE_CS_CCSMWR_RED(x)      (((x) & 0x1f) << 0)

#define PIE_CS_CCSLSSR            ((volatile uint32_t *)(ICE_BASE+0xec00c))
#define PIE_CS_CCSLSSR_SEED(x)    (((x) & 0xfff) << 0)

#define PIE_CS_CCSLSR             ((volatile uint32_t *)(ICE_BASE+0xec010))
#define PIE_CS_CCSLSR_BLUELFSR    (0x1f << 16)
#define PIE_CS_CCSLSR_GREENLFSR   (0x1f << 8)
#define PIE_CS_CCSLSR_REDLFSR     (0x1f << 0)

#define PIE_CS_CCSRSR             ((volatile uint32_t *)(ICE_BASE+0xec014))
#define PIE_CS_CCSRSR_BLUEROW     (0x1f << 16)
#define PIE_CS_CCSRSR_GREENROW    (0x1f << 8)
#define PIE_CS_CCSRSR_REDROW      (0x1f << 0)

#define PIE_WDMA_CHANNEL_OFFSET 0x40
#define PIE_WDMA_DCR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf0000))
#define PIE_WDMA_DCR_CIE          (0x1 << 31)
#define PIE_WDMA_DCR_BURST_32     (0x1 << 4)
#define PIE_WDMA_DCR_RESET        (0x1 << 1)
#define PIE_WDMA_DCR_EN           (0x1 << 0)
#define PIE_WDMA_NUM_CHANNELS 3

#define PIE_WDMA_DAR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf0004))

#define PIE_WDMA_DRCR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf0008))

#define PIE_WDMA_DBCR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf000c))

#define PIE_WDMA_DTCR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf0010))

#define PIE_WDMA_DSTR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf0014))

#define PIE_WDMA_DASR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf0018))

#define PIE_WDMA_DCSR(x)          ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf001c))

#define PIE_WDMA_DRCSR(x)         ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf0020))

#define PIE_WDMA_DSR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf0024))
#define PIE_WDMA_DSR_CMPL         (0x1 << 31)
#define PIE_WDMA_DSR_READY        (0x1 << 1)
#define PIE_WDMA_DSR_ACTIVE       (0x1 << 0)

#define PIE_WDMA_DRR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf0028))
#define PIE_WDMA_DRR_TERM         (0x1 << 23)
#define PIE_WDMA_DRR_ERROR        (0x1 << 22)
#define PIE_WDMA_DRR_XCNT         (0xfffff << 0)

#define PIE_WDMA_DIR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf002c))
#define PIE_WDMA_DIR_CLEAR        (0x1 << 0)

#define PIE_WDMA_DGCR             ((volatile uint32_t *)(ICE_BASE+0xf00c0))
#define PIE_WDMA_DGCR_MODE_RGB    (0x3 << 9)
#define PIE_WDMA_DGCR_MODE_RGBX   (0x2 << 9)
#define PIE_WDMA_DGCR_MODE_XRGB   (0x1 << 9)
#define PIE_WDMA_DGCR_MODE_NORM   (0x0 << 9)
#define PIE_WDMA_DGCR_MONO        (0x1 << 8)
#define PIE_WDMA_DGCR_COLOR       (0x0 << 8)
#define PIE_WDMA_DGCR_DRC         (0x1 << 7)
#define PIE_WDMA_DGCR_ROWS(x)     (((x) & 0x3f) << 0)
#define PIE_WDMA_DGCR_MODE_MASK  (PIE_WDMA_DGCR_MODE_NORM |\
                                  PIE_WDMA_DGCR_MODE_XRGB |\
                                  PIE_WDMA_DGCR_MODE_RGBX |\
                                  PIE_WDMA_DGCR_MODE_RGB)
#define PIE_WDMA_DGCR_MODE_MASK  (PIE_WDMA_DGCR_MODE_NORM |\
                                  PIE_WDMA_DGCR_MODE_XRGB |\
                                  PIE_WDMA_DGCR_MODE_RGBX |\
                                  PIE_WDMA_DGCR_MODE_RGB)
#define PIE_WDMA_DGCR_GET_ROWS(x)   ( ((x)&0x3f) ) /* number of rows in strip; 6 bits */

#define PIE_WDMA_CIR(x)           ((volatile uint32_t *)(ICE_BASE + PIE_WDMA_CHANNEL_OFFSET*(x) + 0xf00c4))
#define PIE_WDMA_CIR_DMA2_IE(x)   (((x) & 0x1) << 2)
#define PIE_WDMA_CIR_DMA1_IE(x)   (((x) & 0x1) << 1)
#define PIE_WDMA_CIR_DMA0_IE(x)   (((x) & 0x1) << 0)

#endif // PIEHW_H
