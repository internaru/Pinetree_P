/* wprtC.c
   Generated by gSOAP 2.7.8c from gen/WSDPrinterService.gsoap
   Copyright (C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "wprtH.h"
#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) wprtC.c ver 2.7.8c 2013-09-16 07:14:30 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_wprt__ConditionIdType:
		return soap_in_wprt__ConditionIdType(soap, NULL, NULL, "wprt:ConditionIdType");
	case SOAP_TYPE_wprt__JobPriorityRestrictionType:
		return soap_in_wprt__JobPriorityRestrictionType(soap, NULL, NULL, "wprt:JobPriorityRestrictionType");
	case SOAP_TYPE_wprt__JobCopiesRestrictionType:
		return soap_in_wprt__JobCopiesRestrictionType(soap, NULL, NULL, "wprt:JobCopiesRestrictionType");
	case SOAP_TYPE_wprt__JobIdRestrictionType:
		return soap_in_wprt__JobIdRestrictionType(soap, NULL, NULL, "wprt:JobIdRestrictionType");
	case SOAP_TYPE_wprt__NUpPagesPerSheetRestrictionType:
		return soap_in_wprt__NUpPagesPerSheetRestrictionType(soap, NULL, NULL, "wprt:NUpPagesPerSheetRestrictionType");
	case SOAP_TYPE_wprt__EventRateBaseType:
		return soap_in_wprt__EventRateBaseType(soap, NULL, NULL, "wprt:EventRateBaseType");
	case SOAP_TYPE_wprt__DocumentIdType:
		return soap_in_wprt__DocumentIdType(soap, NULL, NULL, "wprt:DocumentIdType");
	case SOAP_TYPE_wprt__IntOneBaseType:
		return soap_in_wprt__IntOneBaseType(soap, NULL, NULL, "wprt:IntOneBaseType");
	case SOAP_TYPE_wprt__IntZeroBaseType:
		return soap_in_wprt__IntZeroBaseType(soap, NULL, NULL, "wprt:IntZeroBaseType");
	case SOAP_TYPE_wprt__CapacityRestrictType:
		return soap_in_wprt__CapacityRestrictType(soap, NULL, NULL, "wprt:CapacityRestrictType");
	case SOAP_TYPE_wprt__LevelFreeRestrictType:
		return soap_in_wprt__LevelFreeRestrictType(soap, NULL, NULL, "wprt:LevelFreeRestrictType");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_wprt__ConditionSeverityBaseType:
		return soap_in_wprt__ConditionSeverityBaseType(soap, NULL, NULL, "wprt:ConditionSeverityBaseType");
	case SOAP_TYPE_wprt__ComponentGroupBaseType:
		return soap_in_wprt__ComponentGroupBaseType(soap, NULL, NULL, "wprt:ComponentGroupBaseType");
	case SOAP_TYPE_wprt__ConditionNameBaseType:
		return soap_in_wprt__ConditionNameBaseType(soap, NULL, NULL, "wprt:ConditionNameBaseType");
	case SOAP_TYPE_wprt__HolePunchPatternWKVType:
		return soap_in_wprt__HolePunchPatternWKVType(soap, NULL, NULL, "wprt:HolePunchPatternWKVType");
	case SOAP_TYPE_wprt__HolePunchEdgeWKVType:
		return soap_in_wprt__HolePunchEdgeWKVType(soap, NULL, NULL, "wprt:HolePunchEdgeWKVType");
	case SOAP_TYPE_wprt__StapleAngleWKVType:
		return soap_in_wprt__StapleAngleWKVType(soap, NULL, NULL, "wprt:StapleAngleWKVType");
	case SOAP_TYPE_wprt__StapleLocationWKVType:
		return soap_in_wprt__StapleLocationWKVType(soap, NULL, NULL, "wprt:StapleLocationWKVType");
	case SOAP_TYPE_wprt__NUpDirectionRestrictionType:
		return soap_in_wprt__NUpDirectionRestrictionType(soap, NULL, NULL, "wprt:NUpDirectionRestrictionType");
	case SOAP_TYPE_wprt__MediaColorWKVType:
		return soap_in_wprt__MediaColorWKVType(soap, NULL, NULL, "wprt:MediaColorWKVType");
	case SOAP_TYPE_wprt__MediaTypeWKVType:
		return soap_in_wprt__MediaTypeWKVType(soap, NULL, NULL, "wprt:MediaTypeWKVType");
	case SOAP_TYPE_wprt__MediaSizeSelfDescribingNameWKVType:
		return soap_in_wprt__MediaSizeSelfDescribingNameWKVType(soap, NULL, NULL, "wprt:MediaSizeSelfDescribingNameWKVType");
	case SOAP_TYPE_wprt__SidesWKVType:
		return soap_in_wprt__SidesWKVType(soap, NULL, NULL, "wprt:SidesWKVType");
	case SOAP_TYPE_wprt__PrinterStateReasonsWKVType:
		return soap_in_wprt__PrinterStateReasonsWKVType(soap, NULL, NULL, "wprt:PrinterStateReasonsWKVType");
	case SOAP_TYPE_wprt__PrinterStateWKVType:
		return soap_in_wprt__PrinterStateWKVType(soap, NULL, NULL, "wprt:PrinterStateWKVType");
	case SOAP_TYPE_wprt__PrintQualityWKVType:
		return soap_in_wprt__PrintQualityWKVType(soap, NULL, NULL, "wprt:PrintQualityWKVType");
	case SOAP_TYPE_wprt__OutputBinWKVType:
		return soap_in_wprt__OutputBinWKVType(soap, NULL, NULL, "wprt:OutputBinWKVType");
	case SOAP_TYPE_wprt__OrientationWKVType:
		return soap_in_wprt__OrientationWKVType(soap, NULL, NULL, "wprt:OrientationWKVType");
	case SOAP_TYPE_wprt__JobStateReasonsWKVType:
		return soap_in_wprt__JobStateReasonsWKVType(soap, NULL, NULL, "wprt:JobStateReasonsWKVType");
	case SOAP_TYPE_wprt__JobStateWKVType:
		return soap_in_wprt__JobStateWKVType(soap, NULL, NULL, "wprt:JobStateWKVType");
	case SOAP_TYPE_wprt__InputBinWKVType:
		return soap_in_wprt__InputBinWKVType(soap, NULL, NULL, "wprt:InputBinWKVType");
	case SOAP_TYPE_wprt__DocumentFormatWKVType:
		return soap_in_wprt__DocumentFormatWKVType(soap, NULL, NULL, "wprt:DocumentFormatWKVType");
	case SOAP_TYPE_wprt__CompressionWKVType:
		return soap_in_wprt__CompressionWKVType(soap, NULL, NULL, "wprt:CompressionWKVType");
	case SOAP_TYPE_wprt__InputBinFeedDirectionBaseType:
		return soap_in_wprt__InputBinFeedDirectionBaseType(soap, NULL, NULL, "wprt:InputBinFeedDirectionBaseType");
	case SOAP_TYPE_wprt__ConsumableColorWKVType:
		return soap_in_wprt__ConsumableColorWKVType(soap, NULL, NULL, "wprt:ConsumableColorWKVType");
	case SOAP_TYPE_wprt__ConsumableTypeWKVType:
		return soap_in_wprt__ConsumableTypeWKVType(soap, NULL, NULL, "wprt:ConsumableTypeWKVType");
	case SOAP_TYPE_wprt__StorageTypeWKVType:
		return soap_in_wprt__StorageTypeWKVType(soap, NULL, NULL, "wprt:StorageTypeWKVType");
	case SOAP_TYPE_wprt__PrintServiceFaultValuesType:
		return soap_in_wprt__PrintServiceFaultValuesType(soap, NULL, NULL, "wprt:PrintServiceFaultValuesType");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_SOAP_ENV__Reason:
		return soap_in_SOAP_ENV__Reason(soap, NULL, NULL, "SOAP-ENV:Reason");
	case SOAP_TYPE__wprt__Printer:
		return soap_in__wprt__Printer(soap, NULL, NULL, "wprt:Printer");
	case SOAP_TYPE_wprt__PrinterElementDataType:
		return soap_in_wprt__PrinterElementDataType(soap, NULL, NULL, "wprt:PrinterElementDataType");
	case SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription:
		return soap_in__wprt__DocumentValuesType_DocumentDescription(soap, NULL, NULL, "wprt:DocumentValuesType-DocumentDescription");
	case SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution:
		return soap_in__wprt__JobValuesType_DocumentProcessing_Resolution(soap, NULL, NULL, "wprt:JobValuesType-DocumentProcessing-Resolution");
	case SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp:
		return soap_in__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, NULL, NULL, "wprt:JobValuesType-DocumentProcessing-NumberUp");
	case SOAP_TYPE__wprt__JobValuesType_DocumentProcessing:
		return soap_in__wprt__JobValuesType_DocumentProcessing(soap, NULL, NULL, "wprt:JobValuesType-DocumentProcessing");
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch:
		return soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, NULL, NULL, "wprt:JobValuesType-JobProcessing-JobFinishings-HolePunch");
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple:
		return soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, NULL, NULL, "wprt:JobValuesType-JobProcessing-JobFinishings-Staple");
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings:
		return soap_in__wprt__JobValuesType_JobProcessing_JobFinishings(soap, NULL, NULL, "wprt:JobValuesType-JobProcessing-JobFinishings");
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing:
		return soap_in__wprt__JobValuesType_JobProcessing(soap, NULL, NULL, "wprt:JobValuesType-JobProcessing");
	case SOAP_TYPE_wprt__DocumentValuesType:
		return soap_in_wprt__DocumentValuesType(soap, NULL, NULL, "wprt:DocumentValuesType");
	case SOAP_TYPE_wprt__JobValuesType:
		return soap_in_wprt__JobValuesType(soap, NULL, NULL, "wprt:JobValuesType");
	case SOAP_TYPE_wprt__ComponentNameType:
		return soap_in_wprt__ComponentNameType(soap, NULL, NULL, "wprt:ComponentNameType");
	case SOAP_TYPE_wprt__ComponentGroupType:
		return soap_in_wprt__ComponentGroupType(soap, NULL, NULL, "wprt:ComponentGroupType");
	case SOAP_TYPE_wprt__ConditionSeverityType:
		return soap_in_wprt__ConditionSeverityType(soap, NULL, NULL, "wprt:ConditionSeverityType");
	case SOAP_TYPE_wprt__ConditionComponentType:
		return soap_in_wprt__ConditionComponentType(soap, NULL, NULL, "wprt:ConditionComponentType");
	case SOAP_TYPE_wprt__ConditionNameType:
		return soap_in_wprt__ConditionNameType(soap, NULL, NULL, "wprt:ConditionNameType");
	case SOAP_TYPE_wprt__ConditionHistoryEntryType:
		return soap_in_wprt__ConditionHistoryEntryType(soap, NULL, NULL, "wprt:ConditionHistoryEntryType");
	case SOAP_TYPE_wprt__ConditionHistoryTableType:
		return soap_in_wprt__ConditionHistoryTableType(soap, NULL, NULL, "wprt:ConditionHistoryTableType");
	case SOAP_TYPE_wprt__ActiveConditionTableType:
		return soap_in_wprt__ActiveConditionTableType(soap, NULL, NULL, "wprt:ActiveConditionTableType");
	case SOAP_TYPE_wprt__OutputBinsType:
		return soap_in_wprt__OutputBinsType(soap, NULL, NULL, "wprt:OutputBinsType");
	case SOAP_TYPE_wprt__InputBinsType:
		return soap_in_wprt__InputBinsType(soap, NULL, NULL, "wprt:InputBinsType");
	case SOAP_TYPE_wprt__ConsumablesType:
		return soap_in_wprt__ConsumablesType(soap, NULL, NULL, "wprt:ConsumablesType");
	case SOAP_TYPE_wprt__StorageBaseType:
		return soap_in_wprt__StorageBaseType(soap, NULL, NULL, "wprt:StorageBaseType");
	case SOAP_TYPE_wprt__LocalizedStringType:
		return soap_in_wprt__LocalizedStringType(soap, NULL, NULL, "wprt:LocalizedStringType");
	case SOAP_TYPE_wprt__DeviceIdType:
		return soap_in_wprt__DeviceIdType(soap, NULL, NULL, "wprt:DeviceIdType");
	case SOAP_TYPE_wprt__PrinterStatusType:
		return soap_in_wprt__PrinterStatusType(soap, NULL, NULL, "wprt:PrinterStatusType");
	case SOAP_TYPE_wprt__PrinterType:
		return soap_in_wprt__PrinterType(soap, NULL, NULL, "wprt:PrinterType");
	case SOAP_TYPE_wprt__JobElementDataType:
		return soap_in_wprt__JobElementDataType(soap, NULL, NULL, "wprt:JobElementDataType");
	case SOAP_TYPE_wprt__QNameExtType:
		return soap_in_wprt__QNameExtType(soap, NULL, NULL, "wprt:QNameExtType");
	case SOAP_TYPE_wprt__HolePunchPatternType:
		return soap_in_wprt__HolePunchPatternType(soap, NULL, NULL, "wprt:HolePunchPatternType");
	case SOAP_TYPE_wprt__HolePunchEdgeType:
		return soap_in_wprt__HolePunchEdgeType(soap, NULL, NULL, "wprt:HolePunchEdgeType");
	case SOAP_TYPE_wprt__StapleAngleType:
		return soap_in_wprt__StapleAngleType(soap, NULL, NULL, "wprt:StapleAngleType");
	case SOAP_TYPE_wprt__StapleLocationType:
		return soap_in_wprt__StapleLocationType(soap, NULL, NULL, "wprt:StapleLocationType");
	case SOAP_TYPE_wprt__HolePunchDetailsType:
		return soap_in_wprt__HolePunchDetailsType(soap, NULL, NULL, "wprt:HolePunchDetailsType");
	case SOAP_TYPE_wprt__StapleDetailsType:
		return soap_in_wprt__StapleDetailsType(soap, NULL, NULL, "wprt:StapleDetailsType");
	case SOAP_TYPE_wprt__BooleanExtType:
		return soap_in_wprt__BooleanExtType(soap, NULL, NULL, "wprt:BooleanExtType");
	case SOAP_TYPE_wprt__JobPriorityType:
		return soap_in_wprt__JobPriorityType(soap, NULL, NULL, "wprt:JobPriorityType");
	case SOAP_TYPE_wprt__JobFinishingsType:
		return soap_in_wprt__JobFinishingsType(soap, NULL, NULL, "wprt:JobFinishingsType");
	case SOAP_TYPE_wprt__JobCopiesType:
		return soap_in_wprt__JobCopiesType(soap, NULL, NULL, "wprt:JobCopiesType");
	case SOAP_TYPE_wprt__JobProcessingType:
		return soap_in_wprt__JobProcessingType(soap, NULL, NULL, "wprt:JobProcessingType");
	case SOAP_TYPE_wprt__JobDescriptionType:
		return soap_in_wprt__JobDescriptionType(soap, NULL, NULL, "wprt:JobDescriptionType");
	case SOAP_TYPE_wprt__JobStateReasonType:
		return soap_in_wprt__JobStateReasonType(soap, NULL, NULL, "wprt:JobStateReasonType");
	case SOAP_TYPE_wprt__JobSummaryType:
		return soap_in_wprt__JobSummaryType(soap, NULL, NULL, "wprt:JobSummaryType");
	case SOAP_TYPE_wprt__JobType:
		return soap_in_wprt__JobType(soap, NULL, NULL, "wprt:JobType");
	case SOAP_TYPE_wprt__ListOfJobsType:
		return soap_in_wprt__ListOfJobsType(soap, NULL, NULL, "wprt:ListOfJobsType");
	case SOAP_TYPE_wprt__JobTableType:
		return soap_in_wprt__JobTableType(soap, NULL, NULL, "wprt:JobTableType");
	case SOAP_TYPE_wprt__NUpDirectionType:
		return soap_in_wprt__NUpDirectionType(soap, NULL, NULL, "wprt:NUpDirectionType");
	case SOAP_TYPE_wprt__NUpPagesPerSheetType:
		return soap_in_wprt__NUpPagesPerSheetType(soap, NULL, NULL, "wprt:NUpPagesPerSheetType");
	case SOAP_TYPE_wprt__SidesType:
		return soap_in_wprt__SidesType(soap, NULL, NULL, "wprt:SidesType");
	case SOAP_TYPE_wprt__PrintQualityType:
		return soap_in_wprt__PrintQualityType(soap, NULL, NULL, "wprt:PrintQualityType");
	case SOAP_TYPE_wprt__ResolutionType:
		return soap_in_wprt__ResolutionType(soap, NULL, NULL, "wprt:ResolutionType");
	case SOAP_TYPE_wprt__OrientationType:
		return soap_in_wprt__OrientationType(soap, NULL, NULL, "wprt:OrientationType");
	case SOAP_TYPE_wprt__NumberUpType:
		return soap_in_wprt__NumberUpType(soap, NULL, NULL, "wprt:NumberUpType");
	case SOAP_TYPE_wprt__MediaColorType:
		return soap_in_wprt__MediaColorType(soap, NULL, NULL, "wprt:MediaColorType");
	case SOAP_TYPE_wprt__MediaTypeBaseType:
		return soap_in_wprt__MediaTypeBaseType(soap, NULL, NULL, "wprt:MediaTypeBaseType");
	case SOAP_TYPE_wprt__MediaSizeNameType:
		return soap_in_wprt__MediaSizeNameType(soap, NULL, NULL, "wprt:MediaSizeNameType");
	case SOAP_TYPE_wprt__DocumentFormatType:
		return soap_in_wprt__DocumentFormatType(soap, NULL, NULL, "wprt:DocumentFormatType");
	case SOAP_TYPE_wprt__CompressionType:
		return soap_in_wprt__CompressionType(soap, NULL, NULL, "wprt:CompressionType");
	case SOAP_TYPE_wprt__DocumentsType:
		return soap_in_wprt__DocumentsType(soap, NULL, NULL, "wprt:DocumentsType");
	case SOAP_TYPE_wprt__DocumentType:
		return soap_in_wprt__DocumentType(soap, NULL, NULL, "wprt:DocumentType");
	case SOAP_TYPE_wprt__OutputBinEntryType:
		return soap_in_wprt__OutputBinEntryType(soap, NULL, NULL, "wprt:OutputBinEntryType");
	case SOAP_TYPE_wprt__FinishingsType:
		return soap_in_wprt__FinishingsType(soap, NULL, NULL, "wprt:FinishingsType");
	case SOAP_TYPE_wprt__CapacityBaseType:
		return soap_in_wprt__CapacityBaseType(soap, NULL, NULL, "wprt:CapacityBaseType");
	case SOAP_TYPE_wprt__InputBinMediaColorType:
		return soap_in_wprt__InputBinMediaColorType(soap, NULL, NULL, "wprt:InputBinMediaColorType");
	case SOAP_TYPE_wprt__InputBinMediaTypeBaseType:
		return soap_in_wprt__InputBinMediaTypeBaseType(soap, NULL, NULL, "wprt:InputBinMediaTypeBaseType");
	case SOAP_TYPE_wprt__InputBinMediaSizeType:
		return soap_in_wprt__InputBinMediaSizeType(soap, NULL, NULL, "wprt:InputBinMediaSizeType");
	case SOAP_TYPE_wprt__InputBinFeedDirectionType:
		return soap_in_wprt__InputBinFeedDirectionType(soap, NULL, NULL, "wprt:InputBinFeedDirectionType");
	case SOAP_TYPE_wprt__InputBinEntryType:
		return soap_in_wprt__InputBinEntryType(soap, NULL, NULL, "wprt:InputBinEntryType");
	case SOAP_TYPE_wprt__String255ExtType:
		return soap_in_wprt__String255ExtType(soap, NULL, NULL, "wprt:String255ExtType");
	case SOAP_TYPE_wprt__ConsumableColorType:
		return soap_in_wprt__ConsumableColorType(soap, NULL, NULL, "wprt:ConsumableColorType");
	case SOAP_TYPE_wprt__ConsumableTypeBaseType:
		return soap_in_wprt__ConsumableTypeBaseType(soap, NULL, NULL, "wprt:ConsumableTypeBaseType");
	case SOAP_TYPE_wprt__ConsumableEntryType:
		return soap_in_wprt__ConsumableEntryType(soap, NULL, NULL, "wprt:ConsumableEntryType");
	case SOAP_TYPE_wprt__LevelFreeBaseType:
		return soap_in_wprt__LevelFreeBaseType(soap, NULL, NULL, "wprt:LevelFreeBaseType");
	case SOAP_TYPE_wprt__IntOneExtType:
		return soap_in_wprt__IntOneExtType(soap, NULL, NULL, "wprt:IntOneExtType");
	case SOAP_TYPE_wprt__StorageTypeBaseType:
		return soap_in_wprt__StorageTypeBaseType(soap, NULL, NULL, "wprt:StorageTypeBaseType");
	case SOAP_TYPE_wprt__StorageEntryType:
		return soap_in_wprt__StorageEntryType(soap, NULL, NULL, "wprt:StorageEntryType");
	case SOAP_TYPE_wprt__ResolutionEntryType:
		return soap_in_wprt__ResolutionEntryType(soap, NULL, NULL, "wprt:ResolutionEntryType");
	case SOAP_TYPE_wprt__ValueIntRangeType:
		return soap_in_wprt__ValueIntRangeType(soap, NULL, NULL, "wprt:ValueIntRangeType");
	case SOAP_TYPE_wprt__IntExtType:
		return soap_in_wprt__IntExtType(soap, NULL, NULL, "wprt:IntExtType");
	case SOAP_TYPE_wprt__ValueIntListType:
		return soap_in_wprt__ValueIntListType(soap, NULL, NULL, "wprt:ValueIntListType");
	case SOAP_TYPE_wprt__ValueStringListType:
		return soap_in_wprt__ValueStringListType(soap, NULL, NULL, "wprt:ValueStringListType");
	case SOAP_TYPE_wprt__NMTOKENSExtType:
		return soap_in_wprt__NMTOKENSExtType(soap, NULL, NULL, "wprt:NMTOKENSExtType");
	case SOAP_TYPE_wprt__ValueTokenListType:
		return soap_in_wprt__ValueTokenListType(soap, NULL, NULL, "wprt:ValueTokenListType");
	case SOAP_TYPE_wprt__JobEndStateEventType:
		return soap_in_wprt__JobEndStateEventType(soap, NULL, NULL, "wprt:JobEndStateEventType");
	case SOAP_TYPE_wprt__IntZeroExtType:
		return soap_in_wprt__IntZeroExtType(soap, NULL, NULL, "wprt:IntZeroExtType");
	case SOAP_TYPE_wprt__JobOriginatingUserNameType:
		return soap_in_wprt__JobOriginatingUserNameType(soap, NULL, NULL, "wprt:JobOriginatingUserNameType");
	case SOAP_TYPE_wprt__JobNameType:
		return soap_in_wprt__JobNameType(soap, NULL, NULL, "wprt:JobNameType");
	case SOAP_TYPE_wprt__JobStateReasonsType:
		return soap_in_wprt__JobStateReasonsType(soap, NULL, NULL, "wprt:JobStateReasonsType");
	case SOAP_TYPE_wprt__JobStateType:
		return soap_in_wprt__JobStateType(soap, NULL, NULL, "wprt:JobStateType");
	case SOAP_TYPE_wprt__JobEndStateType:
		return soap_in_wprt__JobEndStateType(soap, NULL, NULL, "wprt:JobEndStateType");
	case SOAP_TYPE_wprt__JobStatusType:
		return soap_in_wprt__JobStatusType(soap, NULL, NULL, "wprt:JobStatusType");
	case SOAP_TYPE_wprt__JobStatusEventType:
		return soap_in_wprt__JobStatusEventType(soap, NULL, NULL, "wprt:JobStatusEventType");
	case SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType:
		return soap_in_wprt__PrinterStatusConditionClearedEventType(soap, NULL, NULL, "wprt:PrinterStatusConditionClearedEventType");
	case SOAP_TYPE_wprt__DateTimeExtType:
		return soap_in_wprt__DateTimeExtType(soap, NULL, NULL, "wprt:DateTimeExtType");
	case SOAP_TYPE_wprt__DeviceConditionClearedType:
		return soap_in_wprt__DeviceConditionClearedType(soap, NULL, NULL, "wprt:DeviceConditionClearedType");
	case SOAP_TYPE_wprt__DeviceConditionType:
		return soap_in_wprt__DeviceConditionType(soap, NULL, NULL, "wprt:DeviceConditionType");
	case SOAP_TYPE_wprt__PrinterStatusConditionEventType:
		return soap_in_wprt__PrinterStatusConditionEventType(soap, NULL, NULL, "wprt:PrinterStatusConditionEventType");
	case SOAP_TYPE_wprt__PrinterStatusSummaryEventType:
		return soap_in_wprt__PrinterStatusSummaryEventType(soap, NULL, NULL, "wprt:PrinterStatusSummaryEventType");
	case SOAP_TYPE_wprt__PrinterStateReasonsType:
		return soap_in_wprt__PrinterStateReasonsType(soap, NULL, NULL, "wprt:PrinterStateReasonsType");
	case SOAP_TYPE_wprt__PrinterStateReasonType:
		return soap_in_wprt__PrinterStateReasonType(soap, NULL, NULL, "wprt:PrinterStateReasonType");
	case SOAP_TYPE_wprt__PrinterStateType:
		return soap_in_wprt__PrinterStateType(soap, NULL, NULL, "wprt:PrinterStateType");
	case SOAP_TYPE_wprt__StatusSummaryType:
		return soap_in_wprt__StatusSummaryType(soap, NULL, NULL, "wprt:StatusSummaryType");
	case SOAP_TYPE_wprt__PrinterElementsChangeEventType:
		return soap_in_wprt__PrinterElementsChangeEventType(soap, NULL, NULL, "wprt:PrinterElementsChangeEventType");
	case SOAP_TYPE_wprt__PrinterCapabilitiesType:
		return soap_in_wprt__PrinterCapabilitiesType(soap, NULL, NULL, "wprt:PrinterCapabilitiesType");
	case SOAP_TYPE_wprt__PrinterConfigurationType:
		return soap_in_wprt__PrinterConfigurationType(soap, NULL, NULL, "wprt:PrinterConfigurationType");
	case SOAP_TYPE_wprt__PrinterDescriptionType:
		return soap_in_wprt__PrinterDescriptionType(soap, NULL, NULL, "wprt:PrinterDescriptionType");
	case SOAP_TYPE_wprt__ElementChangesType:
		return soap_in_wprt__ElementChangesType(soap, NULL, NULL, "wprt:ElementChangesType");
	case SOAP_TYPE_wprt__SetEventRateResponseType:
		return soap_in_wprt__SetEventRateResponseType(soap, NULL, NULL, "wprt:SetEventRateResponseType");
	case SOAP_TYPE_wprt__EventRateType:
		return soap_in_wprt__EventRateType(soap, NULL, NULL, "wprt:EventRateType");
	case SOAP_TYPE_wprt__SetEventRateRequestType:
		return soap_in_wprt__SetEventRateRequestType(soap, NULL, NULL, "wprt:SetEventRateRequestType");
	case SOAP_TYPE_wprt__GetJobHistoryResponseType:
		return soap_in_wprt__GetJobHistoryResponseType(soap, NULL, NULL, "wprt:GetJobHistoryResponseType");
	case SOAP_TYPE_wprt__GetJobHistoryRequestType:
		return soap_in_wprt__GetJobHistoryRequestType(soap, NULL, NULL, "wprt:GetJobHistoryRequestType");
	case SOAP_TYPE_wprt__ListOfSummarysType:
		return soap_in_wprt__ListOfSummarysType(soap, NULL, NULL, "wprt:ListOfSummarysType");
	case SOAP_TYPE_wprt__GetActiveJobsResponseType:
		return soap_in_wprt__GetActiveJobsResponseType(soap, NULL, NULL, "wprt:GetActiveJobsResponseType");
	case SOAP_TYPE_wprt__GetActiveJobsRequestType:
		return soap_in_wprt__GetActiveJobsRequestType(soap, NULL, NULL, "wprt:GetActiveJobsRequestType");
	case SOAP_TYPE_wprt__JobElementsType:
		return soap_in_wprt__JobElementsType(soap, NULL, NULL, "wprt:JobElementsType");
	case SOAP_TYPE_wprt__GetJobElementsResponseType:
		return soap_in_wprt__GetJobElementsResponseType(soap, NULL, NULL, "wprt:GetJobElementsResponseType");
	case SOAP_TYPE_wprt__RequestedJobElementsType:
		return soap_in_wprt__RequestedJobElementsType(soap, NULL, NULL, "wprt:RequestedJobElementsType");
	case SOAP_TYPE_wprt__GetJobElementsRequestType:
		return soap_in_wprt__GetJobElementsRequestType(soap, NULL, NULL, "wprt:GetJobElementsRequestType");
	case SOAP_TYPE_wprt__PrinterElementsType:
		return soap_in_wprt__PrinterElementsType(soap, NULL, NULL, "wprt:PrinterElementsType");
	case SOAP_TYPE_wprt__GetPrinterElementsResponseType:
		return soap_in_wprt__GetPrinterElementsResponseType(soap, NULL, NULL, "wprt:GetPrinterElementsResponseType");
	case SOAP_TYPE_wprt__RequestedPrinterElementsType:
		return soap_in_wprt__RequestedPrinterElementsType(soap, NULL, NULL, "wprt:RequestedPrinterElementsType");
	case SOAP_TYPE_wprt__GetPrinterElementsRequestType:
		return soap_in_wprt__GetPrinterElementsRequestType(soap, NULL, NULL, "wprt:GetPrinterElementsRequestType");
	case SOAP_TYPE_wprt__CancelJobResponseType:
		return soap_in_wprt__CancelJobResponseType(soap, NULL, NULL, "wprt:CancelJobResponseType");
	case SOAP_TYPE_wprt__CancelJobRequestType:
		return soap_in_wprt__CancelJobRequestType(soap, NULL, NULL, "wprt:CancelJobRequestType");
	case SOAP_TYPE_wprt__AddDocumentResponseType:
		return soap_in_wprt__AddDocumentResponseType(soap, NULL, NULL, "wprt:AddDocumentResponseType");
	case SOAP_TYPE_wprt__AnyURIExtType:
		return soap_in_wprt__AnyURIExtType(soap, NULL, NULL, "wprt:AnyURIExtType");
	case SOAP_TYPE_wprt__AddDocumentRequestType:
		return soap_in_wprt__AddDocumentRequestType(soap, NULL, NULL, "wprt:AddDocumentRequestType");
	case SOAP_TYPE_wprt__SendDocumentResponseType:
		return soap_in_wprt__SendDocumentResponseType(soap, NULL, NULL, "wprt:SendDocumentResponseType");
	case SOAP_TYPE_wprt__BoolExtType:
		return soap_in_wprt__BoolExtType(soap, NULL, NULL, "wprt:BoolExtType");
	case SOAP_TYPE_wprt__DocumentProcessingType:
		return soap_in_wprt__DocumentProcessingType(soap, NULL, NULL, "wprt:DocumentProcessingType");
	case SOAP_TYPE_wprt__DocumentDescriptionType:
		return soap_in_wprt__DocumentDescriptionType(soap, NULL, NULL, "wprt:DocumentDescriptionType");
	case SOAP_TYPE_wprt__SendDocumentRequestType:
		return soap_in_wprt__SendDocumentRequestType(soap, NULL, NULL, "wprt:SendDocumentRequestType");
	case SOAP_TYPE_wprt__JobIdType:
		return soap_in_wprt__JobIdType(soap, NULL, NULL, "wprt:JobIdType");
	case SOAP_TYPE_wprt__CreatePrintJobResponseType:
		return soap_in_wprt__CreatePrintJobResponseType(soap, NULL, NULL, "wprt:CreatePrintJobResponseType");
	case SOAP_TYPE_wprt__PrintTicketType:
		return soap_in_wprt__PrintTicketType(soap, NULL, NULL, "wprt:PrintTicketType");
	case SOAP_TYPE_wprt__CreatePrintJobRequestType:
		return soap_in_wprt__CreatePrintJobRequestType(soap, NULL, NULL, "wprt:CreatePrintJobRequestType");
	case SOAP_TYPE__xop__Include:
		return soap_in__xop__Include(soap, NULL, NULL, "xop:Include");
	case SOAP_TYPE_PointerToSOAP_ENV__Reason:
		return soap_in_PointerToSOAP_ENV__Reason(soap, NULL, NULL, "SOAP-ENV:Reason");
	case SOAP_TYPE_PointerTowprt__JobEndStateEventType:
		return soap_in_PointerTowprt__JobEndStateEventType(soap, NULL, NULL, "wprt:JobEndStateEventType");
	case SOAP_TYPE_PointerTowprt__JobStatusEventType:
		return soap_in_PointerTowprt__JobStatusEventType(soap, NULL, NULL, "wprt:JobStatusEventType");
	case SOAP_TYPE_PointerTowprt__PrinterStatusConditionClearedEventType:
		return soap_in_PointerTowprt__PrinterStatusConditionClearedEventType(soap, NULL, NULL, "wprt:PrinterStatusConditionClearedEventType");
	case SOAP_TYPE_PointerTowprt__PrinterStatusConditionEventType:
		return soap_in_PointerTowprt__PrinterStatusConditionEventType(soap, NULL, NULL, "wprt:PrinterStatusConditionEventType");
	case SOAP_TYPE_PointerTowprt__PrinterStatusSummaryEventType:
		return soap_in_PointerTowprt__PrinterStatusSummaryEventType(soap, NULL, NULL, "wprt:PrinterStatusSummaryEventType");
	case SOAP_TYPE_PointerTowprt__PrinterElementsChangeEventType:
		return soap_in_PointerTowprt__PrinterElementsChangeEventType(soap, NULL, NULL, "wprt:PrinterElementsChangeEventType");
	case SOAP_TYPE_PointerTowprt__SetEventRateResponseType:
		return soap_in_PointerTowprt__SetEventRateResponseType(soap, NULL, NULL, "wprt:SetEventRateResponseType");
	case SOAP_TYPE_PointerTowprt__SetEventRateRequestType:
		return soap_in_PointerTowprt__SetEventRateRequestType(soap, NULL, NULL, "wprt:SetEventRateRequestType");
	case SOAP_TYPE_PointerTowprt__GetJobHistoryResponseType:
		return soap_in_PointerTowprt__GetJobHistoryResponseType(soap, NULL, NULL, "wprt:GetJobHistoryResponseType");
	case SOAP_TYPE_PointerTowprt__GetJobHistoryRequestType:
		return soap_in_PointerTowprt__GetJobHistoryRequestType(soap, NULL, NULL, "wprt:GetJobHistoryRequestType");
	case SOAP_TYPE_PointerTowprt__GetActiveJobsResponseType:
		return soap_in_PointerTowprt__GetActiveJobsResponseType(soap, NULL, NULL, "wprt:GetActiveJobsResponseType");
	case SOAP_TYPE_PointerTowprt__GetActiveJobsRequestType:
		return soap_in_PointerTowprt__GetActiveJobsRequestType(soap, NULL, NULL, "wprt:GetActiveJobsRequestType");
	case SOAP_TYPE_PointerTowprt__GetJobElementsResponseType:
		return soap_in_PointerTowprt__GetJobElementsResponseType(soap, NULL, NULL, "wprt:GetJobElementsResponseType");
	case SOAP_TYPE_PointerTowprt__GetJobElementsRequestType:
		return soap_in_PointerTowprt__GetJobElementsRequestType(soap, NULL, NULL, "wprt:GetJobElementsRequestType");
	case SOAP_TYPE_PointerTowprt__GetPrinterElementsResponseType:
		return soap_in_PointerTowprt__GetPrinterElementsResponseType(soap, NULL, NULL, "wprt:GetPrinterElementsResponseType");
	case SOAP_TYPE_PointerTowprt__GetPrinterElementsRequestType:
		return soap_in_PointerTowprt__GetPrinterElementsRequestType(soap, NULL, NULL, "wprt:GetPrinterElementsRequestType");
	case SOAP_TYPE_PointerTowprt__CancelJobResponseType:
		return soap_in_PointerTowprt__CancelJobResponseType(soap, NULL, NULL, "wprt:CancelJobResponseType");
	case SOAP_TYPE_PointerTowprt__CancelJobRequestType:
		return soap_in_PointerTowprt__CancelJobRequestType(soap, NULL, NULL, "wprt:CancelJobRequestType");
	case SOAP_TYPE_PointerTowprt__AddDocumentResponseType:
		return soap_in_PointerTowprt__AddDocumentResponseType(soap, NULL, NULL, "wprt:AddDocumentResponseType");
	case SOAP_TYPE_PointerTowprt__AddDocumentRequestType:
		return soap_in_PointerTowprt__AddDocumentRequestType(soap, NULL, NULL, "wprt:AddDocumentRequestType");
	case SOAP_TYPE_PointerTowprt__SendDocumentResponseType:
		return soap_in_PointerTowprt__SendDocumentResponseType(soap, NULL, NULL, "wprt:SendDocumentResponseType");
	case SOAP_TYPE_PointerTowprt__SendDocumentRequestType:
		return soap_in_PointerTowprt__SendDocumentRequestType(soap, NULL, NULL, "wprt:SendDocumentRequestType");
	case SOAP_TYPE_PointerTowprt__CreatePrintJobResponseType:
		return soap_in_PointerTowprt__CreatePrintJobResponseType(soap, NULL, NULL, "wprt:CreatePrintJobResponseType");
	case SOAP_TYPE_PointerTowprt__CreatePrintJobRequestType:
		return soap_in_PointerTowprt__CreatePrintJobRequestType(soap, NULL, NULL, "wprt:CreatePrintJobRequestType");
	case SOAP_TYPE_PointerTowprt__JobTableType:
		return soap_in_PointerTowprt__JobTableType(soap, NULL, NULL, "wprt:JobTableType");
	case SOAP_TYPE_PointerTowprt__PrinterElementDataType:
		return soap_in_PointerTowprt__PrinterElementDataType(soap, NULL, NULL, "wprt:PrinterElementDataType");
	case SOAP_TYPE_PointerTo_wprt__DocumentValuesType_DocumentDescription:
		return soap_in_PointerTo_wprt__DocumentValuesType_DocumentDescription(soap, NULL, NULL, "wprt:DocumentValuesType-DocumentDescription");
	case SOAP_TYPE_PointerTowprt__ValueStringListType:
		return soap_in_PointerTowprt__ValueStringListType(soap, NULL, NULL, "wprt:ValueStringListType");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing:
		return soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing(soap, NULL, NULL, "wprt:JobValuesType-DocumentProcessing");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution:
		return soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(soap, NULL, NULL, "wprt:JobValuesType-DocumentProcessing-Resolution");
	case SOAP_TYPE_PointerTowprt__ResolutionEntryType:
		return soap_in_PointerTowprt__ResolutionEntryType(soap, NULL, NULL, "wprt:ResolutionEntryType");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp:
		return soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(soap, NULL, NULL, "wprt:JobValuesType-DocumentProcessing-NumberUp");
	case SOAP_TYPE_PointerTowprt__ValueIntListType:
		return soap_in_PointerTowprt__ValueIntListType(soap, NULL, NULL, "wprt:ValueIntListType");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing:
		return soap_in_PointerTo_wprt__JobValuesType_JobProcessing(soap, NULL, NULL, "wprt:JobValuesType-JobProcessing");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings:
		return soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(soap, NULL, NULL, "wprt:JobValuesType-JobProcessing-JobFinishings");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch:
		return soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, NULL, NULL, "wprt:JobValuesType-JobProcessing-JobFinishings-HolePunch");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple:
		return soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, NULL, NULL, "wprt:JobValuesType-JobProcessing-JobFinishings-Staple");
	case SOAP_TYPE_PointerTowprt__ValueTokenListType:
		return soap_in_PointerTowprt__ValueTokenListType(soap, NULL, NULL, "wprt:ValueTokenListType");
	case SOAP_TYPE_PointerTowprt__ValueIntRangeType:
		return soap_in_PointerTowprt__ValueIntRangeType(soap, NULL, NULL, "wprt:ValueIntRangeType");
	case SOAP_TYPE_PointerTowprt__DocumentValuesType:
		return soap_in_PointerTowprt__DocumentValuesType(soap, NULL, NULL, "wprt:DocumentValuesType");
	case SOAP_TYPE_PointerTowprt__JobValuesType:
		return soap_in_PointerTowprt__JobValuesType(soap, NULL, NULL, "wprt:JobValuesType");
	case SOAP_TYPE_PointerTowprt__ComponentNameType:
		return soap_in_PointerTowprt__ComponentNameType(soap, NULL, NULL, "wprt:ComponentNameType");
	case SOAP_TYPE_PointerTowprt__ComponentGroupType:
		return soap_in_PointerTowprt__ComponentGroupType(soap, NULL, NULL, "wprt:ComponentGroupType");
	case SOAP_TYPE_PointerTowprt__ConditionSeverityType:
		return soap_in_PointerTowprt__ConditionSeverityType(soap, NULL, NULL, "wprt:ConditionSeverityType");
	case SOAP_TYPE_PointerTowprt__ConditionComponentType:
		return soap_in_PointerTowprt__ConditionComponentType(soap, NULL, NULL, "wprt:ConditionComponentType");
	case SOAP_TYPE_PointerTowprt__ConditionNameType:
		return soap_in_PointerTowprt__ConditionNameType(soap, NULL, NULL, "wprt:ConditionNameType");
	case SOAP_TYPE_PointerTowprt__ConditionHistoryEntryType:
		return soap_in_PointerTowprt__ConditionHistoryEntryType(soap, NULL, NULL, "wprt:ConditionHistoryEntryType");
	case SOAP_TYPE_PointerTowprt__ConditionHistoryTableType:
		return soap_in_PointerTowprt__ConditionHistoryTableType(soap, NULL, NULL, "wprt:ConditionHistoryTableType");
	case SOAP_TYPE_PointerTowprt__ActiveConditionTableType:
		return soap_in_PointerTowprt__ActiveConditionTableType(soap, NULL, NULL, "wprt:ActiveConditionTableType");
	case SOAP_TYPE_PointerTowprt__OutputBinEntryType:
		return soap_in_PointerTowprt__OutputBinEntryType(soap, NULL, NULL, "wprt:OutputBinEntryType");
	case SOAP_TYPE_PointerTowprt__InputBinEntryType:
		return soap_in_PointerTowprt__InputBinEntryType(soap, NULL, NULL, "wprt:InputBinEntryType");
	case SOAP_TYPE_PointerTowprt__ConsumableEntryType:
		return soap_in_PointerTowprt__ConsumableEntryType(soap, NULL, NULL, "wprt:ConsumableEntryType");
	case SOAP_TYPE_PointerTowprt__StorageEntryType:
		return soap_in_PointerTowprt__StorageEntryType(soap, NULL, NULL, "wprt:StorageEntryType");
	case SOAP_TYPE_PointerTowprt__OutputBinsType:
		return soap_in_PointerTowprt__OutputBinsType(soap, NULL, NULL, "wprt:OutputBinsType");
	case SOAP_TYPE_PointerTowprt__FinishingsType:
		return soap_in_PointerTowprt__FinishingsType(soap, NULL, NULL, "wprt:FinishingsType");
	case SOAP_TYPE_PointerTowprt__InputBinsType:
		return soap_in_PointerTowprt__InputBinsType(soap, NULL, NULL, "wprt:InputBinsType");
	case SOAP_TYPE_PointerTowprt__ConsumablesType:
		return soap_in_PointerTowprt__ConsumablesType(soap, NULL, NULL, "wprt:ConsumablesType");
	case SOAP_TYPE_PointerTowprt__StorageBaseType:
		return soap_in_PointerTowprt__StorageBaseType(soap, NULL, NULL, "wprt:StorageBaseType");
	case SOAP_TYPE_PointerTowprt__LocalizedStringType:
		return soap_in_PointerTowprt__LocalizedStringType(soap, NULL, NULL, "wprt:LocalizedStringType");
	case SOAP_TYPE_PointerTowprt__DeviceIdType:
		return soap_in_PointerTowprt__DeviceIdType(soap, NULL, NULL, "wprt:DeviceIdType");
	case SOAP_TYPE_PointerTowprt__PrinterStatusType:
		return soap_in_PointerTowprt__PrinterStatusType(soap, NULL, NULL, "wprt:PrinterStatusType");
	case SOAP_TYPE_PointerTowprt__JobElementDataType:
		return soap_in_PointerTowprt__JobElementDataType(soap, NULL, NULL, "wprt:JobElementDataType");
	case SOAP_TYPE_PointerTowprt__QNameExtType:
		return soap_in_PointerTowprt__QNameExtType(soap, NULL, NULL, "wprt:QNameExtType");
	case SOAP_TYPE_PointerTowprt__HolePunchPatternType:
		return soap_in_PointerTowprt__HolePunchPatternType(soap, NULL, NULL, "wprt:HolePunchPatternType");
	case SOAP_TYPE_PointerTowprt__HolePunchEdgeType:
		return soap_in_PointerTowprt__HolePunchEdgeType(soap, NULL, NULL, "wprt:HolePunchEdgeType");
	case SOAP_TYPE_PointerTowprt__StapleAngleType:
		return soap_in_PointerTowprt__StapleAngleType(soap, NULL, NULL, "wprt:StapleAngleType");
	case SOAP_TYPE_PointerTowprt__StapleLocationType:
		return soap_in_PointerTowprt__StapleLocationType(soap, NULL, NULL, "wprt:StapleLocationType");
	case SOAP_TYPE_PointerTowprt__HolePunchDetailsType:
		return soap_in_PointerTowprt__HolePunchDetailsType(soap, NULL, NULL, "wprt:HolePunchDetailsType");
	case SOAP_TYPE_PointerTowprt__StapleDetailsType:
		return soap_in_PointerTowprt__StapleDetailsType(soap, NULL, NULL, "wprt:StapleDetailsType");
	case SOAP_TYPE_PointerTowprt__BooleanExtType:
		return soap_in_PointerTowprt__BooleanExtType(soap, NULL, NULL, "wprt:BooleanExtType");
	case SOAP_TYPE_PointerTowprt__JobPriorityType:
		return soap_in_PointerTowprt__JobPriorityType(soap, NULL, NULL, "wprt:JobPriorityType");
	case SOAP_TYPE_PointerTowprt__JobFinishingsType:
		return soap_in_PointerTowprt__JobFinishingsType(soap, NULL, NULL, "wprt:JobFinishingsType");
	case SOAP_TYPE_PointerTowprt__JobCopiesType:
		return soap_in_PointerTowprt__JobCopiesType(soap, NULL, NULL, "wprt:JobCopiesType");
	case SOAP_TYPE_PointerTowprt__JobProcessingType:
		return soap_in_PointerTowprt__JobProcessingType(soap, NULL, NULL, "wprt:JobProcessingType");
	case SOAP_TYPE_PointerTowprt__JobDescriptionType:
		return soap_in_PointerTowprt__JobDescriptionType(soap, NULL, NULL, "wprt:JobDescriptionType");
	case SOAP_TYPE_PointerTowprt__JobStateReasonType:
		return soap_in_PointerTowprt__JobStateReasonType(soap, NULL, NULL, "wprt:JobStateReasonType");
	case SOAP_TYPE_PointerTowprt__JobSummaryType:
		return soap_in_PointerTowprt__JobSummaryType(soap, NULL, NULL, "wprt:JobSummaryType");
	case SOAP_TYPE_PointerTowprt__JobType:
		return soap_in_PointerTowprt__JobType(soap, NULL, NULL, "wprt:JobType");
	case SOAP_TYPE_PointerTowprt__DocumentsType:
		return soap_in_PointerTowprt__DocumentsType(soap, NULL, NULL, "wprt:DocumentsType");
	case SOAP_TYPE_PointerTowprt__ListOfJobsType:
		return soap_in_PointerTowprt__ListOfJobsType(soap, NULL, NULL, "wprt:ListOfJobsType");
	case SOAP_TYPE_PointerTowprt__NUpDirectionType:
		return soap_in_PointerTowprt__NUpDirectionType(soap, NULL, NULL, "wprt:NUpDirectionType");
	case SOAP_TYPE_PointerTowprt__NUpPagesPerSheetType:
		return soap_in_PointerTowprt__NUpPagesPerSheetType(soap, NULL, NULL, "wprt:NUpPagesPerSheetType");
	case SOAP_TYPE_PointerTowprt__SidesType:
		return soap_in_PointerTowprt__SidesType(soap, NULL, NULL, "wprt:SidesType");
	case SOAP_TYPE_PointerTowprt__PrintQualityType:
		return soap_in_PointerTowprt__PrintQualityType(soap, NULL, NULL, "wprt:PrintQualityType");
	case SOAP_TYPE_PointerTowprt__ResolutionType:
		return soap_in_PointerTowprt__ResolutionType(soap, NULL, NULL, "wprt:ResolutionType");
	case SOAP_TYPE_PointerTowprt__OrientationType:
		return soap_in_PointerTowprt__OrientationType(soap, NULL, NULL, "wprt:OrientationType");
	case SOAP_TYPE_PointerTowprt__NumberUpType:
		return soap_in_PointerTowprt__NumberUpType(soap, NULL, NULL, "wprt:NumberUpType");
	case SOAP_TYPE_PointerTowprt__MediaColorType:
		return soap_in_PointerTowprt__MediaColorType(soap, NULL, NULL, "wprt:MediaColorType");
	case SOAP_TYPE_PointerTowprt__MediaTypeBaseType:
		return soap_in_PointerTowprt__MediaTypeBaseType(soap, NULL, NULL, "wprt:MediaTypeBaseType");
	case SOAP_TYPE_PointerTowprt__MediaSizeNameType:
		return soap_in_PointerTowprt__MediaSizeNameType(soap, NULL, NULL, "wprt:MediaSizeNameType");
	case SOAP_TYPE_PointerTowprt__DocumentFormatType:
		return soap_in_PointerTowprt__DocumentFormatType(soap, NULL, NULL, "wprt:DocumentFormatType");
	case SOAP_TYPE_PointerTowprt__CompressionType:
		return soap_in_PointerTowprt__CompressionType(soap, NULL, NULL, "wprt:CompressionType");
	case SOAP_TYPE_PointerTowprt__DocumentType:
		return soap_in_PointerTowprt__DocumentType(soap, NULL, NULL, "wprt:DocumentType");
	case SOAP_TYPE_PointerTowprt__CapacityBaseType:
		return soap_in_PointerTowprt__CapacityBaseType(soap, NULL, NULL, "wprt:CapacityBaseType");
	case SOAP_TYPE_PointerTowprt__InputBinMediaColorType:
		return soap_in_PointerTowprt__InputBinMediaColorType(soap, NULL, NULL, "wprt:InputBinMediaColorType");
	case SOAP_TYPE_PointerTowprt__InputBinMediaTypeBaseType:
		return soap_in_PointerTowprt__InputBinMediaTypeBaseType(soap, NULL, NULL, "wprt:InputBinMediaTypeBaseType");
	case SOAP_TYPE_PointerTowprt__InputBinMediaSizeType:
		return soap_in_PointerTowprt__InputBinMediaSizeType(soap, NULL, NULL, "wprt:InputBinMediaSizeType");
	case SOAP_TYPE_PointerTowprt__InputBinFeedDirectionType:
		return soap_in_PointerTowprt__InputBinFeedDirectionType(soap, NULL, NULL, "wprt:InputBinFeedDirectionType");
	case SOAP_TYPE_PointerTowprt__String255ExtType:
		return soap_in_PointerTowprt__String255ExtType(soap, NULL, NULL, "wprt:String255ExtType");
	case SOAP_TYPE_PointerTowprt__ConsumableColorType:
		return soap_in_PointerTowprt__ConsumableColorType(soap, NULL, NULL, "wprt:ConsumableColorType");
	case SOAP_TYPE_PointerTowprt__ConsumableTypeBaseType:
		return soap_in_PointerTowprt__ConsumableTypeBaseType(soap, NULL, NULL, "wprt:ConsumableTypeBaseType");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTowprt__LevelFreeBaseType:
		return soap_in_PointerTowprt__LevelFreeBaseType(soap, NULL, NULL, "wprt:LevelFreeBaseType");
	case SOAP_TYPE_PointerTowprt__IntOneExtType:
		return soap_in_PointerTowprt__IntOneExtType(soap, NULL, NULL, "wprt:IntOneExtType");
	case SOAP_TYPE_PointerTowprt__StorageTypeBaseType:
		return soap_in_PointerTowprt__StorageTypeBaseType(soap, NULL, NULL, "wprt:StorageTypeBaseType");
	case SOAP_TYPE_PointerTowprt__IntExtType:
		return soap_in_PointerTowprt__IntExtType(soap, NULL, NULL, "wprt:IntExtType");
	case SOAP_TYPE_PointerTowprt__NMTOKENSExtType:
		return soap_in_PointerTowprt__NMTOKENSExtType(soap, NULL, NULL, "wprt:NMTOKENSExtType");
	case SOAP_TYPE_PointerTowprt__JobEndStateType:
		return soap_in_PointerTowprt__JobEndStateType(soap, NULL, NULL, "wprt:JobEndStateType");
	case SOAP_TYPE_PointerTowprt__IntZeroExtType:
		return soap_in_PointerTowprt__IntZeroExtType(soap, NULL, NULL, "wprt:IntZeroExtType");
	case SOAP_TYPE_PointerTowprt__JobOriginatingUserNameType:
		return soap_in_PointerTowprt__JobOriginatingUserNameType(soap, NULL, NULL, "wprt:JobOriginatingUserNameType");
	case SOAP_TYPE_PointerTowprt__JobNameType:
		return soap_in_PointerTowprt__JobNameType(soap, NULL, NULL, "wprt:JobNameType");
	case SOAP_TYPE_PointerTowprt__JobStateReasonsType:
		return soap_in_PointerTowprt__JobStateReasonsType(soap, NULL, NULL, "wprt:JobStateReasonsType");
	case SOAP_TYPE_PointerTowprt__JobStateType:
		return soap_in_PointerTowprt__JobStateType(soap, NULL, NULL, "wprt:JobStateType");
	case SOAP_TYPE_PointerTowprt__JobStatusType:
		return soap_in_PointerTowprt__JobStatusType(soap, NULL, NULL, "wprt:JobStatusType");
	case SOAP_TYPE_PointerTowprt__DeviceConditionClearedType:
		return soap_in_PointerTowprt__DeviceConditionClearedType(soap, NULL, NULL, "wprt:DeviceConditionClearedType");
	case SOAP_TYPE_PointerTowprt__DateTimeExtType:
		return soap_in_PointerTowprt__DateTimeExtType(soap, NULL, NULL, "wprt:DateTimeExtType");
	case SOAP_TYPE_PointerTowprt__DeviceConditionType:
		return soap_in_PointerTowprt__DeviceConditionType(soap, NULL, NULL, "wprt:DeviceConditionType");
	case SOAP_TYPE_PointerTowprt__StatusSummaryType:
		return soap_in_PointerTowprt__StatusSummaryType(soap, NULL, NULL, "wprt:StatusSummaryType");
	case SOAP_TYPE_PointerTowprt__PrinterStateReasonsType:
		return soap_in_PointerTowprt__PrinterStateReasonsType(soap, NULL, NULL, "wprt:PrinterStateReasonsType");
	case SOAP_TYPE_PointerTowprt__PrinterStateReasonType:
		return soap_in_PointerTowprt__PrinterStateReasonType(soap, NULL, NULL, "wprt:PrinterStateReasonType");
	case SOAP_TYPE_PointerTowprt__PrinterStateType:
		return soap_in_PointerTowprt__PrinterStateType(soap, NULL, NULL, "wprt:PrinterStateType");
	case SOAP_TYPE_PointerTowprt__ElementChangesType:
		return soap_in_PointerTowprt__ElementChangesType(soap, NULL, NULL, "wprt:ElementChangesType");
	case SOAP_TYPE_PointerTowprt__PrinterCapabilitiesType:
		return soap_in_PointerTowprt__PrinterCapabilitiesType(soap, NULL, NULL, "wprt:PrinterCapabilitiesType");
	case SOAP_TYPE_PointerTowprt__PrinterConfigurationType:
		return soap_in_PointerTowprt__PrinterConfigurationType(soap, NULL, NULL, "wprt:PrinterConfigurationType");
	case SOAP_TYPE_PointerTowprt__PrinterDescriptionType:
		return soap_in_PointerTowprt__PrinterDescriptionType(soap, NULL, NULL, "wprt:PrinterDescriptionType");
	case SOAP_TYPE_PointerTowprt__EventRateType:
		return soap_in_PointerTowprt__EventRateType(soap, NULL, NULL, "wprt:EventRateType");
	case SOAP_TYPE_PointerTowprt__ListOfSummarysType:
		return soap_in_PointerTowprt__ListOfSummarysType(soap, NULL, NULL, "wprt:ListOfSummarysType");
	case SOAP_TYPE_PointerTowprt__JobElementsType:
		return soap_in_PointerTowprt__JobElementsType(soap, NULL, NULL, "wprt:JobElementsType");
	case SOAP_TYPE_PointerTowprt__RequestedJobElementsType:
		return soap_in_PointerTowprt__RequestedJobElementsType(soap, NULL, NULL, "wprt:RequestedJobElementsType");
	case SOAP_TYPE_PointerTowprt__PrinterElementsType:
		return soap_in_PointerTowprt__PrinterElementsType(soap, NULL, NULL, "wprt:PrinterElementsType");
	case SOAP_TYPE_PointerTowprt__RequestedPrinterElementsType:
		return soap_in_PointerTowprt__RequestedPrinterElementsType(soap, NULL, NULL, "wprt:RequestedPrinterElementsType");
	case SOAP_TYPE_PointerTowprt__AnyURIExtType:
		return soap_in_PointerTowprt__AnyURIExtType(soap, NULL, NULL, "wprt:AnyURIExtType");
	case SOAP_TYPE_PointerTowprt__BoolExtType:
		return soap_in_PointerTowprt__BoolExtType(soap, NULL, NULL, "wprt:BoolExtType");
	case SOAP_TYPE_PointerTowprt__DocumentProcessingType:
		return soap_in_PointerTowprt__DocumentProcessingType(soap, NULL, NULL, "wprt:DocumentProcessingType");
	case SOAP_TYPE_PointerTowprt__DocumentDescriptionType:
		return soap_in_PointerTowprt__DocumentDescriptionType(soap, NULL, NULL, "wprt:DocumentDescriptionType");
	case SOAP_TYPE_PointerTowprt__JobIdType:
		return soap_in_PointerTowprt__JobIdType(soap, NULL, NULL, "wprt:JobIdType");
	case SOAP_TYPE_PointerTowprt__PrintTicketType:
		return soap_in_PointerTowprt__PrintTicketType(soap, NULL, NULL, "wprt:PrintTicketType");
	case SOAP_TYPE_wprt__ComponentNameBaseType:
	{	char **s;
		s = soap_in_wprt__ComponentNameBaseType(soap, NULL, NULL, "wprt:ComponentNameBaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__LocalizedStringRestrictType:
	{	char **s;
		s = soap_in_wprt__LocalizedStringRestrictType(soap, NULL, NULL, "wprt:LocalizedStringRestrictType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__DeviceIdBaseType:
	{	char **s;
		s = soap_in_wprt__DeviceIdBaseType(soap, NULL, NULL, "wprt:DeviceIdBaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__JobOriginatingUserNameRestrictionType:
	{	char **s;
		s = soap_in_wprt__JobOriginatingUserNameRestrictionType(soap, NULL, NULL, "wprt:JobOriginatingUserNameRestrictionType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__JobNameRestrictionType:
	{	char **s;
		s = soap_in_wprt__JobNameRestrictionType(soap, NULL, NULL, "wprt:JobNameRestrictionType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__StringNsExtensionPatternType:
	{	char **s;
		s = soap_in_wprt__StringNsExtensionPatternType(soap, NULL, NULL, "wprt:StringNsExtensionPatternType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__OutputBinExtensionPatternType:
	{	char **s;
		s = soap_in_wprt__OutputBinExtensionPatternType(soap, NULL, NULL, "wprt:OutputBinExtensionPatternType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MimeExtensionPatternType:
	{	char **s;
		s = soap_in_wprt__MimeExtensionPatternType(soap, NULL, NULL, "wprt:MimeExtensionPatternType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__KeywordNsExtensionPatternType:
	{	char **s;
		s = soap_in_wprt__KeywordNsExtensionPatternType(soap, NULL, NULL, "wprt:KeywordNsExtensionPatternType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__InputBinExtensionPatternType:
	{	char **s;
		s = soap_in_wprt__InputBinExtensionPatternType(soap, NULL, NULL, "wprt:InputBinExtensionPatternType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MediaNsExtensionPatternType:
	{	char **s;
		s = soap_in_wprt__MediaNsExtensionPatternType(soap, NULL, NULL, "wprt:MediaNsExtensionPatternType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MediaColorExtensionPatternType:
	{	char **s;
		s = soap_in_wprt__MediaColorExtensionPatternType(soap, NULL, NULL, "wprt:MediaColorExtensionPatternType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MediaTypeExtensionPatternType:
	{	char **s;
		s = soap_in_wprt__MediaTypeExtensionPatternType(soap, NULL, NULL, "wprt:MediaTypeExtensionPatternType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MediaSizeNameExtensionPatternType:
	{	char **s;
		s = soap_in_wprt__MediaSizeNameExtensionPatternType(soap, NULL, NULL, "wprt:MediaSizeNameExtensionPatternType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__InputBinMediaColorBaseType:
	{	char **s;
		s = soap_in_wprt__InputBinMediaColorBaseType(soap, NULL, NULL, "wprt:InputBinMediaColorBaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__InputBinMediaSizeBaseType:
	{	char **s;
		s = soap_in_wprt__InputBinMediaSizeBaseType(soap, NULL, NULL, "wprt:InputBinMediaSizeBaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__String255BaseType:
	{	char **s;
		s = soap_in_wprt__String255BaseType(soap, NULL, NULL, "wprt:String255BaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__PrinterStateReasonBaseType:
	{	char **s;
		s = soap_in_wprt__PrinterStateReasonBaseType(soap, NULL, NULL, "wprt:PrinterStateReasonBaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__PrinterStateBaseType:
	{	char **s;
		s = soap_in_wprt__PrinterStateBaseType(soap, NULL, NULL, "wprt:PrinterStateBaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__HolePunchPatternExtType:
	{	char **s;
		s = soap_in_wprt__HolePunchPatternExtType(soap, NULL, NULL, "wprt:HolePunchPatternExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__HolePunchEdgeExtType:
	{	char **s;
		s = soap_in_wprt__HolePunchEdgeExtType(soap, NULL, NULL, "wprt:HolePunchEdgeExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__StapleAngleExtType:
	{	char **s;
		s = soap_in_wprt__StapleAngleExtType(soap, NULL, NULL, "wprt:StapleAngleExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__StapleLocationExtType:
	{	char **s;
		s = soap_in_wprt__StapleLocationExtType(soap, NULL, NULL, "wprt:StapleLocationExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__JobStateReasonExtType:
	{	char **s;
		s = soap_in_wprt__JobStateReasonExtType(soap, NULL, NULL, "wprt:JobStateReasonExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__JobStateExtType:
	{	char **s;
		s = soap_in_wprt__JobStateExtType(soap, NULL, NULL, "wprt:JobStateExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__SidesBaseType:
	{	char **s;
		s = soap_in_wprt__SidesBaseType(soap, NULL, NULL, "wprt:SidesBaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__PrintQualityBaseType:
	{	char **s;
		s = soap_in_wprt__PrintQualityBaseType(soap, NULL, NULL, "wprt:PrintQualityBaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__OrientationBaseType:
	{	char **s;
		s = soap_in_wprt__OrientationBaseType(soap, NULL, NULL, "wprt:OrientationBaseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MediaSizeNameWKVType:
	{	char **s;
		s = soap_in_wprt__MediaSizeNameWKVType(soap, NULL, NULL, "wprt:MediaSizeNameWKVType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MediaWKVType:
	{	char **s;
		s = soap_in_wprt__MediaWKVType(soap, NULL, NULL, "wprt:MediaWKVType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__OutputBinNameType:
	{	char **s;
		s = soap_in_wprt__OutputBinNameType(soap, NULL, NULL, "wprt:OutputBinNameType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__InputBinNameType:
	{	char **s;
		s = soap_in_wprt__InputBinNameType(soap, NULL, NULL, "wprt:InputBinNameType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__ConsumableColorExtType:
	{	char **s;
		s = soap_in_wprt__ConsumableColorExtType(soap, NULL, NULL, "wprt:ConsumableColorExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__ConsumableTypeExtType:
	{	char **s;
		s = soap_in_wprt__ConsumableTypeExtType(soap, NULL, NULL, "wprt:ConsumableTypeExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__StorageTypeExtType:
	{	char **s;
		s = soap_in_wprt__StorageTypeExtType(soap, NULL, NULL, "wprt:StorageTypeExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MediaColorExtType:
	{	char **s;
		s = soap_in_wprt__MediaColorExtType(soap, NULL, NULL, "wprt:MediaColorExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MediaTypeExtType:
	{	char **s;
		s = soap_in_wprt__MediaTypeExtType(soap, NULL, NULL, "wprt:MediaTypeExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__MediaSizeNameExtType:
	{	char **s;
		s = soap_in_wprt__MediaSizeNameExtType(soap, NULL, NULL, "wprt:MediaSizeNameExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__DocumentFormatExtType:
	{	char **s;
		s = soap_in_wprt__DocumentFormatExtType(soap, NULL, NULL, "wprt:DocumentFormatExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wprt__CompressionExtType:
	{	char **s;
		s = soap_in_wprt__CompressionExtType(soap, NULL, NULL, "wprt:CompressionExtType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__QName:
	{	char **s;
		s = soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NMTOKENS:
	{	char **s;
		s = soap_in_xsd__NMTOKENS(soap, NULL, NULL, "xsd:NMTOKENS");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NMTOKEN:
	{	char **s;
		s = soap_in_xsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionIdType"))
		{	*type = SOAP_TYPE_wprt__ConditionIdType;
			return soap_in_wprt__ConditionIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobPriorityRestrictionType"))
		{	*type = SOAP_TYPE_wprt__JobPriorityRestrictionType;
			return soap_in_wprt__JobPriorityRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobCopiesRestrictionType"))
		{	*type = SOAP_TYPE_wprt__JobCopiesRestrictionType;
			return soap_in_wprt__JobCopiesRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobIdRestrictionType"))
		{	*type = SOAP_TYPE_wprt__JobIdRestrictionType;
			return soap_in_wprt__JobIdRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NUpPagesPerSheetRestrictionType"))
		{	*type = SOAP_TYPE_wprt__NUpPagesPerSheetRestrictionType;
			return soap_in_wprt__NUpPagesPerSheetRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:EventRateBaseType"))
		{	*type = SOAP_TYPE_wprt__EventRateBaseType;
			return soap_in_wprt__EventRateBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentIdType"))
		{	*type = SOAP_TYPE_wprt__DocumentIdType;
			return soap_in_wprt__DocumentIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntOneBaseType"))
		{	*type = SOAP_TYPE_wprt__IntOneBaseType;
			return soap_in_wprt__IntOneBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntZeroBaseType"))
		{	*type = SOAP_TYPE_wprt__IntZeroBaseType;
			return soap_in_wprt__IntZeroBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CapacityRestrictType"))
		{	*type = SOAP_TYPE_wprt__CapacityRestrictType;
			return soap_in_wprt__CapacityRestrictType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:LevelFreeRestrictType"))
		{	*type = SOAP_TYPE_wprt__LevelFreeRestrictType;
			return soap_in_wprt__LevelFreeRestrictType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionSeverityBaseType"))
		{	*type = SOAP_TYPE_wprt__ConditionSeverityBaseType;
			return soap_in_wprt__ConditionSeverityBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ComponentGroupBaseType"))
		{	*type = SOAP_TYPE_wprt__ComponentGroupBaseType;
			return soap_in_wprt__ComponentGroupBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionNameBaseType"))
		{	*type = SOAP_TYPE_wprt__ConditionNameBaseType;
			return soap_in_wprt__ConditionNameBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchPatternWKVType"))
		{	*type = SOAP_TYPE_wprt__HolePunchPatternWKVType;
			return soap_in_wprt__HolePunchPatternWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchEdgeWKVType"))
		{	*type = SOAP_TYPE_wprt__HolePunchEdgeWKVType;
			return soap_in_wprt__HolePunchEdgeWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleAngleWKVType"))
		{	*type = SOAP_TYPE_wprt__StapleAngleWKVType;
			return soap_in_wprt__StapleAngleWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleLocationWKVType"))
		{	*type = SOAP_TYPE_wprt__StapleLocationWKVType;
			return soap_in_wprt__StapleLocationWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NUpDirectionRestrictionType"))
		{	*type = SOAP_TYPE_wprt__NUpDirectionRestrictionType;
			return soap_in_wprt__NUpDirectionRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaColorWKVType"))
		{	*type = SOAP_TYPE_wprt__MediaColorWKVType;
			return soap_in_wprt__MediaColorWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaTypeWKVType"))
		{	*type = SOAP_TYPE_wprt__MediaTypeWKVType;
			return soap_in_wprt__MediaTypeWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeSelfDescribingNameWKVType"))
		{	*type = SOAP_TYPE_wprt__MediaSizeSelfDescribingNameWKVType;
			return soap_in_wprt__MediaSizeSelfDescribingNameWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SidesWKVType"))
		{	*type = SOAP_TYPE_wprt__SidesWKVType;
			return soap_in_wprt__SidesWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateReasonsWKVType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateReasonsWKVType;
			return soap_in_wprt__PrinterStateReasonsWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateWKVType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateWKVType;
			return soap_in_wprt__PrinterStateWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrintQualityWKVType"))
		{	*type = SOAP_TYPE_wprt__PrintQualityWKVType;
			return soap_in_wprt__PrintQualityWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinWKVType"))
		{	*type = SOAP_TYPE_wprt__OutputBinWKVType;
			return soap_in_wprt__OutputBinWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OrientationWKVType"))
		{	*type = SOAP_TYPE_wprt__OrientationWKVType;
			return soap_in_wprt__OrientationWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateReasonsWKVType"))
		{	*type = SOAP_TYPE_wprt__JobStateReasonsWKVType;
			return soap_in_wprt__JobStateReasonsWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateWKVType"))
		{	*type = SOAP_TYPE_wprt__JobStateWKVType;
			return soap_in_wprt__JobStateWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinWKVType"))
		{	*type = SOAP_TYPE_wprt__InputBinWKVType;
			return soap_in_wprt__InputBinWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentFormatWKVType"))
		{	*type = SOAP_TYPE_wprt__DocumentFormatWKVType;
			return soap_in_wprt__DocumentFormatWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CompressionWKVType"))
		{	*type = SOAP_TYPE_wprt__CompressionWKVType;
			return soap_in_wprt__CompressionWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinFeedDirectionBaseType"))
		{	*type = SOAP_TYPE_wprt__InputBinFeedDirectionBaseType;
			return soap_in_wprt__InputBinFeedDirectionBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableColorWKVType"))
		{	*type = SOAP_TYPE_wprt__ConsumableColorWKVType;
			return soap_in_wprt__ConsumableColorWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableTypeWKVType"))
		{	*type = SOAP_TYPE_wprt__ConsumableTypeWKVType;
			return soap_in_wprt__ConsumableTypeWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StorageTypeWKVType"))
		{	*type = SOAP_TYPE_wprt__StorageTypeWKVType;
			return soap_in_wprt__StorageTypeWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrintServiceFaultValuesType"))
		{	*type = SOAP_TYPE_wprt__PrintServiceFaultValuesType;
			return soap_in_wprt__PrintServiceFaultValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Reason"))
		{	*type = SOAP_TYPE_SOAP_ENV__Reason;
			return soap_in_SOAP_ENV__Reason(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:Printer"))
		{	*type = SOAP_TYPE__wprt__Printer;
			return soap_in__wprt__Printer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterElementDataType"))
		{	*type = SOAP_TYPE_wprt__PrinterElementDataType;
			return soap_in_wprt__PrinterElementDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentValuesType-DocumentDescription"))
		{	*type = SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription;
			return soap_in__wprt__DocumentValuesType_DocumentDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-DocumentProcessing-Resolution"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution;
			return soap_in__wprt__JobValuesType_DocumentProcessing_Resolution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-DocumentProcessing-NumberUp"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp;
			return soap_in__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-DocumentProcessing"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_DocumentProcessing;
			return soap_in__wprt__JobValuesType_DocumentProcessing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-JobProcessing-JobFinishings-HolePunch"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch;
			return soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-JobProcessing-JobFinishings-Staple"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple;
			return soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-JobProcessing-JobFinishings"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings;
			return soap_in__wprt__JobValuesType_JobProcessing_JobFinishings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-JobProcessing"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_JobProcessing;
			return soap_in__wprt__JobValuesType_JobProcessing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentValuesType"))
		{	*type = SOAP_TYPE_wprt__DocumentValuesType;
			return soap_in_wprt__DocumentValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType"))
		{	*type = SOAP_TYPE_wprt__JobValuesType;
			return soap_in_wprt__JobValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ComponentNameType"))
		{	*type = SOAP_TYPE_wprt__ComponentNameType;
			return soap_in_wprt__ComponentNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ComponentGroupType"))
		{	*type = SOAP_TYPE_wprt__ComponentGroupType;
			return soap_in_wprt__ComponentGroupType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionSeverityType"))
		{	*type = SOAP_TYPE_wprt__ConditionSeverityType;
			return soap_in_wprt__ConditionSeverityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionComponentType"))
		{	*type = SOAP_TYPE_wprt__ConditionComponentType;
			return soap_in_wprt__ConditionComponentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionNameType"))
		{	*type = SOAP_TYPE_wprt__ConditionNameType;
			return soap_in_wprt__ConditionNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionHistoryEntryType"))
		{	*type = SOAP_TYPE_wprt__ConditionHistoryEntryType;
			return soap_in_wprt__ConditionHistoryEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionHistoryTableType"))
		{	*type = SOAP_TYPE_wprt__ConditionHistoryTableType;
			return soap_in_wprt__ConditionHistoryTableType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ActiveConditionTableType"))
		{	*type = SOAP_TYPE_wprt__ActiveConditionTableType;
			return soap_in_wprt__ActiveConditionTableType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinsType"))
		{	*type = SOAP_TYPE_wprt__OutputBinsType;
			return soap_in_wprt__OutputBinsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinsType"))
		{	*type = SOAP_TYPE_wprt__InputBinsType;
			return soap_in_wprt__InputBinsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumablesType"))
		{	*type = SOAP_TYPE_wprt__ConsumablesType;
			return soap_in_wprt__ConsumablesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StorageBaseType"))
		{	*type = SOAP_TYPE_wprt__StorageBaseType;
			return soap_in_wprt__StorageBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:LocalizedStringType"))
		{	*type = SOAP_TYPE_wprt__LocalizedStringType;
			return soap_in_wprt__LocalizedStringType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DeviceIdType"))
		{	*type = SOAP_TYPE_wprt__DeviceIdType;
			return soap_in_wprt__DeviceIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStatusType"))
		{	*type = SOAP_TYPE_wprt__PrinterStatusType;
			return soap_in_wprt__PrinterStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterType"))
		{	*type = SOAP_TYPE_wprt__PrinterType;
			return soap_in_wprt__PrinterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobElementDataType"))
		{	*type = SOAP_TYPE_wprt__JobElementDataType;
			return soap_in_wprt__JobElementDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:QNameExtType"))
		{	*type = SOAP_TYPE_wprt__QNameExtType;
			return soap_in_wprt__QNameExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchPatternType"))
		{	*type = SOAP_TYPE_wprt__HolePunchPatternType;
			return soap_in_wprt__HolePunchPatternType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchEdgeType"))
		{	*type = SOAP_TYPE_wprt__HolePunchEdgeType;
			return soap_in_wprt__HolePunchEdgeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleAngleType"))
		{	*type = SOAP_TYPE_wprt__StapleAngleType;
			return soap_in_wprt__StapleAngleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleLocationType"))
		{	*type = SOAP_TYPE_wprt__StapleLocationType;
			return soap_in_wprt__StapleLocationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchDetailsType"))
		{	*type = SOAP_TYPE_wprt__HolePunchDetailsType;
			return soap_in_wprt__HolePunchDetailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleDetailsType"))
		{	*type = SOAP_TYPE_wprt__StapleDetailsType;
			return soap_in_wprt__StapleDetailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:BooleanExtType"))
		{	*type = SOAP_TYPE_wprt__BooleanExtType;
			return soap_in_wprt__BooleanExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobPriorityType"))
		{	*type = SOAP_TYPE_wprt__JobPriorityType;
			return soap_in_wprt__JobPriorityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobFinishingsType"))
		{	*type = SOAP_TYPE_wprt__JobFinishingsType;
			return soap_in_wprt__JobFinishingsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobCopiesType"))
		{	*type = SOAP_TYPE_wprt__JobCopiesType;
			return soap_in_wprt__JobCopiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobProcessingType"))
		{	*type = SOAP_TYPE_wprt__JobProcessingType;
			return soap_in_wprt__JobProcessingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobDescriptionType"))
		{	*type = SOAP_TYPE_wprt__JobDescriptionType;
			return soap_in_wprt__JobDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateReasonType"))
		{	*type = SOAP_TYPE_wprt__JobStateReasonType;
			return soap_in_wprt__JobStateReasonType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobSummaryType"))
		{	*type = SOAP_TYPE_wprt__JobSummaryType;
			return soap_in_wprt__JobSummaryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobType"))
		{	*type = SOAP_TYPE_wprt__JobType;
			return soap_in_wprt__JobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ListOfJobsType"))
		{	*type = SOAP_TYPE_wprt__ListOfJobsType;
			return soap_in_wprt__ListOfJobsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobTableType"))
		{	*type = SOAP_TYPE_wprt__JobTableType;
			return soap_in_wprt__JobTableType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NUpDirectionType"))
		{	*type = SOAP_TYPE_wprt__NUpDirectionType;
			return soap_in_wprt__NUpDirectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NUpPagesPerSheetType"))
		{	*type = SOAP_TYPE_wprt__NUpPagesPerSheetType;
			return soap_in_wprt__NUpPagesPerSheetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SidesType"))
		{	*type = SOAP_TYPE_wprt__SidesType;
			return soap_in_wprt__SidesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrintQualityType"))
		{	*type = SOAP_TYPE_wprt__PrintQualityType;
			return soap_in_wprt__PrintQualityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ResolutionType"))
		{	*type = SOAP_TYPE_wprt__ResolutionType;
			return soap_in_wprt__ResolutionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OrientationType"))
		{	*type = SOAP_TYPE_wprt__OrientationType;
			return soap_in_wprt__OrientationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NumberUpType"))
		{	*type = SOAP_TYPE_wprt__NumberUpType;
			return soap_in_wprt__NumberUpType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaColorType"))
		{	*type = SOAP_TYPE_wprt__MediaColorType;
			return soap_in_wprt__MediaColorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaTypeBaseType"))
		{	*type = SOAP_TYPE_wprt__MediaTypeBaseType;
			return soap_in_wprt__MediaTypeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeNameType"))
		{	*type = SOAP_TYPE_wprt__MediaSizeNameType;
			return soap_in_wprt__MediaSizeNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentFormatType"))
		{	*type = SOAP_TYPE_wprt__DocumentFormatType;
			return soap_in_wprt__DocumentFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CompressionType"))
		{	*type = SOAP_TYPE_wprt__CompressionType;
			return soap_in_wprt__CompressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentsType"))
		{	*type = SOAP_TYPE_wprt__DocumentsType;
			return soap_in_wprt__DocumentsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentType"))
		{	*type = SOAP_TYPE_wprt__DocumentType;
			return soap_in_wprt__DocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinEntryType"))
		{	*type = SOAP_TYPE_wprt__OutputBinEntryType;
			return soap_in_wprt__OutputBinEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:FinishingsType"))
		{	*type = SOAP_TYPE_wprt__FinishingsType;
			return soap_in_wprt__FinishingsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CapacityBaseType"))
		{	*type = SOAP_TYPE_wprt__CapacityBaseType;
			return soap_in_wprt__CapacityBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaColorType"))
		{	*type = SOAP_TYPE_wprt__InputBinMediaColorType;
			return soap_in_wprt__InputBinMediaColorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaTypeBaseType"))
		{	*type = SOAP_TYPE_wprt__InputBinMediaTypeBaseType;
			return soap_in_wprt__InputBinMediaTypeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaSizeType"))
		{	*type = SOAP_TYPE_wprt__InputBinMediaSizeType;
			return soap_in_wprt__InputBinMediaSizeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinFeedDirectionType"))
		{	*type = SOAP_TYPE_wprt__InputBinFeedDirectionType;
			return soap_in_wprt__InputBinFeedDirectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinEntryType"))
		{	*type = SOAP_TYPE_wprt__InputBinEntryType;
			return soap_in_wprt__InputBinEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:String255ExtType"))
		{	*type = SOAP_TYPE_wprt__String255ExtType;
			return soap_in_wprt__String255ExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableColorType"))
		{	*type = SOAP_TYPE_wprt__ConsumableColorType;
			return soap_in_wprt__ConsumableColorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableTypeBaseType"))
		{	*type = SOAP_TYPE_wprt__ConsumableTypeBaseType;
			return soap_in_wprt__ConsumableTypeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableEntryType"))
		{	*type = SOAP_TYPE_wprt__ConsumableEntryType;
			return soap_in_wprt__ConsumableEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:LevelFreeBaseType"))
		{	*type = SOAP_TYPE_wprt__LevelFreeBaseType;
			return soap_in_wprt__LevelFreeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntOneExtType"))
		{	*type = SOAP_TYPE_wprt__IntOneExtType;
			return soap_in_wprt__IntOneExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StorageTypeBaseType"))
		{	*type = SOAP_TYPE_wprt__StorageTypeBaseType;
			return soap_in_wprt__StorageTypeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StorageEntryType"))
		{	*type = SOAP_TYPE_wprt__StorageEntryType;
			return soap_in_wprt__StorageEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ResolutionEntryType"))
		{	*type = SOAP_TYPE_wprt__ResolutionEntryType;
			return soap_in_wprt__ResolutionEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ValueIntRangeType"))
		{	*type = SOAP_TYPE_wprt__ValueIntRangeType;
			return soap_in_wprt__ValueIntRangeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntExtType"))
		{	*type = SOAP_TYPE_wprt__IntExtType;
			return soap_in_wprt__IntExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ValueIntListType"))
		{	*type = SOAP_TYPE_wprt__ValueIntListType;
			return soap_in_wprt__ValueIntListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ValueStringListType"))
		{	*type = SOAP_TYPE_wprt__ValueStringListType;
			return soap_in_wprt__ValueStringListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NMTOKENSExtType"))
		{	*type = SOAP_TYPE_wprt__NMTOKENSExtType;
			return soap_in_wprt__NMTOKENSExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ValueTokenListType"))
		{	*type = SOAP_TYPE_wprt__ValueTokenListType;
			return soap_in_wprt__ValueTokenListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobEndStateEventType"))
		{	*type = SOAP_TYPE_wprt__JobEndStateEventType;
			return soap_in_wprt__JobEndStateEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntZeroExtType"))
		{	*type = SOAP_TYPE_wprt__IntZeroExtType;
			return soap_in_wprt__IntZeroExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobOriginatingUserNameType"))
		{	*type = SOAP_TYPE_wprt__JobOriginatingUserNameType;
			return soap_in_wprt__JobOriginatingUserNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobNameType"))
		{	*type = SOAP_TYPE_wprt__JobNameType;
			return soap_in_wprt__JobNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateReasonsType"))
		{	*type = SOAP_TYPE_wprt__JobStateReasonsType;
			return soap_in_wprt__JobStateReasonsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateType"))
		{	*type = SOAP_TYPE_wprt__JobStateType;
			return soap_in_wprt__JobStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobEndStateType"))
		{	*type = SOAP_TYPE_wprt__JobEndStateType;
			return soap_in_wprt__JobEndStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStatusType"))
		{	*type = SOAP_TYPE_wprt__JobStatusType;
			return soap_in_wprt__JobStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStatusEventType"))
		{	*type = SOAP_TYPE_wprt__JobStatusEventType;
			return soap_in_wprt__JobStatusEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStatusConditionClearedEventType"))
		{	*type = SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType;
			return soap_in_wprt__PrinterStatusConditionClearedEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DateTimeExtType"))
		{	*type = SOAP_TYPE_wprt__DateTimeExtType;
			return soap_in_wprt__DateTimeExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DeviceConditionClearedType"))
		{	*type = SOAP_TYPE_wprt__DeviceConditionClearedType;
			return soap_in_wprt__DeviceConditionClearedType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DeviceConditionType"))
		{	*type = SOAP_TYPE_wprt__DeviceConditionType;
			return soap_in_wprt__DeviceConditionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStatusConditionEventType"))
		{	*type = SOAP_TYPE_wprt__PrinterStatusConditionEventType;
			return soap_in_wprt__PrinterStatusConditionEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStatusSummaryEventType"))
		{	*type = SOAP_TYPE_wprt__PrinterStatusSummaryEventType;
			return soap_in_wprt__PrinterStatusSummaryEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateReasonsType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateReasonsType;
			return soap_in_wprt__PrinterStateReasonsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateReasonType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateReasonType;
			return soap_in_wprt__PrinterStateReasonType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateType;
			return soap_in_wprt__PrinterStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StatusSummaryType"))
		{	*type = SOAP_TYPE_wprt__StatusSummaryType;
			return soap_in_wprt__StatusSummaryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterElementsChangeEventType"))
		{	*type = SOAP_TYPE_wprt__PrinterElementsChangeEventType;
			return soap_in_wprt__PrinterElementsChangeEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterCapabilitiesType"))
		{	*type = SOAP_TYPE_wprt__PrinterCapabilitiesType;
			return soap_in_wprt__PrinterCapabilitiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterConfigurationType"))
		{	*type = SOAP_TYPE_wprt__PrinterConfigurationType;
			return soap_in_wprt__PrinterConfigurationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterDescriptionType"))
		{	*type = SOAP_TYPE_wprt__PrinterDescriptionType;
			return soap_in_wprt__PrinterDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ElementChangesType"))
		{	*type = SOAP_TYPE_wprt__ElementChangesType;
			return soap_in_wprt__ElementChangesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SetEventRateResponseType"))
		{	*type = SOAP_TYPE_wprt__SetEventRateResponseType;
			return soap_in_wprt__SetEventRateResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:EventRateType"))
		{	*type = SOAP_TYPE_wprt__EventRateType;
			return soap_in_wprt__EventRateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SetEventRateRequestType"))
		{	*type = SOAP_TYPE_wprt__SetEventRateRequestType;
			return soap_in_wprt__SetEventRateRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetJobHistoryResponseType"))
		{	*type = SOAP_TYPE_wprt__GetJobHistoryResponseType;
			return soap_in_wprt__GetJobHistoryResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetJobHistoryRequestType"))
		{	*type = SOAP_TYPE_wprt__GetJobHistoryRequestType;
			return soap_in_wprt__GetJobHistoryRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ListOfSummarysType"))
		{	*type = SOAP_TYPE_wprt__ListOfSummarysType;
			return soap_in_wprt__ListOfSummarysType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetActiveJobsResponseType"))
		{	*type = SOAP_TYPE_wprt__GetActiveJobsResponseType;
			return soap_in_wprt__GetActiveJobsResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetActiveJobsRequestType"))
		{	*type = SOAP_TYPE_wprt__GetActiveJobsRequestType;
			return soap_in_wprt__GetActiveJobsRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobElementsType"))
		{	*type = SOAP_TYPE_wprt__JobElementsType;
			return soap_in_wprt__JobElementsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetJobElementsResponseType"))
		{	*type = SOAP_TYPE_wprt__GetJobElementsResponseType;
			return soap_in_wprt__GetJobElementsResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:RequestedJobElementsType"))
		{	*type = SOAP_TYPE_wprt__RequestedJobElementsType;
			return soap_in_wprt__RequestedJobElementsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetJobElementsRequestType"))
		{	*type = SOAP_TYPE_wprt__GetJobElementsRequestType;
			return soap_in_wprt__GetJobElementsRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterElementsType"))
		{	*type = SOAP_TYPE_wprt__PrinterElementsType;
			return soap_in_wprt__PrinterElementsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetPrinterElementsResponseType"))
		{	*type = SOAP_TYPE_wprt__GetPrinterElementsResponseType;
			return soap_in_wprt__GetPrinterElementsResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:RequestedPrinterElementsType"))
		{	*type = SOAP_TYPE_wprt__RequestedPrinterElementsType;
			return soap_in_wprt__RequestedPrinterElementsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetPrinterElementsRequestType"))
		{	*type = SOAP_TYPE_wprt__GetPrinterElementsRequestType;
			return soap_in_wprt__GetPrinterElementsRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CancelJobResponseType"))
		{	*type = SOAP_TYPE_wprt__CancelJobResponseType;
			return soap_in_wprt__CancelJobResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CancelJobRequestType"))
		{	*type = SOAP_TYPE_wprt__CancelJobRequestType;
			return soap_in_wprt__CancelJobRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:AddDocumentResponseType"))
		{	*type = SOAP_TYPE_wprt__AddDocumentResponseType;
			return soap_in_wprt__AddDocumentResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:AnyURIExtType"))
		{	*type = SOAP_TYPE_wprt__AnyURIExtType;
			return soap_in_wprt__AnyURIExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:AddDocumentRequestType"))
		{	*type = SOAP_TYPE_wprt__AddDocumentRequestType;
			return soap_in_wprt__AddDocumentRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SendDocumentResponseType"))
		{	*type = SOAP_TYPE_wprt__SendDocumentResponseType;
			return soap_in_wprt__SendDocumentResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:BoolExtType"))
		{	*type = SOAP_TYPE_wprt__BoolExtType;
			return soap_in_wprt__BoolExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentProcessingType"))
		{	*type = SOAP_TYPE_wprt__DocumentProcessingType;
			return soap_in_wprt__DocumentProcessingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentDescriptionType"))
		{	*type = SOAP_TYPE_wprt__DocumentDescriptionType;
			return soap_in_wprt__DocumentDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SendDocumentRequestType"))
		{	*type = SOAP_TYPE_wprt__SendDocumentRequestType;
			return soap_in_wprt__SendDocumentRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobIdType"))
		{	*type = SOAP_TYPE_wprt__JobIdType;
			return soap_in_wprt__JobIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CreatePrintJobResponseType"))
		{	*type = SOAP_TYPE_wprt__CreatePrintJobResponseType;
			return soap_in_wprt__CreatePrintJobResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrintTicketType"))
		{	*type = SOAP_TYPE_wprt__PrintTicketType;
			return soap_in_wprt__PrintTicketType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CreatePrintJobRequestType"))
		{	*type = SOAP_TYPE_wprt__CreatePrintJobRequestType;
			return soap_in_wprt__CreatePrintJobRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xop:Include"))
		{	*type = SOAP_TYPE__xop__Include;
			return soap_in__xop__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ComponentNameBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__ComponentNameBaseType;
			s = soap_in_wprt__ComponentNameBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:LocalizedStringRestrictType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__LocalizedStringRestrictType;
			s = soap_in_wprt__LocalizedStringRestrictType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:DeviceIdBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__DeviceIdBaseType;
			s = soap_in_wprt__DeviceIdBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:JobOriginatingUserNameRestrictionType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__JobOriginatingUserNameRestrictionType;
			s = soap_in_wprt__JobOriginatingUserNameRestrictionType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:JobNameRestrictionType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__JobNameRestrictionType;
			s = soap_in_wprt__JobNameRestrictionType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:StringNsExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__StringNsExtensionPatternType;
			s = soap_in_wprt__StringNsExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__OutputBinExtensionPatternType;
			s = soap_in_wprt__OutputBinExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MimeExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MimeExtensionPatternType;
			s = soap_in_wprt__MimeExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:KeywordNsExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__KeywordNsExtensionPatternType;
			s = soap_in_wprt__KeywordNsExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__InputBinExtensionPatternType;
			s = soap_in_wprt__InputBinExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaNsExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaNsExtensionPatternType;
			s = soap_in_wprt__MediaNsExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaColorExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaColorExtensionPatternType;
			s = soap_in_wprt__MediaColorExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaTypeExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaTypeExtensionPatternType;
			s = soap_in_wprt__MediaTypeExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeNameExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaSizeNameExtensionPatternType;
			s = soap_in_wprt__MediaSizeNameExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaColorBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__InputBinMediaColorBaseType;
			s = soap_in_wprt__InputBinMediaColorBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaSizeBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__InputBinMediaSizeBaseType;
			s = soap_in_wprt__InputBinMediaSizeBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:String255BaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__String255BaseType;
			s = soap_in_wprt__String255BaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateReasonBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__PrinterStateReasonBaseType;
			s = soap_in_wprt__PrinterStateReasonBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__PrinterStateBaseType;
			s = soap_in_wprt__PrinterStateBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchPatternExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__HolePunchPatternExtType;
			s = soap_in_wprt__HolePunchPatternExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchEdgeExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__HolePunchEdgeExtType;
			s = soap_in_wprt__HolePunchEdgeExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:StapleAngleExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__StapleAngleExtType;
			s = soap_in_wprt__StapleAngleExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:StapleLocationExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__StapleLocationExtType;
			s = soap_in_wprt__StapleLocationExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateReasonExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__JobStateReasonExtType;
			s = soap_in_wprt__JobStateReasonExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__JobStateExtType;
			s = soap_in_wprt__JobStateExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:SidesBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__SidesBaseType;
			s = soap_in_wprt__SidesBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:PrintQualityBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__PrintQualityBaseType;
			s = soap_in_wprt__PrintQualityBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:OrientationBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__OrientationBaseType;
			s = soap_in_wprt__OrientationBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeNameWKVType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaSizeNameWKVType;
			s = soap_in_wprt__MediaSizeNameWKVType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaWKVType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaWKVType;
			s = soap_in_wprt__MediaWKVType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinNameType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__OutputBinNameType;
			s = soap_in_wprt__OutputBinNameType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinNameType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__InputBinNameType;
			s = soap_in_wprt__InputBinNameType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableColorExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__ConsumableColorExtType;
			s = soap_in_wprt__ConsumableColorExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableTypeExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__ConsumableTypeExtType;
			s = soap_in_wprt__ConsumableTypeExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:StorageTypeExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__StorageTypeExtType;
			s = soap_in_wprt__StorageTypeExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaColorExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaColorExtType;
			s = soap_in_wprt__MediaColorExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaTypeExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaTypeExtType;
			s = soap_in_wprt__MediaTypeExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeNameExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaSizeNameExtType;
			s = soap_in_wprt__MediaSizeNameExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentFormatExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__DocumentFormatExtType;
			s = soap_in_wprt__DocumentFormatExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:CompressionExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__CompressionExtType;
			s = soap_in_wprt__CompressionExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_xsd__QName;
			s = soap_in_xsd__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKENS"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NMTOKENS;
			s = soap_in_xsd__NMTOKENS(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKEN"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NMTOKEN;
			s = soap_in_xsd__NMTOKEN(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionIdType"))
		{	*type = SOAP_TYPE_wprt__ConditionIdType;
			return soap_in_wprt__ConditionIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobPriorityRestrictionType"))
		{	*type = SOAP_TYPE_wprt__JobPriorityRestrictionType;
			return soap_in_wprt__JobPriorityRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobCopiesRestrictionType"))
		{	*type = SOAP_TYPE_wprt__JobCopiesRestrictionType;
			return soap_in_wprt__JobCopiesRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobIdRestrictionType"))
		{	*type = SOAP_TYPE_wprt__JobIdRestrictionType;
			return soap_in_wprt__JobIdRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NUpPagesPerSheetRestrictionType"))
		{	*type = SOAP_TYPE_wprt__NUpPagesPerSheetRestrictionType;
			return soap_in_wprt__NUpPagesPerSheetRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:EventRateBaseType"))
		{	*type = SOAP_TYPE_wprt__EventRateBaseType;
			return soap_in_wprt__EventRateBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentIdType"))
		{	*type = SOAP_TYPE_wprt__DocumentIdType;
			return soap_in_wprt__DocumentIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntOneBaseType"))
		{	*type = SOAP_TYPE_wprt__IntOneBaseType;
			return soap_in_wprt__IntOneBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntZeroBaseType"))
		{	*type = SOAP_TYPE_wprt__IntZeroBaseType;
			return soap_in_wprt__IntZeroBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CapacityRestrictType"))
		{	*type = SOAP_TYPE_wprt__CapacityRestrictType;
			return soap_in_wprt__CapacityRestrictType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:LevelFreeRestrictType"))
		{	*type = SOAP_TYPE_wprt__LevelFreeRestrictType;
			return soap_in_wprt__LevelFreeRestrictType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionSeverityBaseType"))
		{	*type = SOAP_TYPE_wprt__ConditionSeverityBaseType;
			return soap_in_wprt__ConditionSeverityBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ComponentGroupBaseType"))
		{	*type = SOAP_TYPE_wprt__ComponentGroupBaseType;
			return soap_in_wprt__ComponentGroupBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionNameBaseType"))
		{	*type = SOAP_TYPE_wprt__ConditionNameBaseType;
			return soap_in_wprt__ConditionNameBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchPatternWKVType"))
		{	*type = SOAP_TYPE_wprt__HolePunchPatternWKVType;
			return soap_in_wprt__HolePunchPatternWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchEdgeWKVType"))
		{	*type = SOAP_TYPE_wprt__HolePunchEdgeWKVType;
			return soap_in_wprt__HolePunchEdgeWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleAngleWKVType"))
		{	*type = SOAP_TYPE_wprt__StapleAngleWKVType;
			return soap_in_wprt__StapleAngleWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleLocationWKVType"))
		{	*type = SOAP_TYPE_wprt__StapleLocationWKVType;
			return soap_in_wprt__StapleLocationWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NUpDirectionRestrictionType"))
		{	*type = SOAP_TYPE_wprt__NUpDirectionRestrictionType;
			return soap_in_wprt__NUpDirectionRestrictionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaColorWKVType"))
		{	*type = SOAP_TYPE_wprt__MediaColorWKVType;
			return soap_in_wprt__MediaColorWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaTypeWKVType"))
		{	*type = SOAP_TYPE_wprt__MediaTypeWKVType;
			return soap_in_wprt__MediaTypeWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeSelfDescribingNameWKVType"))
		{	*type = SOAP_TYPE_wprt__MediaSizeSelfDescribingNameWKVType;
			return soap_in_wprt__MediaSizeSelfDescribingNameWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SidesWKVType"))
		{	*type = SOAP_TYPE_wprt__SidesWKVType;
			return soap_in_wprt__SidesWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateReasonsWKVType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateReasonsWKVType;
			return soap_in_wprt__PrinterStateReasonsWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateWKVType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateWKVType;
			return soap_in_wprt__PrinterStateWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrintQualityWKVType"))
		{	*type = SOAP_TYPE_wprt__PrintQualityWKVType;
			return soap_in_wprt__PrintQualityWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinWKVType"))
		{	*type = SOAP_TYPE_wprt__OutputBinWKVType;
			return soap_in_wprt__OutputBinWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OrientationWKVType"))
		{	*type = SOAP_TYPE_wprt__OrientationWKVType;
			return soap_in_wprt__OrientationWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateReasonsWKVType"))
		{	*type = SOAP_TYPE_wprt__JobStateReasonsWKVType;
			return soap_in_wprt__JobStateReasonsWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateWKVType"))
		{	*type = SOAP_TYPE_wprt__JobStateWKVType;
			return soap_in_wprt__JobStateWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinWKVType"))
		{	*type = SOAP_TYPE_wprt__InputBinWKVType;
			return soap_in_wprt__InputBinWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentFormatWKVType"))
		{	*type = SOAP_TYPE_wprt__DocumentFormatWKVType;
			return soap_in_wprt__DocumentFormatWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CompressionWKVType"))
		{	*type = SOAP_TYPE_wprt__CompressionWKVType;
			return soap_in_wprt__CompressionWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinFeedDirectionBaseType"))
		{	*type = SOAP_TYPE_wprt__InputBinFeedDirectionBaseType;
			return soap_in_wprt__InputBinFeedDirectionBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableColorWKVType"))
		{	*type = SOAP_TYPE_wprt__ConsumableColorWKVType;
			return soap_in_wprt__ConsumableColorWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableTypeWKVType"))
		{	*type = SOAP_TYPE_wprt__ConsumableTypeWKVType;
			return soap_in_wprt__ConsumableTypeWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StorageTypeWKVType"))
		{	*type = SOAP_TYPE_wprt__StorageTypeWKVType;
			return soap_in_wprt__StorageTypeWKVType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrintServiceFaultValuesType"))
		{	*type = SOAP_TYPE_wprt__PrintServiceFaultValuesType;
			return soap_in_wprt__PrintServiceFaultValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Reason"))
		{	*type = SOAP_TYPE_SOAP_ENV__Reason;
			return soap_in_SOAP_ENV__Reason(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:Printer"))
		{	*type = SOAP_TYPE__wprt__Printer;
			return soap_in__wprt__Printer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterElementDataType"))
		{	*type = SOAP_TYPE_wprt__PrinterElementDataType;
			return soap_in_wprt__PrinterElementDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentValuesType-DocumentDescription"))
		{	*type = SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription;
			return soap_in__wprt__DocumentValuesType_DocumentDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-DocumentProcessing-Resolution"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution;
			return soap_in__wprt__JobValuesType_DocumentProcessing_Resolution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-DocumentProcessing-NumberUp"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp;
			return soap_in__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-DocumentProcessing"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_DocumentProcessing;
			return soap_in__wprt__JobValuesType_DocumentProcessing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-JobProcessing-JobFinishings-HolePunch"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch;
			return soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-JobProcessing-JobFinishings-Staple"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple;
			return soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-JobProcessing-JobFinishings"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings;
			return soap_in__wprt__JobValuesType_JobProcessing_JobFinishings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType-JobProcessing"))
		{	*type = SOAP_TYPE__wprt__JobValuesType_JobProcessing;
			return soap_in__wprt__JobValuesType_JobProcessing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentValuesType"))
		{	*type = SOAP_TYPE_wprt__DocumentValuesType;
			return soap_in_wprt__DocumentValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobValuesType"))
		{	*type = SOAP_TYPE_wprt__JobValuesType;
			return soap_in_wprt__JobValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ComponentNameType"))
		{	*type = SOAP_TYPE_wprt__ComponentNameType;
			return soap_in_wprt__ComponentNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ComponentGroupType"))
		{	*type = SOAP_TYPE_wprt__ComponentGroupType;
			return soap_in_wprt__ComponentGroupType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionSeverityType"))
		{	*type = SOAP_TYPE_wprt__ConditionSeverityType;
			return soap_in_wprt__ConditionSeverityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionComponentType"))
		{	*type = SOAP_TYPE_wprt__ConditionComponentType;
			return soap_in_wprt__ConditionComponentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionNameType"))
		{	*type = SOAP_TYPE_wprt__ConditionNameType;
			return soap_in_wprt__ConditionNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionHistoryEntryType"))
		{	*type = SOAP_TYPE_wprt__ConditionHistoryEntryType;
			return soap_in_wprt__ConditionHistoryEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConditionHistoryTableType"))
		{	*type = SOAP_TYPE_wprt__ConditionHistoryTableType;
			return soap_in_wprt__ConditionHistoryTableType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ActiveConditionTableType"))
		{	*type = SOAP_TYPE_wprt__ActiveConditionTableType;
			return soap_in_wprt__ActiveConditionTableType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinsType"))
		{	*type = SOAP_TYPE_wprt__OutputBinsType;
			return soap_in_wprt__OutputBinsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinsType"))
		{	*type = SOAP_TYPE_wprt__InputBinsType;
			return soap_in_wprt__InputBinsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumablesType"))
		{	*type = SOAP_TYPE_wprt__ConsumablesType;
			return soap_in_wprt__ConsumablesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StorageBaseType"))
		{	*type = SOAP_TYPE_wprt__StorageBaseType;
			return soap_in_wprt__StorageBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:LocalizedStringType"))
		{	*type = SOAP_TYPE_wprt__LocalizedStringType;
			return soap_in_wprt__LocalizedStringType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DeviceIdType"))
		{	*type = SOAP_TYPE_wprt__DeviceIdType;
			return soap_in_wprt__DeviceIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStatusType"))
		{	*type = SOAP_TYPE_wprt__PrinterStatusType;
			return soap_in_wprt__PrinterStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterType"))
		{	*type = SOAP_TYPE_wprt__PrinterType;
			return soap_in_wprt__PrinterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobElementDataType"))
		{	*type = SOAP_TYPE_wprt__JobElementDataType;
			return soap_in_wprt__JobElementDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:QNameExtType"))
		{	*type = SOAP_TYPE_wprt__QNameExtType;
			return soap_in_wprt__QNameExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchPatternType"))
		{	*type = SOAP_TYPE_wprt__HolePunchPatternType;
			return soap_in_wprt__HolePunchPatternType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchEdgeType"))
		{	*type = SOAP_TYPE_wprt__HolePunchEdgeType;
			return soap_in_wprt__HolePunchEdgeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleAngleType"))
		{	*type = SOAP_TYPE_wprt__StapleAngleType;
			return soap_in_wprt__StapleAngleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleLocationType"))
		{	*type = SOAP_TYPE_wprt__StapleLocationType;
			return soap_in_wprt__StapleLocationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchDetailsType"))
		{	*type = SOAP_TYPE_wprt__HolePunchDetailsType;
			return soap_in_wprt__HolePunchDetailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StapleDetailsType"))
		{	*type = SOAP_TYPE_wprt__StapleDetailsType;
			return soap_in_wprt__StapleDetailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:BooleanExtType"))
		{	*type = SOAP_TYPE_wprt__BooleanExtType;
			return soap_in_wprt__BooleanExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobPriorityType"))
		{	*type = SOAP_TYPE_wprt__JobPriorityType;
			return soap_in_wprt__JobPriorityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobFinishingsType"))
		{	*type = SOAP_TYPE_wprt__JobFinishingsType;
			return soap_in_wprt__JobFinishingsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobCopiesType"))
		{	*type = SOAP_TYPE_wprt__JobCopiesType;
			return soap_in_wprt__JobCopiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobProcessingType"))
		{	*type = SOAP_TYPE_wprt__JobProcessingType;
			return soap_in_wprt__JobProcessingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobDescriptionType"))
		{	*type = SOAP_TYPE_wprt__JobDescriptionType;
			return soap_in_wprt__JobDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateReasonType"))
		{	*type = SOAP_TYPE_wprt__JobStateReasonType;
			return soap_in_wprt__JobStateReasonType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobSummaryType"))
		{	*type = SOAP_TYPE_wprt__JobSummaryType;
			return soap_in_wprt__JobSummaryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobType"))
		{	*type = SOAP_TYPE_wprt__JobType;
			return soap_in_wprt__JobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ListOfJobsType"))
		{	*type = SOAP_TYPE_wprt__ListOfJobsType;
			return soap_in_wprt__ListOfJobsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobTableType"))
		{	*type = SOAP_TYPE_wprt__JobTableType;
			return soap_in_wprt__JobTableType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NUpDirectionType"))
		{	*type = SOAP_TYPE_wprt__NUpDirectionType;
			return soap_in_wprt__NUpDirectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NUpPagesPerSheetType"))
		{	*type = SOAP_TYPE_wprt__NUpPagesPerSheetType;
			return soap_in_wprt__NUpPagesPerSheetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SidesType"))
		{	*type = SOAP_TYPE_wprt__SidesType;
			return soap_in_wprt__SidesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrintQualityType"))
		{	*type = SOAP_TYPE_wprt__PrintQualityType;
			return soap_in_wprt__PrintQualityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ResolutionType"))
		{	*type = SOAP_TYPE_wprt__ResolutionType;
			return soap_in_wprt__ResolutionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OrientationType"))
		{	*type = SOAP_TYPE_wprt__OrientationType;
			return soap_in_wprt__OrientationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NumberUpType"))
		{	*type = SOAP_TYPE_wprt__NumberUpType;
			return soap_in_wprt__NumberUpType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaColorType"))
		{	*type = SOAP_TYPE_wprt__MediaColorType;
			return soap_in_wprt__MediaColorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaTypeBaseType"))
		{	*type = SOAP_TYPE_wprt__MediaTypeBaseType;
			return soap_in_wprt__MediaTypeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeNameType"))
		{	*type = SOAP_TYPE_wprt__MediaSizeNameType;
			return soap_in_wprt__MediaSizeNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentFormatType"))
		{	*type = SOAP_TYPE_wprt__DocumentFormatType;
			return soap_in_wprt__DocumentFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CompressionType"))
		{	*type = SOAP_TYPE_wprt__CompressionType;
			return soap_in_wprt__CompressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentsType"))
		{	*type = SOAP_TYPE_wprt__DocumentsType;
			return soap_in_wprt__DocumentsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentType"))
		{	*type = SOAP_TYPE_wprt__DocumentType;
			return soap_in_wprt__DocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinEntryType"))
		{	*type = SOAP_TYPE_wprt__OutputBinEntryType;
			return soap_in_wprt__OutputBinEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:FinishingsType"))
		{	*type = SOAP_TYPE_wprt__FinishingsType;
			return soap_in_wprt__FinishingsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CapacityBaseType"))
		{	*type = SOAP_TYPE_wprt__CapacityBaseType;
			return soap_in_wprt__CapacityBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaColorType"))
		{	*type = SOAP_TYPE_wprt__InputBinMediaColorType;
			return soap_in_wprt__InputBinMediaColorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaTypeBaseType"))
		{	*type = SOAP_TYPE_wprt__InputBinMediaTypeBaseType;
			return soap_in_wprt__InputBinMediaTypeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaSizeType"))
		{	*type = SOAP_TYPE_wprt__InputBinMediaSizeType;
			return soap_in_wprt__InputBinMediaSizeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinFeedDirectionType"))
		{	*type = SOAP_TYPE_wprt__InputBinFeedDirectionType;
			return soap_in_wprt__InputBinFeedDirectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinEntryType"))
		{	*type = SOAP_TYPE_wprt__InputBinEntryType;
			return soap_in_wprt__InputBinEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:String255ExtType"))
		{	*type = SOAP_TYPE_wprt__String255ExtType;
			return soap_in_wprt__String255ExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableColorType"))
		{	*type = SOAP_TYPE_wprt__ConsumableColorType;
			return soap_in_wprt__ConsumableColorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableTypeBaseType"))
		{	*type = SOAP_TYPE_wprt__ConsumableTypeBaseType;
			return soap_in_wprt__ConsumableTypeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableEntryType"))
		{	*type = SOAP_TYPE_wprt__ConsumableEntryType;
			return soap_in_wprt__ConsumableEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:LevelFreeBaseType"))
		{	*type = SOAP_TYPE_wprt__LevelFreeBaseType;
			return soap_in_wprt__LevelFreeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntOneExtType"))
		{	*type = SOAP_TYPE_wprt__IntOneExtType;
			return soap_in_wprt__IntOneExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StorageTypeBaseType"))
		{	*type = SOAP_TYPE_wprt__StorageTypeBaseType;
			return soap_in_wprt__StorageTypeBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StorageEntryType"))
		{	*type = SOAP_TYPE_wprt__StorageEntryType;
			return soap_in_wprt__StorageEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ResolutionEntryType"))
		{	*type = SOAP_TYPE_wprt__ResolutionEntryType;
			return soap_in_wprt__ResolutionEntryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ValueIntRangeType"))
		{	*type = SOAP_TYPE_wprt__ValueIntRangeType;
			return soap_in_wprt__ValueIntRangeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntExtType"))
		{	*type = SOAP_TYPE_wprt__IntExtType;
			return soap_in_wprt__IntExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ValueIntListType"))
		{	*type = SOAP_TYPE_wprt__ValueIntListType;
			return soap_in_wprt__ValueIntListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ValueStringListType"))
		{	*type = SOAP_TYPE_wprt__ValueStringListType;
			return soap_in_wprt__ValueStringListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:NMTOKENSExtType"))
		{	*type = SOAP_TYPE_wprt__NMTOKENSExtType;
			return soap_in_wprt__NMTOKENSExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ValueTokenListType"))
		{	*type = SOAP_TYPE_wprt__ValueTokenListType;
			return soap_in_wprt__ValueTokenListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobEndStateEventType"))
		{	*type = SOAP_TYPE_wprt__JobEndStateEventType;
			return soap_in_wprt__JobEndStateEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:IntZeroExtType"))
		{	*type = SOAP_TYPE_wprt__IntZeroExtType;
			return soap_in_wprt__IntZeroExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobOriginatingUserNameType"))
		{	*type = SOAP_TYPE_wprt__JobOriginatingUserNameType;
			return soap_in_wprt__JobOriginatingUserNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobNameType"))
		{	*type = SOAP_TYPE_wprt__JobNameType;
			return soap_in_wprt__JobNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateReasonsType"))
		{	*type = SOAP_TYPE_wprt__JobStateReasonsType;
			return soap_in_wprt__JobStateReasonsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateType"))
		{	*type = SOAP_TYPE_wprt__JobStateType;
			return soap_in_wprt__JobStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobEndStateType"))
		{	*type = SOAP_TYPE_wprt__JobEndStateType;
			return soap_in_wprt__JobEndStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStatusType"))
		{	*type = SOAP_TYPE_wprt__JobStatusType;
			return soap_in_wprt__JobStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobStatusEventType"))
		{	*type = SOAP_TYPE_wprt__JobStatusEventType;
			return soap_in_wprt__JobStatusEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStatusConditionClearedEventType"))
		{	*type = SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType;
			return soap_in_wprt__PrinterStatusConditionClearedEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DateTimeExtType"))
		{	*type = SOAP_TYPE_wprt__DateTimeExtType;
			return soap_in_wprt__DateTimeExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DeviceConditionClearedType"))
		{	*type = SOAP_TYPE_wprt__DeviceConditionClearedType;
			return soap_in_wprt__DeviceConditionClearedType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DeviceConditionType"))
		{	*type = SOAP_TYPE_wprt__DeviceConditionType;
			return soap_in_wprt__DeviceConditionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStatusConditionEventType"))
		{	*type = SOAP_TYPE_wprt__PrinterStatusConditionEventType;
			return soap_in_wprt__PrinterStatusConditionEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStatusSummaryEventType"))
		{	*type = SOAP_TYPE_wprt__PrinterStatusSummaryEventType;
			return soap_in_wprt__PrinterStatusSummaryEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateReasonsType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateReasonsType;
			return soap_in_wprt__PrinterStateReasonsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateReasonType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateReasonType;
			return soap_in_wprt__PrinterStateReasonType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateType"))
		{	*type = SOAP_TYPE_wprt__PrinterStateType;
			return soap_in_wprt__PrinterStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:StatusSummaryType"))
		{	*type = SOAP_TYPE_wprt__StatusSummaryType;
			return soap_in_wprt__StatusSummaryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterElementsChangeEventType"))
		{	*type = SOAP_TYPE_wprt__PrinterElementsChangeEventType;
			return soap_in_wprt__PrinterElementsChangeEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterCapabilitiesType"))
		{	*type = SOAP_TYPE_wprt__PrinterCapabilitiesType;
			return soap_in_wprt__PrinterCapabilitiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterConfigurationType"))
		{	*type = SOAP_TYPE_wprt__PrinterConfigurationType;
			return soap_in_wprt__PrinterConfigurationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterDescriptionType"))
		{	*type = SOAP_TYPE_wprt__PrinterDescriptionType;
			return soap_in_wprt__PrinterDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ElementChangesType"))
		{	*type = SOAP_TYPE_wprt__ElementChangesType;
			return soap_in_wprt__ElementChangesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SetEventRateResponseType"))
		{	*type = SOAP_TYPE_wprt__SetEventRateResponseType;
			return soap_in_wprt__SetEventRateResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:EventRateType"))
		{	*type = SOAP_TYPE_wprt__EventRateType;
			return soap_in_wprt__EventRateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SetEventRateRequestType"))
		{	*type = SOAP_TYPE_wprt__SetEventRateRequestType;
			return soap_in_wprt__SetEventRateRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetJobHistoryResponseType"))
		{	*type = SOAP_TYPE_wprt__GetJobHistoryResponseType;
			return soap_in_wprt__GetJobHistoryResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetJobHistoryRequestType"))
		{	*type = SOAP_TYPE_wprt__GetJobHistoryRequestType;
			return soap_in_wprt__GetJobHistoryRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ListOfSummarysType"))
		{	*type = SOAP_TYPE_wprt__ListOfSummarysType;
			return soap_in_wprt__ListOfSummarysType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetActiveJobsResponseType"))
		{	*type = SOAP_TYPE_wprt__GetActiveJobsResponseType;
			return soap_in_wprt__GetActiveJobsResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetActiveJobsRequestType"))
		{	*type = SOAP_TYPE_wprt__GetActiveJobsRequestType;
			return soap_in_wprt__GetActiveJobsRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobElementsType"))
		{	*type = SOAP_TYPE_wprt__JobElementsType;
			return soap_in_wprt__JobElementsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetJobElementsResponseType"))
		{	*type = SOAP_TYPE_wprt__GetJobElementsResponseType;
			return soap_in_wprt__GetJobElementsResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:RequestedJobElementsType"))
		{	*type = SOAP_TYPE_wprt__RequestedJobElementsType;
			return soap_in_wprt__RequestedJobElementsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetJobElementsRequestType"))
		{	*type = SOAP_TYPE_wprt__GetJobElementsRequestType;
			return soap_in_wprt__GetJobElementsRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterElementsType"))
		{	*type = SOAP_TYPE_wprt__PrinterElementsType;
			return soap_in_wprt__PrinterElementsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetPrinterElementsResponseType"))
		{	*type = SOAP_TYPE_wprt__GetPrinterElementsResponseType;
			return soap_in_wprt__GetPrinterElementsResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:RequestedPrinterElementsType"))
		{	*type = SOAP_TYPE_wprt__RequestedPrinterElementsType;
			return soap_in_wprt__RequestedPrinterElementsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:GetPrinterElementsRequestType"))
		{	*type = SOAP_TYPE_wprt__GetPrinterElementsRequestType;
			return soap_in_wprt__GetPrinterElementsRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CancelJobResponseType"))
		{	*type = SOAP_TYPE_wprt__CancelJobResponseType;
			return soap_in_wprt__CancelJobResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CancelJobRequestType"))
		{	*type = SOAP_TYPE_wprt__CancelJobRequestType;
			return soap_in_wprt__CancelJobRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:AddDocumentResponseType"))
		{	*type = SOAP_TYPE_wprt__AddDocumentResponseType;
			return soap_in_wprt__AddDocumentResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:AnyURIExtType"))
		{	*type = SOAP_TYPE_wprt__AnyURIExtType;
			return soap_in_wprt__AnyURIExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:AddDocumentRequestType"))
		{	*type = SOAP_TYPE_wprt__AddDocumentRequestType;
			return soap_in_wprt__AddDocumentRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SendDocumentResponseType"))
		{	*type = SOAP_TYPE_wprt__SendDocumentResponseType;
			return soap_in_wprt__SendDocumentResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:BoolExtType"))
		{	*type = SOAP_TYPE_wprt__BoolExtType;
			return soap_in_wprt__BoolExtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentProcessingType"))
		{	*type = SOAP_TYPE_wprt__DocumentProcessingType;
			return soap_in_wprt__DocumentProcessingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentDescriptionType"))
		{	*type = SOAP_TYPE_wprt__DocumentDescriptionType;
			return soap_in_wprt__DocumentDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:SendDocumentRequestType"))
		{	*type = SOAP_TYPE_wprt__SendDocumentRequestType;
			return soap_in_wprt__SendDocumentRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:JobIdType"))
		{	*type = SOAP_TYPE_wprt__JobIdType;
			return soap_in_wprt__JobIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CreatePrintJobResponseType"))
		{	*type = SOAP_TYPE_wprt__CreatePrintJobResponseType;
			return soap_in_wprt__CreatePrintJobResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:PrintTicketType"))
		{	*type = SOAP_TYPE_wprt__PrintTicketType;
			return soap_in_wprt__PrintTicketType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:CreatePrintJobRequestType"))
		{	*type = SOAP_TYPE_wprt__CreatePrintJobRequestType;
			return soap_in_wprt__CreatePrintJobRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xop:Include"))
		{	*type = SOAP_TYPE__xop__Include;
			return soap_in__xop__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wprt:ComponentNameBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__ComponentNameBaseType;
			s = soap_in_wprt__ComponentNameBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:LocalizedStringRestrictType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__LocalizedStringRestrictType;
			s = soap_in_wprt__LocalizedStringRestrictType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:DeviceIdBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__DeviceIdBaseType;
			s = soap_in_wprt__DeviceIdBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:JobOriginatingUserNameRestrictionType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__JobOriginatingUserNameRestrictionType;
			s = soap_in_wprt__JobOriginatingUserNameRestrictionType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:JobNameRestrictionType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__JobNameRestrictionType;
			s = soap_in_wprt__JobNameRestrictionType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:StringNsExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__StringNsExtensionPatternType;
			s = soap_in_wprt__StringNsExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__OutputBinExtensionPatternType;
			s = soap_in_wprt__OutputBinExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MimeExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MimeExtensionPatternType;
			s = soap_in_wprt__MimeExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:KeywordNsExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__KeywordNsExtensionPatternType;
			s = soap_in_wprt__KeywordNsExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__InputBinExtensionPatternType;
			s = soap_in_wprt__InputBinExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaNsExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaNsExtensionPatternType;
			s = soap_in_wprt__MediaNsExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaColorExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaColorExtensionPatternType;
			s = soap_in_wprt__MediaColorExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaTypeExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaTypeExtensionPatternType;
			s = soap_in_wprt__MediaTypeExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeNameExtensionPatternType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaSizeNameExtensionPatternType;
			s = soap_in_wprt__MediaSizeNameExtensionPatternType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaColorBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__InputBinMediaColorBaseType;
			s = soap_in_wprt__InputBinMediaColorBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinMediaSizeBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__InputBinMediaSizeBaseType;
			s = soap_in_wprt__InputBinMediaSizeBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:String255BaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__String255BaseType;
			s = soap_in_wprt__String255BaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateReasonBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__PrinterStateReasonBaseType;
			s = soap_in_wprt__PrinterStateReasonBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:PrinterStateBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__PrinterStateBaseType;
			s = soap_in_wprt__PrinterStateBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchPatternExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__HolePunchPatternExtType;
			s = soap_in_wprt__HolePunchPatternExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:HolePunchEdgeExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__HolePunchEdgeExtType;
			s = soap_in_wprt__HolePunchEdgeExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:StapleAngleExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__StapleAngleExtType;
			s = soap_in_wprt__StapleAngleExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:StapleLocationExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__StapleLocationExtType;
			s = soap_in_wprt__StapleLocationExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateReasonExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__JobStateReasonExtType;
			s = soap_in_wprt__JobStateReasonExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:JobStateExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__JobStateExtType;
			s = soap_in_wprt__JobStateExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:SidesBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__SidesBaseType;
			s = soap_in_wprt__SidesBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:PrintQualityBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__PrintQualityBaseType;
			s = soap_in_wprt__PrintQualityBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:OrientationBaseType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__OrientationBaseType;
			s = soap_in_wprt__OrientationBaseType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeNameWKVType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaSizeNameWKVType;
			s = soap_in_wprt__MediaSizeNameWKVType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaWKVType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaWKVType;
			s = soap_in_wprt__MediaWKVType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:OutputBinNameType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__OutputBinNameType;
			s = soap_in_wprt__OutputBinNameType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:InputBinNameType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__InputBinNameType;
			s = soap_in_wprt__InputBinNameType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableColorExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__ConsumableColorExtType;
			s = soap_in_wprt__ConsumableColorExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:ConsumableTypeExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__ConsumableTypeExtType;
			s = soap_in_wprt__ConsumableTypeExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:StorageTypeExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__StorageTypeExtType;
			s = soap_in_wprt__StorageTypeExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaColorExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaColorExtType;
			s = soap_in_wprt__MediaColorExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaTypeExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaTypeExtType;
			s = soap_in_wprt__MediaTypeExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:MediaSizeNameExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__MediaSizeNameExtType;
			s = soap_in_wprt__MediaSizeNameExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:DocumentFormatExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__DocumentFormatExtType;
			s = soap_in_wprt__DocumentFormatExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wprt:CompressionExtType"))
		{	char **s;
			*type = SOAP_TYPE_wprt__CompressionExtType;
			s = soap_in_wprt__CompressionExtType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_xsd__QName;
			s = soap_in_xsd__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKENS"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NMTOKENS;
			s = soap_in_xsd__NMTOKENS(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKEN"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NMTOKEN;
			s = soap_in_xsd__NMTOKEN(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_wprt__ConditionIdType:
		return soap_out_wprt__ConditionIdType(soap, tag, id, (const int *)ptr, "wprt:ConditionIdType");
	case SOAP_TYPE_wprt__JobPriorityRestrictionType:
		return soap_out_wprt__JobPriorityRestrictionType(soap, tag, id, (const int *)ptr, "wprt:JobPriorityRestrictionType");
	case SOAP_TYPE_wprt__JobCopiesRestrictionType:
		return soap_out_wprt__JobCopiesRestrictionType(soap, tag, id, (const int *)ptr, "wprt:JobCopiesRestrictionType");
	case SOAP_TYPE_wprt__JobIdRestrictionType:
		return soap_out_wprt__JobIdRestrictionType(soap, tag, id, (const int *)ptr, "wprt:JobIdRestrictionType");
	case SOAP_TYPE_wprt__NUpPagesPerSheetRestrictionType:
		return soap_out_wprt__NUpPagesPerSheetRestrictionType(soap, tag, id, (const int *)ptr, "wprt:NUpPagesPerSheetRestrictionType");
	case SOAP_TYPE_wprt__EventRateBaseType:
		return soap_out_wprt__EventRateBaseType(soap, tag, id, (const int *)ptr, "wprt:EventRateBaseType");
	case SOAP_TYPE_wprt__DocumentIdType:
		return soap_out_wprt__DocumentIdType(soap, tag, id, (const int *)ptr, "wprt:DocumentIdType");
	case SOAP_TYPE_wprt__IntOneBaseType:
		return soap_out_wprt__IntOneBaseType(soap, tag, id, (const int *)ptr, "wprt:IntOneBaseType");
	case SOAP_TYPE_wprt__IntZeroBaseType:
		return soap_out_wprt__IntZeroBaseType(soap, tag, id, (const int *)ptr, "wprt:IntZeroBaseType");
	case SOAP_TYPE_wprt__CapacityRestrictType:
		return soap_out_wprt__CapacityRestrictType(soap, tag, id, (const int *)ptr, "wprt:CapacityRestrictType");
	case SOAP_TYPE_wprt__LevelFreeRestrictType:
		return soap_out_wprt__LevelFreeRestrictType(soap, tag, id, (const int *)ptr, "wprt:LevelFreeRestrictType");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_wprt__ConditionSeverityBaseType:
		return soap_out_wprt__ConditionSeverityBaseType(soap, tag, id, (const enum wprt__ConditionSeverityBaseType *)ptr, "wprt:ConditionSeverityBaseType");
	case SOAP_TYPE_wprt__ComponentGroupBaseType:
		return soap_out_wprt__ComponentGroupBaseType(soap, tag, id, (const enum wprt__ComponentGroupBaseType *)ptr, "wprt:ComponentGroupBaseType");
	case SOAP_TYPE_wprt__ConditionNameBaseType:
		return soap_out_wprt__ConditionNameBaseType(soap, tag, id, (const enum wprt__ConditionNameBaseType *)ptr, "wprt:ConditionNameBaseType");
	case SOAP_TYPE_wprt__HolePunchPatternWKVType:
		return soap_out_wprt__HolePunchPatternWKVType(soap, tag, id, (const enum wprt__HolePunchPatternWKVType *)ptr, "wprt:HolePunchPatternWKVType");
	case SOAP_TYPE_wprt__HolePunchEdgeWKVType:
		return soap_out_wprt__HolePunchEdgeWKVType(soap, tag, id, (const enum wprt__HolePunchEdgeWKVType *)ptr, "wprt:HolePunchEdgeWKVType");
	case SOAP_TYPE_wprt__StapleAngleWKVType:
		return soap_out_wprt__StapleAngleWKVType(soap, tag, id, (const enum wprt__StapleAngleWKVType *)ptr, "wprt:StapleAngleWKVType");
	case SOAP_TYPE_wprt__StapleLocationWKVType:
		return soap_out_wprt__StapleLocationWKVType(soap, tag, id, (const enum wprt__StapleLocationWKVType *)ptr, "wprt:StapleLocationWKVType");
	case SOAP_TYPE_wprt__NUpDirectionRestrictionType:
		return soap_out_wprt__NUpDirectionRestrictionType(soap, tag, id, (const enum wprt__NUpDirectionRestrictionType *)ptr, "wprt:NUpDirectionRestrictionType");
	case SOAP_TYPE_wprt__MediaColorWKVType:
		return soap_out_wprt__MediaColorWKVType(soap, tag, id, (const enum wprt__MediaColorWKVType *)ptr, "wprt:MediaColorWKVType");
	case SOAP_TYPE_wprt__MediaTypeWKVType:
		return soap_out_wprt__MediaTypeWKVType(soap, tag, id, (const enum wprt__MediaTypeWKVType *)ptr, "wprt:MediaTypeWKVType");
	case SOAP_TYPE_wprt__MediaSizeSelfDescribingNameWKVType:
		return soap_out_wprt__MediaSizeSelfDescribingNameWKVType(soap, tag, id, (const enum wprt__MediaSizeSelfDescribingNameWKVType *)ptr, "wprt:MediaSizeSelfDescribingNameWKVType");
	case SOAP_TYPE_wprt__SidesWKVType:
		return soap_out_wprt__SidesWKVType(soap, tag, id, (const enum wprt__SidesWKVType *)ptr, "wprt:SidesWKVType");
	case SOAP_TYPE_wprt__PrinterStateReasonsWKVType:
		return soap_out_wprt__PrinterStateReasonsWKVType(soap, tag, id, (const enum wprt__PrinterStateReasonsWKVType *)ptr, "wprt:PrinterStateReasonsWKVType");
	case SOAP_TYPE_wprt__PrinterStateWKVType:
		return soap_out_wprt__PrinterStateWKVType(soap, tag, id, (const enum wprt__PrinterStateWKVType *)ptr, "wprt:PrinterStateWKVType");
	case SOAP_TYPE_wprt__PrintQualityWKVType:
		return soap_out_wprt__PrintQualityWKVType(soap, tag, id, (const enum wprt__PrintQualityWKVType *)ptr, "wprt:PrintQualityWKVType");
	case SOAP_TYPE_wprt__OutputBinWKVType:
		return soap_out_wprt__OutputBinWKVType(soap, tag, id, (const enum wprt__OutputBinWKVType *)ptr, "wprt:OutputBinWKVType");
	case SOAP_TYPE_wprt__OrientationWKVType:
		return soap_out_wprt__OrientationWKVType(soap, tag, id, (const enum wprt__OrientationWKVType *)ptr, "wprt:OrientationWKVType");
	case SOAP_TYPE_wprt__JobStateReasonsWKVType:
		return soap_out_wprt__JobStateReasonsWKVType(soap, tag, id, (const enum wprt__JobStateReasonsWKVType *)ptr, "wprt:JobStateReasonsWKVType");
	case SOAP_TYPE_wprt__JobStateWKVType:
		return soap_out_wprt__JobStateWKVType(soap, tag, id, (const enum wprt__JobStateWKVType *)ptr, "wprt:JobStateWKVType");
	case SOAP_TYPE_wprt__InputBinWKVType:
		return soap_out_wprt__InputBinWKVType(soap, tag, id, (const enum wprt__InputBinWKVType *)ptr, "wprt:InputBinWKVType");
	case SOAP_TYPE_wprt__DocumentFormatWKVType:
		return soap_out_wprt__DocumentFormatWKVType(soap, tag, id, (const enum wprt__DocumentFormatWKVType *)ptr, "wprt:DocumentFormatWKVType");
	case SOAP_TYPE_wprt__CompressionWKVType:
		return soap_out_wprt__CompressionWKVType(soap, tag, id, (const enum wprt__CompressionWKVType *)ptr, "wprt:CompressionWKVType");
	case SOAP_TYPE_wprt__InputBinFeedDirectionBaseType:
		return soap_out_wprt__InputBinFeedDirectionBaseType(soap, tag, id, (const enum wprt__InputBinFeedDirectionBaseType *)ptr, "wprt:InputBinFeedDirectionBaseType");
	case SOAP_TYPE_wprt__ConsumableColorWKVType:
		return soap_out_wprt__ConsumableColorWKVType(soap, tag, id, (const enum wprt__ConsumableColorWKVType *)ptr, "wprt:ConsumableColorWKVType");
	case SOAP_TYPE_wprt__ConsumableTypeWKVType:
		return soap_out_wprt__ConsumableTypeWKVType(soap, tag, id, (const enum wprt__ConsumableTypeWKVType *)ptr, "wprt:ConsumableTypeWKVType");
	case SOAP_TYPE_wprt__StorageTypeWKVType:
		return soap_out_wprt__StorageTypeWKVType(soap, tag, id, (const enum wprt__StorageTypeWKVType *)ptr, "wprt:StorageTypeWKVType");
	case SOAP_TYPE_wprt__PrintServiceFaultValuesType:
		return soap_out_wprt__PrintServiceFaultValuesType(soap, tag, id, (const enum wprt__PrintServiceFaultValuesType *)ptr, "wprt:PrintServiceFaultValuesType");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_SOAP_ENV__Reason:
		return soap_out_SOAP_ENV__Reason(soap, tag, id, (const struct SOAP_ENV__Reason *)ptr, "SOAP-ENV:Reason");
	case SOAP_TYPE__wprt__Printer:
		return soap_out__wprt__Printer(soap, "wprt:Printer", id, (const struct _wprt__Printer *)ptr, NULL);
	case SOAP_TYPE_wprt__PrinterElementDataType:
		return soap_out_wprt__PrinterElementDataType(soap, tag, id, (const struct wprt__PrinterElementDataType *)ptr, "wprt:PrinterElementDataType");
	case SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription:
		return soap_out__wprt__DocumentValuesType_DocumentDescription(soap, "wprt:DocumentValuesType-DocumentDescription", id, (const struct _wprt__DocumentValuesType_DocumentDescription *)ptr, NULL);
	case SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution:
		return soap_out__wprt__JobValuesType_DocumentProcessing_Resolution(soap, "wprt:JobValuesType-DocumentProcessing-Resolution", id, (const struct _wprt__JobValuesType_DocumentProcessing_Resolution *)ptr, NULL);
	case SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp:
		return soap_out__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, "wprt:JobValuesType-DocumentProcessing-NumberUp", id, (const struct _wprt__JobValuesType_DocumentProcessing_NumberUp *)ptr, NULL);
	case SOAP_TYPE__wprt__JobValuesType_DocumentProcessing:
		return soap_out__wprt__JobValuesType_DocumentProcessing(soap, "wprt:JobValuesType-DocumentProcessing", id, (const struct _wprt__JobValuesType_DocumentProcessing *)ptr, NULL);
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch:
		return soap_out__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, "wprt:JobValuesType-JobProcessing-JobFinishings-HolePunch", id, (const struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *)ptr, NULL);
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple:
		return soap_out__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, "wprt:JobValuesType-JobProcessing-JobFinishings-Staple", id, (const struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *)ptr, NULL);
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings:
		return soap_out__wprt__JobValuesType_JobProcessing_JobFinishings(soap, "wprt:JobValuesType-JobProcessing-JobFinishings", id, (const struct _wprt__JobValuesType_JobProcessing_JobFinishings *)ptr, NULL);
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing:
		return soap_out__wprt__JobValuesType_JobProcessing(soap, "wprt:JobValuesType-JobProcessing", id, (const struct _wprt__JobValuesType_JobProcessing *)ptr, NULL);
	case SOAP_TYPE_wprt__DocumentValuesType:
		return soap_out_wprt__DocumentValuesType(soap, tag, id, (const struct wprt__DocumentValuesType *)ptr, "wprt:DocumentValuesType");
	case SOAP_TYPE_wprt__JobValuesType:
		return soap_out_wprt__JobValuesType(soap, tag, id, (const struct wprt__JobValuesType *)ptr, "wprt:JobValuesType");
	case SOAP_TYPE_wprt__ComponentNameType:
		return soap_out_wprt__ComponentNameType(soap, tag, id, (const struct wprt__ComponentNameType *)ptr, "wprt:ComponentNameType");
	case SOAP_TYPE_wprt__ComponentGroupType:
		return soap_out_wprt__ComponentGroupType(soap, tag, id, (const struct wprt__ComponentGroupType *)ptr, "wprt:ComponentGroupType");
	case SOAP_TYPE_wprt__ConditionSeverityType:
		return soap_out_wprt__ConditionSeverityType(soap, tag, id, (const struct wprt__ConditionSeverityType *)ptr, "wprt:ConditionSeverityType");
	case SOAP_TYPE_wprt__ConditionComponentType:
		return soap_out_wprt__ConditionComponentType(soap, tag, id, (const struct wprt__ConditionComponentType *)ptr, "wprt:ConditionComponentType");
	case SOAP_TYPE_wprt__ConditionNameType:
		return soap_out_wprt__ConditionNameType(soap, tag, id, (const struct wprt__ConditionNameType *)ptr, "wprt:ConditionNameType");
	case SOAP_TYPE_wprt__ConditionHistoryEntryType:
		return soap_out_wprt__ConditionHistoryEntryType(soap, tag, id, (const struct wprt__ConditionHistoryEntryType *)ptr, "wprt:ConditionHistoryEntryType");
	case SOAP_TYPE_wprt__ConditionHistoryTableType:
		return soap_out_wprt__ConditionHistoryTableType(soap, tag, id, (const struct wprt__ConditionHistoryTableType *)ptr, "wprt:ConditionHistoryTableType");
	case SOAP_TYPE_wprt__ActiveConditionTableType:
		return soap_out_wprt__ActiveConditionTableType(soap, tag, id, (const struct wprt__ActiveConditionTableType *)ptr, "wprt:ActiveConditionTableType");
	case SOAP_TYPE_wprt__OutputBinsType:
		return soap_out_wprt__OutputBinsType(soap, tag, id, (const struct wprt__OutputBinsType *)ptr, "wprt:OutputBinsType");
	case SOAP_TYPE_wprt__InputBinsType:
		return soap_out_wprt__InputBinsType(soap, tag, id, (const struct wprt__InputBinsType *)ptr, "wprt:InputBinsType");
	case SOAP_TYPE_wprt__ConsumablesType:
		return soap_out_wprt__ConsumablesType(soap, tag, id, (const struct wprt__ConsumablesType *)ptr, "wprt:ConsumablesType");
	case SOAP_TYPE_wprt__StorageBaseType:
		return soap_out_wprt__StorageBaseType(soap, tag, id, (const struct wprt__StorageBaseType *)ptr, "wprt:StorageBaseType");
	case SOAP_TYPE_wprt__LocalizedStringType:
		return soap_out_wprt__LocalizedStringType(soap, tag, id, (const struct wprt__LocalizedStringType *)ptr, "wprt:LocalizedStringType");
	case SOAP_TYPE_wprt__DeviceIdType:
		return soap_out_wprt__DeviceIdType(soap, tag, id, (const struct wprt__DeviceIdType *)ptr, "wprt:DeviceIdType");
	case SOAP_TYPE_wprt__PrinterStatusType:
		return soap_out_wprt__PrinterStatusType(soap, tag, id, (const struct wprt__PrinterStatusType *)ptr, "wprt:PrinterStatusType");
	case SOAP_TYPE_wprt__PrinterType:
		return soap_out_wprt__PrinterType(soap, tag, id, (const struct wprt__PrinterType *)ptr, "wprt:PrinterType");
	case SOAP_TYPE_wprt__JobElementDataType:
		return soap_out_wprt__JobElementDataType(soap, tag, id, (const struct wprt__JobElementDataType *)ptr, "wprt:JobElementDataType");
	case SOAP_TYPE_wprt__QNameExtType:
		return soap_out_wprt__QNameExtType(soap, tag, id, (const struct wprt__QNameExtType *)ptr, "wprt:QNameExtType");
	case SOAP_TYPE_wprt__HolePunchPatternType:
		return soap_out_wprt__HolePunchPatternType(soap, tag, id, (const struct wprt__HolePunchPatternType *)ptr, "wprt:HolePunchPatternType");
	case SOAP_TYPE_wprt__HolePunchEdgeType:
		return soap_out_wprt__HolePunchEdgeType(soap, tag, id, (const struct wprt__HolePunchEdgeType *)ptr, "wprt:HolePunchEdgeType");
	case SOAP_TYPE_wprt__StapleAngleType:
		return soap_out_wprt__StapleAngleType(soap, tag, id, (const struct wprt__StapleAngleType *)ptr, "wprt:StapleAngleType");
	case SOAP_TYPE_wprt__StapleLocationType:
		return soap_out_wprt__StapleLocationType(soap, tag, id, (const struct wprt__StapleLocationType *)ptr, "wprt:StapleLocationType");
	case SOAP_TYPE_wprt__HolePunchDetailsType:
		return soap_out_wprt__HolePunchDetailsType(soap, tag, id, (const struct wprt__HolePunchDetailsType *)ptr, "wprt:HolePunchDetailsType");
	case SOAP_TYPE_wprt__StapleDetailsType:
		return soap_out_wprt__StapleDetailsType(soap, tag, id, (const struct wprt__StapleDetailsType *)ptr, "wprt:StapleDetailsType");
	case SOAP_TYPE_wprt__BooleanExtType:
		return soap_out_wprt__BooleanExtType(soap, tag, id, (const struct wprt__BooleanExtType *)ptr, "wprt:BooleanExtType");
	case SOAP_TYPE_wprt__JobPriorityType:
		return soap_out_wprt__JobPriorityType(soap, tag, id, (const struct wprt__JobPriorityType *)ptr, "wprt:JobPriorityType");
	case SOAP_TYPE_wprt__JobFinishingsType:
		return soap_out_wprt__JobFinishingsType(soap, tag, id, (const struct wprt__JobFinishingsType *)ptr, "wprt:JobFinishingsType");
	case SOAP_TYPE_wprt__JobCopiesType:
		return soap_out_wprt__JobCopiesType(soap, tag, id, (const struct wprt__JobCopiesType *)ptr, "wprt:JobCopiesType");
	case SOAP_TYPE_wprt__JobProcessingType:
		return soap_out_wprt__JobProcessingType(soap, tag, id, (const struct wprt__JobProcessingType *)ptr, "wprt:JobProcessingType");
	case SOAP_TYPE_wprt__JobDescriptionType:
		return soap_out_wprt__JobDescriptionType(soap, tag, id, (const struct wprt__JobDescriptionType *)ptr, "wprt:JobDescriptionType");
	case SOAP_TYPE_wprt__JobStateReasonType:
		return soap_out_wprt__JobStateReasonType(soap, tag, id, (const struct wprt__JobStateReasonType *)ptr, "wprt:JobStateReasonType");
	case SOAP_TYPE_wprt__JobSummaryType:
		return soap_out_wprt__JobSummaryType(soap, tag, id, (const struct wprt__JobSummaryType *)ptr, "wprt:JobSummaryType");
	case SOAP_TYPE_wprt__JobType:
		return soap_out_wprt__JobType(soap, tag, id, (const struct wprt__JobType *)ptr, "wprt:JobType");
	case SOAP_TYPE_wprt__ListOfJobsType:
		return soap_out_wprt__ListOfJobsType(soap, tag, id, (const struct wprt__ListOfJobsType *)ptr, "wprt:ListOfJobsType");
	case SOAP_TYPE_wprt__JobTableType:
		return soap_out_wprt__JobTableType(soap, tag, id, (const struct wprt__JobTableType *)ptr, "wprt:JobTableType");
	case SOAP_TYPE_wprt__NUpDirectionType:
		return soap_out_wprt__NUpDirectionType(soap, tag, id, (const struct wprt__NUpDirectionType *)ptr, "wprt:NUpDirectionType");
	case SOAP_TYPE_wprt__NUpPagesPerSheetType:
		return soap_out_wprt__NUpPagesPerSheetType(soap, tag, id, (const struct wprt__NUpPagesPerSheetType *)ptr, "wprt:NUpPagesPerSheetType");
	case SOAP_TYPE_wprt__SidesType:
		return soap_out_wprt__SidesType(soap, tag, id, (const struct wprt__SidesType *)ptr, "wprt:SidesType");
	case SOAP_TYPE_wprt__PrintQualityType:
		return soap_out_wprt__PrintQualityType(soap, tag, id, (const struct wprt__PrintQualityType *)ptr, "wprt:PrintQualityType");
	case SOAP_TYPE_wprt__ResolutionType:
		return soap_out_wprt__ResolutionType(soap, tag, id, (const struct wprt__ResolutionType *)ptr, "wprt:ResolutionType");
	case SOAP_TYPE_wprt__OrientationType:
		return soap_out_wprt__OrientationType(soap, tag, id, (const struct wprt__OrientationType *)ptr, "wprt:OrientationType");
	case SOAP_TYPE_wprt__NumberUpType:
		return soap_out_wprt__NumberUpType(soap, tag, id, (const struct wprt__NumberUpType *)ptr, "wprt:NumberUpType");
	case SOAP_TYPE_wprt__MediaColorType:
		return soap_out_wprt__MediaColorType(soap, tag, id, (const struct wprt__MediaColorType *)ptr, "wprt:MediaColorType");
	case SOAP_TYPE_wprt__MediaTypeBaseType:
		return soap_out_wprt__MediaTypeBaseType(soap, tag, id, (const struct wprt__MediaTypeBaseType *)ptr, "wprt:MediaTypeBaseType");
	case SOAP_TYPE_wprt__MediaSizeNameType:
		return soap_out_wprt__MediaSizeNameType(soap, tag, id, (const struct wprt__MediaSizeNameType *)ptr, "wprt:MediaSizeNameType");
	case SOAP_TYPE_wprt__DocumentFormatType:
		return soap_out_wprt__DocumentFormatType(soap, tag, id, (const struct wprt__DocumentFormatType *)ptr, "wprt:DocumentFormatType");
	case SOAP_TYPE_wprt__CompressionType:
		return soap_out_wprt__CompressionType(soap, tag, id, (const struct wprt__CompressionType *)ptr, "wprt:CompressionType");
	case SOAP_TYPE_wprt__DocumentsType:
		return soap_out_wprt__DocumentsType(soap, tag, id, (const struct wprt__DocumentsType *)ptr, "wprt:DocumentsType");
	case SOAP_TYPE_wprt__DocumentType:
		return soap_out_wprt__DocumentType(soap, tag, id, (const struct wprt__DocumentType *)ptr, "wprt:DocumentType");
	case SOAP_TYPE_wprt__OutputBinEntryType:
		return soap_out_wprt__OutputBinEntryType(soap, tag, id, (const struct wprt__OutputBinEntryType *)ptr, "wprt:OutputBinEntryType");
	case SOAP_TYPE_wprt__FinishingsType:
		return soap_out_wprt__FinishingsType(soap, tag, id, (const struct wprt__FinishingsType *)ptr, "wprt:FinishingsType");
	case SOAP_TYPE_wprt__CapacityBaseType:
		return soap_out_wprt__CapacityBaseType(soap, tag, id, (const struct wprt__CapacityBaseType *)ptr, "wprt:CapacityBaseType");
	case SOAP_TYPE_wprt__InputBinMediaColorType:
		return soap_out_wprt__InputBinMediaColorType(soap, tag, id, (const struct wprt__InputBinMediaColorType *)ptr, "wprt:InputBinMediaColorType");
	case SOAP_TYPE_wprt__InputBinMediaTypeBaseType:
		return soap_out_wprt__InputBinMediaTypeBaseType(soap, tag, id, (const struct wprt__InputBinMediaTypeBaseType *)ptr, "wprt:InputBinMediaTypeBaseType");
	case SOAP_TYPE_wprt__InputBinMediaSizeType:
		return soap_out_wprt__InputBinMediaSizeType(soap, tag, id, (const struct wprt__InputBinMediaSizeType *)ptr, "wprt:InputBinMediaSizeType");
	case SOAP_TYPE_wprt__InputBinFeedDirectionType:
		return soap_out_wprt__InputBinFeedDirectionType(soap, tag, id, (const struct wprt__InputBinFeedDirectionType *)ptr, "wprt:InputBinFeedDirectionType");
	case SOAP_TYPE_wprt__InputBinEntryType:
		return soap_out_wprt__InputBinEntryType(soap, tag, id, (const struct wprt__InputBinEntryType *)ptr, "wprt:InputBinEntryType");
	case SOAP_TYPE_wprt__String255ExtType:
		return soap_out_wprt__String255ExtType(soap, tag, id, (const struct wprt__String255ExtType *)ptr, "wprt:String255ExtType");
	case SOAP_TYPE_wprt__ConsumableColorType:
		return soap_out_wprt__ConsumableColorType(soap, tag, id, (const struct wprt__ConsumableColorType *)ptr, "wprt:ConsumableColorType");
	case SOAP_TYPE_wprt__ConsumableTypeBaseType:
		return soap_out_wprt__ConsumableTypeBaseType(soap, tag, id, (const struct wprt__ConsumableTypeBaseType *)ptr, "wprt:ConsumableTypeBaseType");
	case SOAP_TYPE_wprt__ConsumableEntryType:
		return soap_out_wprt__ConsumableEntryType(soap, tag, id, (const struct wprt__ConsumableEntryType *)ptr, "wprt:ConsumableEntryType");
	case SOAP_TYPE_wprt__LevelFreeBaseType:
		return soap_out_wprt__LevelFreeBaseType(soap, tag, id, (const struct wprt__LevelFreeBaseType *)ptr, "wprt:LevelFreeBaseType");
	case SOAP_TYPE_wprt__IntOneExtType:
		return soap_out_wprt__IntOneExtType(soap, tag, id, (const struct wprt__IntOneExtType *)ptr, "wprt:IntOneExtType");
	case SOAP_TYPE_wprt__StorageTypeBaseType:
		return soap_out_wprt__StorageTypeBaseType(soap, tag, id, (const struct wprt__StorageTypeBaseType *)ptr, "wprt:StorageTypeBaseType");
	case SOAP_TYPE_wprt__StorageEntryType:
		return soap_out_wprt__StorageEntryType(soap, tag, id, (const struct wprt__StorageEntryType *)ptr, "wprt:StorageEntryType");
	case SOAP_TYPE_wprt__ResolutionEntryType:
		return soap_out_wprt__ResolutionEntryType(soap, tag, id, (const struct wprt__ResolutionEntryType *)ptr, "wprt:ResolutionEntryType");
	case SOAP_TYPE_wprt__ValueIntRangeType:
		return soap_out_wprt__ValueIntRangeType(soap, tag, id, (const struct wprt__ValueIntRangeType *)ptr, "wprt:ValueIntRangeType");
	case SOAP_TYPE_wprt__IntExtType:
		return soap_out_wprt__IntExtType(soap, tag, id, (const struct wprt__IntExtType *)ptr, "wprt:IntExtType");
	case SOAP_TYPE_wprt__ValueIntListType:
		return soap_out_wprt__ValueIntListType(soap, tag, id, (const struct wprt__ValueIntListType *)ptr, "wprt:ValueIntListType");
	case SOAP_TYPE_wprt__ValueStringListType:
		return soap_out_wprt__ValueStringListType(soap, tag, id, (const struct wprt__ValueStringListType *)ptr, "wprt:ValueStringListType");
	case SOAP_TYPE_wprt__NMTOKENSExtType:
		return soap_out_wprt__NMTOKENSExtType(soap, tag, id, (const struct wprt__NMTOKENSExtType *)ptr, "wprt:NMTOKENSExtType");
	case SOAP_TYPE_wprt__ValueTokenListType:
		return soap_out_wprt__ValueTokenListType(soap, tag, id, (const struct wprt__ValueTokenListType *)ptr, "wprt:ValueTokenListType");
	case SOAP_TYPE_wprt__JobEndStateEventType:
		return soap_out_wprt__JobEndStateEventType(soap, tag, id, (const struct wprt__JobEndStateEventType *)ptr, "wprt:JobEndStateEventType");
	case SOAP_TYPE_wprt__IntZeroExtType:
		return soap_out_wprt__IntZeroExtType(soap, tag, id, (const struct wprt__IntZeroExtType *)ptr, "wprt:IntZeroExtType");
	case SOAP_TYPE_wprt__JobOriginatingUserNameType:
		return soap_out_wprt__JobOriginatingUserNameType(soap, tag, id, (const struct wprt__JobOriginatingUserNameType *)ptr, "wprt:JobOriginatingUserNameType");
	case SOAP_TYPE_wprt__JobNameType:
		return soap_out_wprt__JobNameType(soap, tag, id, (const struct wprt__JobNameType *)ptr, "wprt:JobNameType");
	case SOAP_TYPE_wprt__JobStateReasonsType:
		return soap_out_wprt__JobStateReasonsType(soap, tag, id, (const struct wprt__JobStateReasonsType *)ptr, "wprt:JobStateReasonsType");
	case SOAP_TYPE_wprt__JobStateType:
		return soap_out_wprt__JobStateType(soap, tag, id, (const struct wprt__JobStateType *)ptr, "wprt:JobStateType");
	case SOAP_TYPE_wprt__JobEndStateType:
		return soap_out_wprt__JobEndStateType(soap, tag, id, (const struct wprt__JobEndStateType *)ptr, "wprt:JobEndStateType");
	case SOAP_TYPE_wprt__JobStatusType:
		return soap_out_wprt__JobStatusType(soap, tag, id, (const struct wprt__JobStatusType *)ptr, "wprt:JobStatusType");
	case SOAP_TYPE_wprt__JobStatusEventType:
		return soap_out_wprt__JobStatusEventType(soap, tag, id, (const struct wprt__JobStatusEventType *)ptr, "wprt:JobStatusEventType");
	case SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType:
		return soap_out_wprt__PrinterStatusConditionClearedEventType(soap, tag, id, (const struct wprt__PrinterStatusConditionClearedEventType *)ptr, "wprt:PrinterStatusConditionClearedEventType");
	case SOAP_TYPE_wprt__DateTimeExtType:
		return soap_out_wprt__DateTimeExtType(soap, tag, id, (const struct wprt__DateTimeExtType *)ptr, "wprt:DateTimeExtType");
	case SOAP_TYPE_wprt__DeviceConditionClearedType:
		return soap_out_wprt__DeviceConditionClearedType(soap, tag, id, (const struct wprt__DeviceConditionClearedType *)ptr, "wprt:DeviceConditionClearedType");
	case SOAP_TYPE_wprt__DeviceConditionType:
		return soap_out_wprt__DeviceConditionType(soap, tag, id, (const struct wprt__DeviceConditionType *)ptr, "wprt:DeviceConditionType");
	case SOAP_TYPE_wprt__PrinterStatusConditionEventType:
		return soap_out_wprt__PrinterStatusConditionEventType(soap, tag, id, (const struct wprt__PrinterStatusConditionEventType *)ptr, "wprt:PrinterStatusConditionEventType");
	case SOAP_TYPE_wprt__PrinterStatusSummaryEventType:
		return soap_out_wprt__PrinterStatusSummaryEventType(soap, tag, id, (const struct wprt__PrinterStatusSummaryEventType *)ptr, "wprt:PrinterStatusSummaryEventType");
	case SOAP_TYPE_wprt__PrinterStateReasonsType:
		return soap_out_wprt__PrinterStateReasonsType(soap, tag, id, (const struct wprt__PrinterStateReasonsType *)ptr, "wprt:PrinterStateReasonsType");
	case SOAP_TYPE_wprt__PrinterStateReasonType:
		return soap_out_wprt__PrinterStateReasonType(soap, tag, id, (const struct wprt__PrinterStateReasonType *)ptr, "wprt:PrinterStateReasonType");
	case SOAP_TYPE_wprt__PrinterStateType:
		return soap_out_wprt__PrinterStateType(soap, tag, id, (const struct wprt__PrinterStateType *)ptr, "wprt:PrinterStateType");
	case SOAP_TYPE_wprt__StatusSummaryType:
		return soap_out_wprt__StatusSummaryType(soap, tag, id, (const struct wprt__StatusSummaryType *)ptr, "wprt:StatusSummaryType");
	case SOAP_TYPE_wprt__PrinterElementsChangeEventType:
		return soap_out_wprt__PrinterElementsChangeEventType(soap, tag, id, (const struct wprt__PrinterElementsChangeEventType *)ptr, "wprt:PrinterElementsChangeEventType");
	case SOAP_TYPE_wprt__PrinterCapabilitiesType:
		return soap_out_wprt__PrinterCapabilitiesType(soap, tag, id, (const struct wprt__PrinterCapabilitiesType *)ptr, "wprt:PrinterCapabilitiesType");
	case SOAP_TYPE_wprt__PrinterConfigurationType:
		return soap_out_wprt__PrinterConfigurationType(soap, tag, id, (const struct wprt__PrinterConfigurationType *)ptr, "wprt:PrinterConfigurationType");
	case SOAP_TYPE_wprt__PrinterDescriptionType:
		return soap_out_wprt__PrinterDescriptionType(soap, tag, id, (const struct wprt__PrinterDescriptionType *)ptr, "wprt:PrinterDescriptionType");
	case SOAP_TYPE_wprt__ElementChangesType:
		return soap_out_wprt__ElementChangesType(soap, tag, id, (const struct wprt__ElementChangesType *)ptr, "wprt:ElementChangesType");
	case SOAP_TYPE_wprt__SetEventRateResponseType:
		return soap_out_wprt__SetEventRateResponseType(soap, tag, id, (const struct wprt__SetEventRateResponseType *)ptr, "wprt:SetEventRateResponseType");
	case SOAP_TYPE_wprt__EventRateType:
		return soap_out_wprt__EventRateType(soap, tag, id, (const struct wprt__EventRateType *)ptr, "wprt:EventRateType");
	case SOAP_TYPE_wprt__SetEventRateRequestType:
		return soap_out_wprt__SetEventRateRequestType(soap, tag, id, (const struct wprt__SetEventRateRequestType *)ptr, "wprt:SetEventRateRequestType");
	case SOAP_TYPE_wprt__GetJobHistoryResponseType:
		return soap_out_wprt__GetJobHistoryResponseType(soap, tag, id, (const struct wprt__GetJobHistoryResponseType *)ptr, "wprt:GetJobHistoryResponseType");
	case SOAP_TYPE_wprt__GetJobHistoryRequestType:
		return soap_out_wprt__GetJobHistoryRequestType(soap, tag, id, (const struct wprt__GetJobHistoryRequestType *)ptr, "wprt:GetJobHistoryRequestType");
	case SOAP_TYPE_wprt__ListOfSummarysType:
		return soap_out_wprt__ListOfSummarysType(soap, tag, id, (const struct wprt__ListOfSummarysType *)ptr, "wprt:ListOfSummarysType");
	case SOAP_TYPE_wprt__GetActiveJobsResponseType:
		return soap_out_wprt__GetActiveJobsResponseType(soap, tag, id, (const struct wprt__GetActiveJobsResponseType *)ptr, "wprt:GetActiveJobsResponseType");
	case SOAP_TYPE_wprt__GetActiveJobsRequestType:
		return soap_out_wprt__GetActiveJobsRequestType(soap, tag, id, (const struct wprt__GetActiveJobsRequestType *)ptr, "wprt:GetActiveJobsRequestType");
	case SOAP_TYPE_wprt__JobElementsType:
		return soap_out_wprt__JobElementsType(soap, tag, id, (const struct wprt__JobElementsType *)ptr, "wprt:JobElementsType");
	case SOAP_TYPE_wprt__GetJobElementsResponseType:
		return soap_out_wprt__GetJobElementsResponseType(soap, tag, id, (const struct wprt__GetJobElementsResponseType *)ptr, "wprt:GetJobElementsResponseType");
	case SOAP_TYPE_wprt__RequestedJobElementsType:
		return soap_out_wprt__RequestedJobElementsType(soap, tag, id, (const struct wprt__RequestedJobElementsType *)ptr, "wprt:RequestedJobElementsType");
	case SOAP_TYPE_wprt__GetJobElementsRequestType:
		return soap_out_wprt__GetJobElementsRequestType(soap, tag, id, (const struct wprt__GetJobElementsRequestType *)ptr, "wprt:GetJobElementsRequestType");
	case SOAP_TYPE_wprt__PrinterElementsType:
		return soap_out_wprt__PrinterElementsType(soap, tag, id, (const struct wprt__PrinterElementsType *)ptr, "wprt:PrinterElementsType");
	case SOAP_TYPE_wprt__GetPrinterElementsResponseType:
		return soap_out_wprt__GetPrinterElementsResponseType(soap, tag, id, (const struct wprt__GetPrinterElementsResponseType *)ptr, "wprt:GetPrinterElementsResponseType");
	case SOAP_TYPE_wprt__RequestedPrinterElementsType:
		return soap_out_wprt__RequestedPrinterElementsType(soap, tag, id, (const struct wprt__RequestedPrinterElementsType *)ptr, "wprt:RequestedPrinterElementsType");
	case SOAP_TYPE_wprt__GetPrinterElementsRequestType:
		return soap_out_wprt__GetPrinterElementsRequestType(soap, tag, id, (const struct wprt__GetPrinterElementsRequestType *)ptr, "wprt:GetPrinterElementsRequestType");
	case SOAP_TYPE_wprt__CancelJobResponseType:
		return soap_out_wprt__CancelJobResponseType(soap, tag, id, (const struct wprt__CancelJobResponseType *)ptr, "wprt:CancelJobResponseType");
	case SOAP_TYPE_wprt__CancelJobRequestType:
		return soap_out_wprt__CancelJobRequestType(soap, tag, id, (const struct wprt__CancelJobRequestType *)ptr, "wprt:CancelJobRequestType");
	case SOAP_TYPE_wprt__AddDocumentResponseType:
		return soap_out_wprt__AddDocumentResponseType(soap, tag, id, (const struct wprt__AddDocumentResponseType *)ptr, "wprt:AddDocumentResponseType");
	case SOAP_TYPE_wprt__AnyURIExtType:
		return soap_out_wprt__AnyURIExtType(soap, tag, id, (const struct wprt__AnyURIExtType *)ptr, "wprt:AnyURIExtType");
	case SOAP_TYPE_wprt__AddDocumentRequestType:
		return soap_out_wprt__AddDocumentRequestType(soap, tag, id, (const struct wprt__AddDocumentRequestType *)ptr, "wprt:AddDocumentRequestType");
	case SOAP_TYPE_wprt__SendDocumentResponseType:
		return soap_out_wprt__SendDocumentResponseType(soap, tag, id, (const struct wprt__SendDocumentResponseType *)ptr, "wprt:SendDocumentResponseType");
	case SOAP_TYPE_wprt__BoolExtType:
		return soap_out_wprt__BoolExtType(soap, tag, id, (const struct wprt__BoolExtType *)ptr, "wprt:BoolExtType");
	case SOAP_TYPE_wprt__DocumentProcessingType:
		return soap_out_wprt__DocumentProcessingType(soap, tag, id, (const struct wprt__DocumentProcessingType *)ptr, "wprt:DocumentProcessingType");
	case SOAP_TYPE_wprt__DocumentDescriptionType:
		return soap_out_wprt__DocumentDescriptionType(soap, tag, id, (const struct wprt__DocumentDescriptionType *)ptr, "wprt:DocumentDescriptionType");
	case SOAP_TYPE_wprt__SendDocumentRequestType:
		return soap_out_wprt__SendDocumentRequestType(soap, tag, id, (const struct wprt__SendDocumentRequestType *)ptr, "wprt:SendDocumentRequestType");
	case SOAP_TYPE_wprt__JobIdType:
		return soap_out_wprt__JobIdType(soap, tag, id, (const struct wprt__JobIdType *)ptr, "wprt:JobIdType");
	case SOAP_TYPE_wprt__CreatePrintJobResponseType:
		return soap_out_wprt__CreatePrintJobResponseType(soap, tag, id, (const struct wprt__CreatePrintJobResponseType *)ptr, "wprt:CreatePrintJobResponseType");
	case SOAP_TYPE_wprt__PrintTicketType:
		return soap_out_wprt__PrintTicketType(soap, tag, id, (const struct wprt__PrintTicketType *)ptr, "wprt:PrintTicketType");
	case SOAP_TYPE_wprt__CreatePrintJobRequestType:
		return soap_out_wprt__CreatePrintJobRequestType(soap, tag, id, (const struct wprt__CreatePrintJobRequestType *)ptr, "wprt:CreatePrintJobRequestType");
	case SOAP_TYPE__xop__Include:
		return soap_out__xop__Include(soap, "xop:Include", id, (const struct _xop__Include *)ptr, NULL);
	case SOAP_TYPE_PointerToSOAP_ENV__Reason:
		return soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, (struct SOAP_ENV__Reason *const*)ptr, "SOAP-ENV:Reason");
	case SOAP_TYPE_PointerTowprt__JobEndStateEventType:
		return soap_out_PointerTowprt__JobEndStateEventType(soap, tag, id, (struct wprt__JobEndStateEventType *const*)ptr, "wprt:JobEndStateEventType");
	case SOAP_TYPE_PointerTowprt__JobStatusEventType:
		return soap_out_PointerTowprt__JobStatusEventType(soap, tag, id, (struct wprt__JobStatusEventType *const*)ptr, "wprt:JobStatusEventType");
	case SOAP_TYPE_PointerTowprt__PrinterStatusConditionClearedEventType:
		return soap_out_PointerTowprt__PrinterStatusConditionClearedEventType(soap, tag, id, (struct wprt__PrinterStatusConditionClearedEventType *const*)ptr, "wprt:PrinterStatusConditionClearedEventType");
	case SOAP_TYPE_PointerTowprt__PrinterStatusConditionEventType:
		return soap_out_PointerTowprt__PrinterStatusConditionEventType(soap, tag, id, (struct wprt__PrinterStatusConditionEventType *const*)ptr, "wprt:PrinterStatusConditionEventType");
	case SOAP_TYPE_PointerTowprt__PrinterStatusSummaryEventType:
		return soap_out_PointerTowprt__PrinterStatusSummaryEventType(soap, tag, id, (struct wprt__PrinterStatusSummaryEventType *const*)ptr, "wprt:PrinterStatusSummaryEventType");
	case SOAP_TYPE_PointerTowprt__PrinterElementsChangeEventType:
		return soap_out_PointerTowprt__PrinterElementsChangeEventType(soap, tag, id, (struct wprt__PrinterElementsChangeEventType *const*)ptr, "wprt:PrinterElementsChangeEventType");
	case SOAP_TYPE_PointerTowprt__SetEventRateResponseType:
		return soap_out_PointerTowprt__SetEventRateResponseType(soap, tag, id, (struct wprt__SetEventRateResponseType *const*)ptr, "wprt:SetEventRateResponseType");
	case SOAP_TYPE_PointerTowprt__SetEventRateRequestType:
		return soap_out_PointerTowprt__SetEventRateRequestType(soap, tag, id, (struct wprt__SetEventRateRequestType *const*)ptr, "wprt:SetEventRateRequestType");
	case SOAP_TYPE_PointerTowprt__GetJobHistoryResponseType:
		return soap_out_PointerTowprt__GetJobHistoryResponseType(soap, tag, id, (struct wprt__GetJobHistoryResponseType *const*)ptr, "wprt:GetJobHistoryResponseType");
	case SOAP_TYPE_PointerTowprt__GetJobHistoryRequestType:
		return soap_out_PointerTowprt__GetJobHistoryRequestType(soap, tag, id, (struct wprt__GetJobHistoryRequestType *const*)ptr, "wprt:GetJobHistoryRequestType");
	case SOAP_TYPE_PointerTowprt__GetActiveJobsResponseType:
		return soap_out_PointerTowprt__GetActiveJobsResponseType(soap, tag, id, (struct wprt__GetActiveJobsResponseType *const*)ptr, "wprt:GetActiveJobsResponseType");
	case SOAP_TYPE_PointerTowprt__GetActiveJobsRequestType:
		return soap_out_PointerTowprt__GetActiveJobsRequestType(soap, tag, id, (struct wprt__GetActiveJobsRequestType *const*)ptr, "wprt:GetActiveJobsRequestType");
	case SOAP_TYPE_PointerTowprt__GetJobElementsResponseType:
		return soap_out_PointerTowprt__GetJobElementsResponseType(soap, tag, id, (struct wprt__GetJobElementsResponseType *const*)ptr, "wprt:GetJobElementsResponseType");
	case SOAP_TYPE_PointerTowprt__GetJobElementsRequestType:
		return soap_out_PointerTowprt__GetJobElementsRequestType(soap, tag, id, (struct wprt__GetJobElementsRequestType *const*)ptr, "wprt:GetJobElementsRequestType");
	case SOAP_TYPE_PointerTowprt__GetPrinterElementsResponseType:
		return soap_out_PointerTowprt__GetPrinterElementsResponseType(soap, tag, id, (struct wprt__GetPrinterElementsResponseType *const*)ptr, "wprt:GetPrinterElementsResponseType");
	case SOAP_TYPE_PointerTowprt__GetPrinterElementsRequestType:
		return soap_out_PointerTowprt__GetPrinterElementsRequestType(soap, tag, id, (struct wprt__GetPrinterElementsRequestType *const*)ptr, "wprt:GetPrinterElementsRequestType");
	case SOAP_TYPE_PointerTowprt__CancelJobResponseType:
		return soap_out_PointerTowprt__CancelJobResponseType(soap, tag, id, (struct wprt__CancelJobResponseType *const*)ptr, "wprt:CancelJobResponseType");
	case SOAP_TYPE_PointerTowprt__CancelJobRequestType:
		return soap_out_PointerTowprt__CancelJobRequestType(soap, tag, id, (struct wprt__CancelJobRequestType *const*)ptr, "wprt:CancelJobRequestType");
	case SOAP_TYPE_PointerTowprt__AddDocumentResponseType:
		return soap_out_PointerTowprt__AddDocumentResponseType(soap, tag, id, (struct wprt__AddDocumentResponseType *const*)ptr, "wprt:AddDocumentResponseType");
	case SOAP_TYPE_PointerTowprt__AddDocumentRequestType:
		return soap_out_PointerTowprt__AddDocumentRequestType(soap, tag, id, (struct wprt__AddDocumentRequestType *const*)ptr, "wprt:AddDocumentRequestType");
	case SOAP_TYPE_PointerTowprt__SendDocumentResponseType:
		return soap_out_PointerTowprt__SendDocumentResponseType(soap, tag, id, (struct wprt__SendDocumentResponseType *const*)ptr, "wprt:SendDocumentResponseType");
	case SOAP_TYPE_PointerTowprt__SendDocumentRequestType:
		return soap_out_PointerTowprt__SendDocumentRequestType(soap, tag, id, (struct wprt__SendDocumentRequestType *const*)ptr, "wprt:SendDocumentRequestType");
	case SOAP_TYPE_PointerTowprt__CreatePrintJobResponseType:
		return soap_out_PointerTowprt__CreatePrintJobResponseType(soap, tag, id, (struct wprt__CreatePrintJobResponseType *const*)ptr, "wprt:CreatePrintJobResponseType");
	case SOAP_TYPE_PointerTowprt__CreatePrintJobRequestType:
		return soap_out_PointerTowprt__CreatePrintJobRequestType(soap, tag, id, (struct wprt__CreatePrintJobRequestType *const*)ptr, "wprt:CreatePrintJobRequestType");
	case SOAP_TYPE_PointerTowprt__JobTableType:
		return soap_out_PointerTowprt__JobTableType(soap, tag, id, (struct wprt__JobTableType *const*)ptr, "wprt:JobTableType");
	case SOAP_TYPE_PointerTowprt__PrinterElementDataType:
		return soap_out_PointerTowprt__PrinterElementDataType(soap, tag, id, (struct wprt__PrinterElementDataType *const*)ptr, "wprt:PrinterElementDataType");
	case SOAP_TYPE_PointerTo_wprt__DocumentValuesType_DocumentDescription:
		return soap_out_PointerTo_wprt__DocumentValuesType_DocumentDescription(soap, tag, id, (struct _wprt__DocumentValuesType_DocumentDescription *const*)ptr, "wprt:DocumentValuesType-DocumentDescription");
	case SOAP_TYPE_PointerTowprt__ValueStringListType:
		return soap_out_PointerTowprt__ValueStringListType(soap, tag, id, (struct wprt__ValueStringListType *const*)ptr, "wprt:ValueStringListType");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing:
		return soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing(soap, tag, id, (struct _wprt__JobValuesType_DocumentProcessing *const*)ptr, "wprt:JobValuesType-DocumentProcessing");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution:
		return soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(soap, tag, id, (struct _wprt__JobValuesType_DocumentProcessing_Resolution *const*)ptr, "wprt:JobValuesType-DocumentProcessing-Resolution");
	case SOAP_TYPE_PointerTowprt__ResolutionEntryType:
		return soap_out_PointerTowprt__ResolutionEntryType(soap, tag, id, (struct wprt__ResolutionEntryType *const*)ptr, "wprt:ResolutionEntryType");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp:
		return soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(soap, tag, id, (struct _wprt__JobValuesType_DocumentProcessing_NumberUp *const*)ptr, "wprt:JobValuesType-DocumentProcessing-NumberUp");
	case SOAP_TYPE_PointerTowprt__ValueIntListType:
		return soap_out_PointerTowprt__ValueIntListType(soap, tag, id, (struct wprt__ValueIntListType *const*)ptr, "wprt:ValueIntListType");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing:
		return soap_out_PointerTo_wprt__JobValuesType_JobProcessing(soap, tag, id, (struct _wprt__JobValuesType_JobProcessing *const*)ptr, "wprt:JobValuesType-JobProcessing");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings:
		return soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(soap, tag, id, (struct _wprt__JobValuesType_JobProcessing_JobFinishings *const*)ptr, "wprt:JobValuesType-JobProcessing-JobFinishings");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch:
		return soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, tag, id, (struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *const*)ptr, "wprt:JobValuesType-JobProcessing-JobFinishings-HolePunch");
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple:
		return soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, tag, id, (struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *const*)ptr, "wprt:JobValuesType-JobProcessing-JobFinishings-Staple");
	case SOAP_TYPE_PointerTowprt__ValueTokenListType:
		return soap_out_PointerTowprt__ValueTokenListType(soap, tag, id, (struct wprt__ValueTokenListType *const*)ptr, "wprt:ValueTokenListType");
	case SOAP_TYPE_PointerTowprt__ValueIntRangeType:
		return soap_out_PointerTowprt__ValueIntRangeType(soap, tag, id, (struct wprt__ValueIntRangeType *const*)ptr, "wprt:ValueIntRangeType");
	case SOAP_TYPE_PointerTowprt__DocumentValuesType:
		return soap_out_PointerTowprt__DocumentValuesType(soap, tag, id, (struct wprt__DocumentValuesType *const*)ptr, "wprt:DocumentValuesType");
	case SOAP_TYPE_PointerTowprt__JobValuesType:
		return soap_out_PointerTowprt__JobValuesType(soap, tag, id, (struct wprt__JobValuesType *const*)ptr, "wprt:JobValuesType");
	case SOAP_TYPE_PointerTowprt__ComponentNameType:
		return soap_out_PointerTowprt__ComponentNameType(soap, tag, id, (struct wprt__ComponentNameType *const*)ptr, "wprt:ComponentNameType");
	case SOAP_TYPE_PointerTowprt__ComponentGroupType:
		return soap_out_PointerTowprt__ComponentGroupType(soap, tag, id, (struct wprt__ComponentGroupType *const*)ptr, "wprt:ComponentGroupType");
	case SOAP_TYPE_PointerTowprt__ConditionSeverityType:
		return soap_out_PointerTowprt__ConditionSeverityType(soap, tag, id, (struct wprt__ConditionSeverityType *const*)ptr, "wprt:ConditionSeverityType");
	case SOAP_TYPE_PointerTowprt__ConditionComponentType:
		return soap_out_PointerTowprt__ConditionComponentType(soap, tag, id, (struct wprt__ConditionComponentType *const*)ptr, "wprt:ConditionComponentType");
	case SOAP_TYPE_PointerTowprt__ConditionNameType:
		return soap_out_PointerTowprt__ConditionNameType(soap, tag, id, (struct wprt__ConditionNameType *const*)ptr, "wprt:ConditionNameType");
	case SOAP_TYPE_PointerTowprt__ConditionHistoryEntryType:
		return soap_out_PointerTowprt__ConditionHistoryEntryType(soap, tag, id, (struct wprt__ConditionHistoryEntryType *const*)ptr, "wprt:ConditionHistoryEntryType");
	case SOAP_TYPE_PointerTowprt__ConditionHistoryTableType:
		return soap_out_PointerTowprt__ConditionHistoryTableType(soap, tag, id, (struct wprt__ConditionHistoryTableType *const*)ptr, "wprt:ConditionHistoryTableType");
	case SOAP_TYPE_PointerTowprt__ActiveConditionTableType:
		return soap_out_PointerTowprt__ActiveConditionTableType(soap, tag, id, (struct wprt__ActiveConditionTableType *const*)ptr, "wprt:ActiveConditionTableType");
	case SOAP_TYPE_PointerTowprt__OutputBinEntryType:
		return soap_out_PointerTowprt__OutputBinEntryType(soap, tag, id, (struct wprt__OutputBinEntryType *const*)ptr, "wprt:OutputBinEntryType");
	case SOAP_TYPE_PointerTowprt__InputBinEntryType:
		return soap_out_PointerTowprt__InputBinEntryType(soap, tag, id, (struct wprt__InputBinEntryType *const*)ptr, "wprt:InputBinEntryType");
	case SOAP_TYPE_PointerTowprt__ConsumableEntryType:
		return soap_out_PointerTowprt__ConsumableEntryType(soap, tag, id, (struct wprt__ConsumableEntryType *const*)ptr, "wprt:ConsumableEntryType");
	case SOAP_TYPE_PointerTowprt__StorageEntryType:
		return soap_out_PointerTowprt__StorageEntryType(soap, tag, id, (struct wprt__StorageEntryType *const*)ptr, "wprt:StorageEntryType");
	case SOAP_TYPE_PointerTowprt__OutputBinsType:
		return soap_out_PointerTowprt__OutputBinsType(soap, tag, id, (struct wprt__OutputBinsType *const*)ptr, "wprt:OutputBinsType");
	case SOAP_TYPE_PointerTowprt__FinishingsType:
		return soap_out_PointerTowprt__FinishingsType(soap, tag, id, (struct wprt__FinishingsType *const*)ptr, "wprt:FinishingsType");
	case SOAP_TYPE_PointerTowprt__InputBinsType:
		return soap_out_PointerTowprt__InputBinsType(soap, tag, id, (struct wprt__InputBinsType *const*)ptr, "wprt:InputBinsType");
	case SOAP_TYPE_PointerTowprt__ConsumablesType:
		return soap_out_PointerTowprt__ConsumablesType(soap, tag, id, (struct wprt__ConsumablesType *const*)ptr, "wprt:ConsumablesType");
	case SOAP_TYPE_PointerTowprt__StorageBaseType:
		return soap_out_PointerTowprt__StorageBaseType(soap, tag, id, (struct wprt__StorageBaseType *const*)ptr, "wprt:StorageBaseType");
	case SOAP_TYPE_PointerTowprt__LocalizedStringType:
		return soap_out_PointerTowprt__LocalizedStringType(soap, tag, id, (struct wprt__LocalizedStringType *const*)ptr, "wprt:LocalizedStringType");
	case SOAP_TYPE_PointerTowprt__DeviceIdType:
		return soap_out_PointerTowprt__DeviceIdType(soap, tag, id, (struct wprt__DeviceIdType *const*)ptr, "wprt:DeviceIdType");
	case SOAP_TYPE_PointerTowprt__PrinterStatusType:
		return soap_out_PointerTowprt__PrinterStatusType(soap, tag, id, (struct wprt__PrinterStatusType *const*)ptr, "wprt:PrinterStatusType");
	case SOAP_TYPE_PointerTowprt__JobElementDataType:
		return soap_out_PointerTowprt__JobElementDataType(soap, tag, id, (struct wprt__JobElementDataType *const*)ptr, "wprt:JobElementDataType");
	case SOAP_TYPE_PointerTowprt__QNameExtType:
		return soap_out_PointerTowprt__QNameExtType(soap, tag, id, (struct wprt__QNameExtType *const*)ptr, "wprt:QNameExtType");
	case SOAP_TYPE_PointerTowprt__HolePunchPatternType:
		return soap_out_PointerTowprt__HolePunchPatternType(soap, tag, id, (struct wprt__HolePunchPatternType *const*)ptr, "wprt:HolePunchPatternType");
	case SOAP_TYPE_PointerTowprt__HolePunchEdgeType:
		return soap_out_PointerTowprt__HolePunchEdgeType(soap, tag, id, (struct wprt__HolePunchEdgeType *const*)ptr, "wprt:HolePunchEdgeType");
	case SOAP_TYPE_PointerTowprt__StapleAngleType:
		return soap_out_PointerTowprt__StapleAngleType(soap, tag, id, (struct wprt__StapleAngleType *const*)ptr, "wprt:StapleAngleType");
	case SOAP_TYPE_PointerTowprt__StapleLocationType:
		return soap_out_PointerTowprt__StapleLocationType(soap, tag, id, (struct wprt__StapleLocationType *const*)ptr, "wprt:StapleLocationType");
	case SOAP_TYPE_PointerTowprt__HolePunchDetailsType:
		return soap_out_PointerTowprt__HolePunchDetailsType(soap, tag, id, (struct wprt__HolePunchDetailsType *const*)ptr, "wprt:HolePunchDetailsType");
	case SOAP_TYPE_PointerTowprt__StapleDetailsType:
		return soap_out_PointerTowprt__StapleDetailsType(soap, tag, id, (struct wprt__StapleDetailsType *const*)ptr, "wprt:StapleDetailsType");
	case SOAP_TYPE_PointerTowprt__BooleanExtType:
		return soap_out_PointerTowprt__BooleanExtType(soap, tag, id, (struct wprt__BooleanExtType *const*)ptr, "wprt:BooleanExtType");
	case SOAP_TYPE_PointerTowprt__JobPriorityType:
		return soap_out_PointerTowprt__JobPriorityType(soap, tag, id, (struct wprt__JobPriorityType *const*)ptr, "wprt:JobPriorityType");
	case SOAP_TYPE_PointerTowprt__JobFinishingsType:
		return soap_out_PointerTowprt__JobFinishingsType(soap, tag, id, (struct wprt__JobFinishingsType *const*)ptr, "wprt:JobFinishingsType");
	case SOAP_TYPE_PointerTowprt__JobCopiesType:
		return soap_out_PointerTowprt__JobCopiesType(soap, tag, id, (struct wprt__JobCopiesType *const*)ptr, "wprt:JobCopiesType");
	case SOAP_TYPE_PointerTowprt__JobProcessingType:
		return soap_out_PointerTowprt__JobProcessingType(soap, tag, id, (struct wprt__JobProcessingType *const*)ptr, "wprt:JobProcessingType");
	case SOAP_TYPE_PointerTowprt__JobDescriptionType:
		return soap_out_PointerTowprt__JobDescriptionType(soap, tag, id, (struct wprt__JobDescriptionType *const*)ptr, "wprt:JobDescriptionType");
	case SOAP_TYPE_PointerTowprt__JobStateReasonType:
		return soap_out_PointerTowprt__JobStateReasonType(soap, tag, id, (struct wprt__JobStateReasonType *const*)ptr, "wprt:JobStateReasonType");
	case SOAP_TYPE_PointerTowprt__JobSummaryType:
		return soap_out_PointerTowprt__JobSummaryType(soap, tag, id, (struct wprt__JobSummaryType *const*)ptr, "wprt:JobSummaryType");
	case SOAP_TYPE_PointerTowprt__JobType:
		return soap_out_PointerTowprt__JobType(soap, tag, id, (struct wprt__JobType *const*)ptr, "wprt:JobType");
	case SOAP_TYPE_PointerTowprt__DocumentsType:
		return soap_out_PointerTowprt__DocumentsType(soap, tag, id, (struct wprt__DocumentsType *const*)ptr, "wprt:DocumentsType");
	case SOAP_TYPE_PointerTowprt__ListOfJobsType:
		return soap_out_PointerTowprt__ListOfJobsType(soap, tag, id, (struct wprt__ListOfJobsType *const*)ptr, "wprt:ListOfJobsType");
	case SOAP_TYPE_PointerTowprt__NUpDirectionType:
		return soap_out_PointerTowprt__NUpDirectionType(soap, tag, id, (struct wprt__NUpDirectionType *const*)ptr, "wprt:NUpDirectionType");
	case SOAP_TYPE_PointerTowprt__NUpPagesPerSheetType:
		return soap_out_PointerTowprt__NUpPagesPerSheetType(soap, tag, id, (struct wprt__NUpPagesPerSheetType *const*)ptr, "wprt:NUpPagesPerSheetType");
	case SOAP_TYPE_PointerTowprt__SidesType:
		return soap_out_PointerTowprt__SidesType(soap, tag, id, (struct wprt__SidesType *const*)ptr, "wprt:SidesType");
	case SOAP_TYPE_PointerTowprt__PrintQualityType:
		return soap_out_PointerTowprt__PrintQualityType(soap, tag, id, (struct wprt__PrintQualityType *const*)ptr, "wprt:PrintQualityType");
	case SOAP_TYPE_PointerTowprt__ResolutionType:
		return soap_out_PointerTowprt__ResolutionType(soap, tag, id, (struct wprt__ResolutionType *const*)ptr, "wprt:ResolutionType");
	case SOAP_TYPE_PointerTowprt__OrientationType:
		return soap_out_PointerTowprt__OrientationType(soap, tag, id, (struct wprt__OrientationType *const*)ptr, "wprt:OrientationType");
	case SOAP_TYPE_PointerTowprt__NumberUpType:
		return soap_out_PointerTowprt__NumberUpType(soap, tag, id, (struct wprt__NumberUpType *const*)ptr, "wprt:NumberUpType");
	case SOAP_TYPE_PointerTowprt__MediaColorType:
		return soap_out_PointerTowprt__MediaColorType(soap, tag, id, (struct wprt__MediaColorType *const*)ptr, "wprt:MediaColorType");
	case SOAP_TYPE_PointerTowprt__MediaTypeBaseType:
		return soap_out_PointerTowprt__MediaTypeBaseType(soap, tag, id, (struct wprt__MediaTypeBaseType *const*)ptr, "wprt:MediaTypeBaseType");
	case SOAP_TYPE_PointerTowprt__MediaSizeNameType:
		return soap_out_PointerTowprt__MediaSizeNameType(soap, tag, id, (struct wprt__MediaSizeNameType *const*)ptr, "wprt:MediaSizeNameType");
	case SOAP_TYPE_PointerTowprt__DocumentFormatType:
		return soap_out_PointerTowprt__DocumentFormatType(soap, tag, id, (struct wprt__DocumentFormatType *const*)ptr, "wprt:DocumentFormatType");
	case SOAP_TYPE_PointerTowprt__CompressionType:
		return soap_out_PointerTowprt__CompressionType(soap, tag, id, (struct wprt__CompressionType *const*)ptr, "wprt:CompressionType");
	case SOAP_TYPE_PointerTowprt__DocumentType:
		return soap_out_PointerTowprt__DocumentType(soap, tag, id, (struct wprt__DocumentType *const*)ptr, "wprt:DocumentType");
	case SOAP_TYPE_PointerTowprt__CapacityBaseType:
		return soap_out_PointerTowprt__CapacityBaseType(soap, tag, id, (struct wprt__CapacityBaseType *const*)ptr, "wprt:CapacityBaseType");
	case SOAP_TYPE_PointerTowprt__InputBinMediaColorType:
		return soap_out_PointerTowprt__InputBinMediaColorType(soap, tag, id, (struct wprt__InputBinMediaColorType *const*)ptr, "wprt:InputBinMediaColorType");
	case SOAP_TYPE_PointerTowprt__InputBinMediaTypeBaseType:
		return soap_out_PointerTowprt__InputBinMediaTypeBaseType(soap, tag, id, (struct wprt__InputBinMediaTypeBaseType *const*)ptr, "wprt:InputBinMediaTypeBaseType");
	case SOAP_TYPE_PointerTowprt__InputBinMediaSizeType:
		return soap_out_PointerTowprt__InputBinMediaSizeType(soap, tag, id, (struct wprt__InputBinMediaSizeType *const*)ptr, "wprt:InputBinMediaSizeType");
	case SOAP_TYPE_PointerTowprt__InputBinFeedDirectionType:
		return soap_out_PointerTowprt__InputBinFeedDirectionType(soap, tag, id, (struct wprt__InputBinFeedDirectionType *const*)ptr, "wprt:InputBinFeedDirectionType");
	case SOAP_TYPE_PointerTowprt__String255ExtType:
		return soap_out_PointerTowprt__String255ExtType(soap, tag, id, (struct wprt__String255ExtType *const*)ptr, "wprt:String255ExtType");
	case SOAP_TYPE_PointerTowprt__ConsumableColorType:
		return soap_out_PointerTowprt__ConsumableColorType(soap, tag, id, (struct wprt__ConsumableColorType *const*)ptr, "wprt:ConsumableColorType");
	case SOAP_TYPE_PointerTowprt__ConsumableTypeBaseType:
		return soap_out_PointerTowprt__ConsumableTypeBaseType(soap, tag, id, (struct wprt__ConsumableTypeBaseType *const*)ptr, "wprt:ConsumableTypeBaseType");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTowprt__LevelFreeBaseType:
		return soap_out_PointerTowprt__LevelFreeBaseType(soap, tag, id, (struct wprt__LevelFreeBaseType *const*)ptr, "wprt:LevelFreeBaseType");
	case SOAP_TYPE_PointerTowprt__IntOneExtType:
		return soap_out_PointerTowprt__IntOneExtType(soap, tag, id, (struct wprt__IntOneExtType *const*)ptr, "wprt:IntOneExtType");
	case SOAP_TYPE_PointerTowprt__StorageTypeBaseType:
		return soap_out_PointerTowprt__StorageTypeBaseType(soap, tag, id, (struct wprt__StorageTypeBaseType *const*)ptr, "wprt:StorageTypeBaseType");
	case SOAP_TYPE_PointerTowprt__IntExtType:
		return soap_out_PointerTowprt__IntExtType(soap, tag, id, (struct wprt__IntExtType *const*)ptr, "wprt:IntExtType");
	case SOAP_TYPE_PointerTowprt__NMTOKENSExtType:
		return soap_out_PointerTowprt__NMTOKENSExtType(soap, tag, id, (struct wprt__NMTOKENSExtType *const*)ptr, "wprt:NMTOKENSExtType");
	case SOAP_TYPE_PointerTowprt__JobEndStateType:
		return soap_out_PointerTowprt__JobEndStateType(soap, tag, id, (struct wprt__JobEndStateType *const*)ptr, "wprt:JobEndStateType");
	case SOAP_TYPE_PointerTowprt__IntZeroExtType:
		return soap_out_PointerTowprt__IntZeroExtType(soap, tag, id, (struct wprt__IntZeroExtType *const*)ptr, "wprt:IntZeroExtType");
	case SOAP_TYPE_PointerTowprt__JobOriginatingUserNameType:
		return soap_out_PointerTowprt__JobOriginatingUserNameType(soap, tag, id, (struct wprt__JobOriginatingUserNameType *const*)ptr, "wprt:JobOriginatingUserNameType");
	case SOAP_TYPE_PointerTowprt__JobNameType:
		return soap_out_PointerTowprt__JobNameType(soap, tag, id, (struct wprt__JobNameType *const*)ptr, "wprt:JobNameType");
	case SOAP_TYPE_PointerTowprt__JobStateReasonsType:
		return soap_out_PointerTowprt__JobStateReasonsType(soap, tag, id, (struct wprt__JobStateReasonsType *const*)ptr, "wprt:JobStateReasonsType");
	case SOAP_TYPE_PointerTowprt__JobStateType:
		return soap_out_PointerTowprt__JobStateType(soap, tag, id, (struct wprt__JobStateType *const*)ptr, "wprt:JobStateType");
	case SOAP_TYPE_PointerTowprt__JobStatusType:
		return soap_out_PointerTowprt__JobStatusType(soap, tag, id, (struct wprt__JobStatusType *const*)ptr, "wprt:JobStatusType");
	case SOAP_TYPE_PointerTowprt__DeviceConditionClearedType:
		return soap_out_PointerTowprt__DeviceConditionClearedType(soap, tag, id, (struct wprt__DeviceConditionClearedType *const*)ptr, "wprt:DeviceConditionClearedType");
	case SOAP_TYPE_PointerTowprt__DateTimeExtType:
		return soap_out_PointerTowprt__DateTimeExtType(soap, tag, id, (struct wprt__DateTimeExtType *const*)ptr, "wprt:DateTimeExtType");
	case SOAP_TYPE_PointerTowprt__DeviceConditionType:
		return soap_out_PointerTowprt__DeviceConditionType(soap, tag, id, (struct wprt__DeviceConditionType *const*)ptr, "wprt:DeviceConditionType");
	case SOAP_TYPE_PointerTowprt__StatusSummaryType:
		return soap_out_PointerTowprt__StatusSummaryType(soap, tag, id, (struct wprt__StatusSummaryType *const*)ptr, "wprt:StatusSummaryType");
	case SOAP_TYPE_PointerTowprt__PrinterStateReasonsType:
		return soap_out_PointerTowprt__PrinterStateReasonsType(soap, tag, id, (struct wprt__PrinterStateReasonsType *const*)ptr, "wprt:PrinterStateReasonsType");
	case SOAP_TYPE_PointerTowprt__PrinterStateReasonType:
		return soap_out_PointerTowprt__PrinterStateReasonType(soap, tag, id, (struct wprt__PrinterStateReasonType *const*)ptr, "wprt:PrinterStateReasonType");
	case SOAP_TYPE_PointerTowprt__PrinterStateType:
		return soap_out_PointerTowprt__PrinterStateType(soap, tag, id, (struct wprt__PrinterStateType *const*)ptr, "wprt:PrinterStateType");
	case SOAP_TYPE_PointerTowprt__ElementChangesType:
		return soap_out_PointerTowprt__ElementChangesType(soap, tag, id, (struct wprt__ElementChangesType *const*)ptr, "wprt:ElementChangesType");
	case SOAP_TYPE_PointerTowprt__PrinterCapabilitiesType:
		return soap_out_PointerTowprt__PrinterCapabilitiesType(soap, tag, id, (struct wprt__PrinterCapabilitiesType *const*)ptr, "wprt:PrinterCapabilitiesType");
	case SOAP_TYPE_PointerTowprt__PrinterConfigurationType:
		return soap_out_PointerTowprt__PrinterConfigurationType(soap, tag, id, (struct wprt__PrinterConfigurationType *const*)ptr, "wprt:PrinterConfigurationType");
	case SOAP_TYPE_PointerTowprt__PrinterDescriptionType:
		return soap_out_PointerTowprt__PrinterDescriptionType(soap, tag, id, (struct wprt__PrinterDescriptionType *const*)ptr, "wprt:PrinterDescriptionType");
	case SOAP_TYPE_PointerTowprt__EventRateType:
		return soap_out_PointerTowprt__EventRateType(soap, tag, id, (struct wprt__EventRateType *const*)ptr, "wprt:EventRateType");
	case SOAP_TYPE_PointerTowprt__ListOfSummarysType:
		return soap_out_PointerTowprt__ListOfSummarysType(soap, tag, id, (struct wprt__ListOfSummarysType *const*)ptr, "wprt:ListOfSummarysType");
	case SOAP_TYPE_PointerTowprt__JobElementsType:
		return soap_out_PointerTowprt__JobElementsType(soap, tag, id, (struct wprt__JobElementsType *const*)ptr, "wprt:JobElementsType");
	case SOAP_TYPE_PointerTowprt__RequestedJobElementsType:
		return soap_out_PointerTowprt__RequestedJobElementsType(soap, tag, id, (struct wprt__RequestedJobElementsType *const*)ptr, "wprt:RequestedJobElementsType");
	case SOAP_TYPE_PointerTowprt__PrinterElementsType:
		return soap_out_PointerTowprt__PrinterElementsType(soap, tag, id, (struct wprt__PrinterElementsType *const*)ptr, "wprt:PrinterElementsType");
	case SOAP_TYPE_PointerTowprt__RequestedPrinterElementsType:
		return soap_out_PointerTowprt__RequestedPrinterElementsType(soap, tag, id, (struct wprt__RequestedPrinterElementsType *const*)ptr, "wprt:RequestedPrinterElementsType");
	case SOAP_TYPE_PointerTowprt__AnyURIExtType:
		return soap_out_PointerTowprt__AnyURIExtType(soap, tag, id, (struct wprt__AnyURIExtType *const*)ptr, "wprt:AnyURIExtType");
	case SOAP_TYPE_PointerTowprt__BoolExtType:
		return soap_out_PointerTowprt__BoolExtType(soap, tag, id, (struct wprt__BoolExtType *const*)ptr, "wprt:BoolExtType");
	case SOAP_TYPE_PointerTowprt__DocumentProcessingType:
		return soap_out_PointerTowprt__DocumentProcessingType(soap, tag, id, (struct wprt__DocumentProcessingType *const*)ptr, "wprt:DocumentProcessingType");
	case SOAP_TYPE_PointerTowprt__DocumentDescriptionType:
		return soap_out_PointerTowprt__DocumentDescriptionType(soap, tag, id, (struct wprt__DocumentDescriptionType *const*)ptr, "wprt:DocumentDescriptionType");
	case SOAP_TYPE_PointerTowprt__JobIdType:
		return soap_out_PointerTowprt__JobIdType(soap, tag, id, (struct wprt__JobIdType *const*)ptr, "wprt:JobIdType");
	case SOAP_TYPE_PointerTowprt__PrintTicketType:
		return soap_out_PointerTowprt__PrintTicketType(soap, tag, id, (struct wprt__PrintTicketType *const*)ptr, "wprt:PrintTicketType");
	case SOAP_TYPE_wprt__ComponentNameBaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:ComponentNameBaseType");
	case SOAP_TYPE_wprt__LocalizedStringRestrictType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:LocalizedStringRestrictType");
	case SOAP_TYPE_wprt__DeviceIdBaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:DeviceIdBaseType");
	case SOAP_TYPE_wprt__JobOriginatingUserNameRestrictionType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:JobOriginatingUserNameRestrictionType");
	case SOAP_TYPE_wprt__JobNameRestrictionType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:JobNameRestrictionType");
	case SOAP_TYPE_wprt__StringNsExtensionPatternType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:StringNsExtensionPatternType");
	case SOAP_TYPE_wprt__OutputBinExtensionPatternType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:OutputBinExtensionPatternType");
	case SOAP_TYPE_wprt__MimeExtensionPatternType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MimeExtensionPatternType");
	case SOAP_TYPE_wprt__KeywordNsExtensionPatternType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:KeywordNsExtensionPatternType");
	case SOAP_TYPE_wprt__InputBinExtensionPatternType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:InputBinExtensionPatternType");
	case SOAP_TYPE_wprt__MediaNsExtensionPatternType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MediaNsExtensionPatternType");
	case SOAP_TYPE_wprt__MediaColorExtensionPatternType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MediaColorExtensionPatternType");
	case SOAP_TYPE_wprt__MediaTypeExtensionPatternType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MediaTypeExtensionPatternType");
	case SOAP_TYPE_wprt__MediaSizeNameExtensionPatternType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MediaSizeNameExtensionPatternType");
	case SOAP_TYPE_wprt__InputBinMediaColorBaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:InputBinMediaColorBaseType");
	case SOAP_TYPE_wprt__InputBinMediaSizeBaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:InputBinMediaSizeBaseType");
	case SOAP_TYPE_wprt__String255BaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:String255BaseType");
	case SOAP_TYPE_wprt__PrinterStateReasonBaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:PrinterStateReasonBaseType");
	case SOAP_TYPE_wprt__PrinterStateBaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:PrinterStateBaseType");
	case SOAP_TYPE_wprt__HolePunchPatternExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:HolePunchPatternExtType");
	case SOAP_TYPE_wprt__HolePunchEdgeExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:HolePunchEdgeExtType");
	case SOAP_TYPE_wprt__StapleAngleExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:StapleAngleExtType");
	case SOAP_TYPE_wprt__StapleLocationExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:StapleLocationExtType");
	case SOAP_TYPE_wprt__JobStateReasonExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:JobStateReasonExtType");
	case SOAP_TYPE_wprt__JobStateExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:JobStateExtType");
	case SOAP_TYPE_wprt__SidesBaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:SidesBaseType");
	case SOAP_TYPE_wprt__PrintQualityBaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:PrintQualityBaseType");
	case SOAP_TYPE_wprt__OrientationBaseType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:OrientationBaseType");
	case SOAP_TYPE_wprt__MediaSizeNameWKVType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MediaSizeNameWKVType");
	case SOAP_TYPE_wprt__MediaWKVType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MediaWKVType");
	case SOAP_TYPE_wprt__OutputBinNameType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:OutputBinNameType");
	case SOAP_TYPE_wprt__InputBinNameType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:InputBinNameType");
	case SOAP_TYPE_wprt__ConsumableColorExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:ConsumableColorExtType");
	case SOAP_TYPE_wprt__ConsumableTypeExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:ConsumableTypeExtType");
	case SOAP_TYPE_wprt__StorageTypeExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:StorageTypeExtType");
	case SOAP_TYPE_wprt__MediaColorExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MediaColorExtType");
	case SOAP_TYPE_wprt__MediaTypeExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MediaTypeExtType");
	case SOAP_TYPE_wprt__MediaSizeNameExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:MediaSizeNameExtType");
	case SOAP_TYPE_wprt__DocumentFormatExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:DocumentFormatExtType");
	case SOAP_TYPE_wprt__CompressionExtType:
		return soap_out_string(soap, tag, id, (char**)&ptr, "wprt:CompressionExtType");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:QName");
	case SOAP_TYPE_xsd__NMTOKENS:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:NMTOKENS");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:NMTOKEN");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_SOAP_ENV__Reason:
		soap_serialize_SOAP_ENV__Reason(soap, (const struct SOAP_ENV__Reason *)ptr);
		break;
	case SOAP_TYPE___wprt__JobEndStateEvent:
		soap_serialize___wprt__JobEndStateEvent(soap, (const struct __wprt__JobEndStateEvent *)ptr);
		break;
	case SOAP_TYPE___wprt__JobStatusEvent:
		soap_serialize___wprt__JobStatusEvent(soap, (const struct __wprt__JobStatusEvent *)ptr);
		break;
	case SOAP_TYPE___wprt__PrinterStatusConditionClearedEvent:
		soap_serialize___wprt__PrinterStatusConditionClearedEvent(soap, (const struct __wprt__PrinterStatusConditionClearedEvent *)ptr);
		break;
	case SOAP_TYPE___wprt__PrinterStatusConditionEvent:
		soap_serialize___wprt__PrinterStatusConditionEvent(soap, (const struct __wprt__PrinterStatusConditionEvent *)ptr);
		break;
	case SOAP_TYPE___wprt__PrinterStatusSummaryEvent:
		soap_serialize___wprt__PrinterStatusSummaryEvent(soap, (const struct __wprt__PrinterStatusSummaryEvent *)ptr);
		break;
	case SOAP_TYPE___wprt__PrinterElementsChangeEvent:
		soap_serialize___wprt__PrinterElementsChangeEvent(soap, (const struct __wprt__PrinterElementsChangeEvent *)ptr);
		break;
	case SOAP_TYPE___wprt__SetEventRate:
		soap_serialize___wprt__SetEventRate(soap, (const struct __wprt__SetEventRate *)ptr);
		break;
	case SOAP_TYPE___wprt__GetJobHistory:
		soap_serialize___wprt__GetJobHistory(soap, (const struct __wprt__GetJobHistory *)ptr);
		break;
	case SOAP_TYPE___wprt__GetActiveJobs:
		soap_serialize___wprt__GetActiveJobs(soap, (const struct __wprt__GetActiveJobs *)ptr);
		break;
	case SOAP_TYPE___wprt__GetJobElements:
		soap_serialize___wprt__GetJobElements(soap, (const struct __wprt__GetJobElements *)ptr);
		break;
	case SOAP_TYPE___wprt__GetPrinterElements:
		soap_serialize___wprt__GetPrinterElements(soap, (const struct __wprt__GetPrinterElements *)ptr);
		break;
	case SOAP_TYPE___wprt__CancelJob:
		soap_serialize___wprt__CancelJob(soap, (const struct __wprt__CancelJob *)ptr);
		break;
	case SOAP_TYPE___wprt__AddDocument:
		soap_serialize___wprt__AddDocument(soap, (const struct __wprt__AddDocument *)ptr);
		break;
	case SOAP_TYPE___wprt__SendDocument:
		soap_serialize___wprt__SendDocument(soap, (const struct __wprt__SendDocument *)ptr);
		break;
	case SOAP_TYPE___wprt__CreatePrintJob:
		soap_serialize___wprt__CreatePrintJob(soap, (const struct __wprt__CreatePrintJob *)ptr);
		break;
	case SOAP_TYPE__wprt__Printer:
		soap_serialize__wprt__Printer(soap, (const struct _wprt__Printer *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterElementDataType:
		soap_serialize_wprt__PrinterElementDataType(soap, (const struct wprt__PrinterElementDataType *)ptr);
		break;
	case SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription:
		soap_serialize__wprt__DocumentValuesType_DocumentDescription(soap, (const struct _wprt__DocumentValuesType_DocumentDescription *)ptr);
		break;
	case SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution:
		soap_serialize__wprt__JobValuesType_DocumentProcessing_Resolution(soap, (const struct _wprt__JobValuesType_DocumentProcessing_Resolution *)ptr);
		break;
	case SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp:
		soap_serialize__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, (const struct _wprt__JobValuesType_DocumentProcessing_NumberUp *)ptr);
		break;
	case SOAP_TYPE__wprt__JobValuesType_DocumentProcessing:
		soap_serialize__wprt__JobValuesType_DocumentProcessing(soap, (const struct _wprt__JobValuesType_DocumentProcessing *)ptr);
		break;
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch:
		soap_serialize__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, (const struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *)ptr);
		break;
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple:
		soap_serialize__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, (const struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *)ptr);
		break;
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings:
		soap_serialize__wprt__JobValuesType_JobProcessing_JobFinishings(soap, (const struct _wprt__JobValuesType_JobProcessing_JobFinishings *)ptr);
		break;
	case SOAP_TYPE__wprt__JobValuesType_JobProcessing:
		soap_serialize__wprt__JobValuesType_JobProcessing(soap, (const struct _wprt__JobValuesType_JobProcessing *)ptr);
		break;
	case SOAP_TYPE_wprt__DocumentValuesType:
		soap_serialize_wprt__DocumentValuesType(soap, (const struct wprt__DocumentValuesType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobValuesType:
		soap_serialize_wprt__JobValuesType(soap, (const struct wprt__JobValuesType *)ptr);
		break;
	case SOAP_TYPE_wprt__ComponentNameType:
		soap_serialize_wprt__ComponentNameType(soap, (const struct wprt__ComponentNameType *)ptr);
		break;
	case SOAP_TYPE_wprt__ComponentGroupType:
		soap_serialize_wprt__ComponentGroupType(soap, (const struct wprt__ComponentGroupType *)ptr);
		break;
	case SOAP_TYPE_wprt__ConditionSeverityType:
		soap_serialize_wprt__ConditionSeverityType(soap, (const struct wprt__ConditionSeverityType *)ptr);
		break;
	case SOAP_TYPE_wprt__ConditionComponentType:
		soap_serialize_wprt__ConditionComponentType(soap, (const struct wprt__ConditionComponentType *)ptr);
		break;
	case SOAP_TYPE_wprt__ConditionNameType:
		soap_serialize_wprt__ConditionNameType(soap, (const struct wprt__ConditionNameType *)ptr);
		break;
	case SOAP_TYPE_wprt__ConditionHistoryEntryType:
		soap_serialize_wprt__ConditionHistoryEntryType(soap, (const struct wprt__ConditionHistoryEntryType *)ptr);
		break;
	case SOAP_TYPE_wprt__ConditionHistoryTableType:
		soap_serialize_wprt__ConditionHistoryTableType(soap, (const struct wprt__ConditionHistoryTableType *)ptr);
		break;
	case SOAP_TYPE_wprt__ActiveConditionTableType:
		soap_serialize_wprt__ActiveConditionTableType(soap, (const struct wprt__ActiveConditionTableType *)ptr);
		break;
	case SOAP_TYPE_wprt__OutputBinsType:
		soap_serialize_wprt__OutputBinsType(soap, (const struct wprt__OutputBinsType *)ptr);
		break;
	case SOAP_TYPE_wprt__InputBinsType:
		soap_serialize_wprt__InputBinsType(soap, (const struct wprt__InputBinsType *)ptr);
		break;
	case SOAP_TYPE_wprt__ConsumablesType:
		soap_serialize_wprt__ConsumablesType(soap, (const struct wprt__ConsumablesType *)ptr);
		break;
	case SOAP_TYPE_wprt__StorageBaseType:
		soap_serialize_wprt__StorageBaseType(soap, (const struct wprt__StorageBaseType *)ptr);
		break;
	case SOAP_TYPE_wprt__LocalizedStringType:
		soap_serialize_wprt__LocalizedStringType(soap, (const struct wprt__LocalizedStringType *)ptr);
		break;
	case SOAP_TYPE_wprt__DeviceIdType:
		soap_serialize_wprt__DeviceIdType(soap, (const struct wprt__DeviceIdType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterStatusType:
		soap_serialize_wprt__PrinterStatusType(soap, (const struct wprt__PrinterStatusType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterType:
		soap_serialize_wprt__PrinterType(soap, (const struct wprt__PrinterType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobElementDataType:
		soap_serialize_wprt__JobElementDataType(soap, (const struct wprt__JobElementDataType *)ptr);
		break;
	case SOAP_TYPE_wprt__QNameExtType:
		soap_serialize_wprt__QNameExtType(soap, (const struct wprt__QNameExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__HolePunchPatternType:
		soap_serialize_wprt__HolePunchPatternType(soap, (const struct wprt__HolePunchPatternType *)ptr);
		break;
	case SOAP_TYPE_wprt__HolePunchEdgeType:
		soap_serialize_wprt__HolePunchEdgeType(soap, (const struct wprt__HolePunchEdgeType *)ptr);
		break;
	case SOAP_TYPE_wprt__StapleAngleType:
		soap_serialize_wprt__StapleAngleType(soap, (const struct wprt__StapleAngleType *)ptr);
		break;
	case SOAP_TYPE_wprt__StapleLocationType:
		soap_serialize_wprt__StapleLocationType(soap, (const struct wprt__StapleLocationType *)ptr);
		break;
	case SOAP_TYPE_wprt__HolePunchDetailsType:
		soap_serialize_wprt__HolePunchDetailsType(soap, (const struct wprt__HolePunchDetailsType *)ptr);
		break;
	case SOAP_TYPE_wprt__StapleDetailsType:
		soap_serialize_wprt__StapleDetailsType(soap, (const struct wprt__StapleDetailsType *)ptr);
		break;
	case SOAP_TYPE_wprt__BooleanExtType:
		soap_serialize_wprt__BooleanExtType(soap, (const struct wprt__BooleanExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobPriorityType:
		soap_serialize_wprt__JobPriorityType(soap, (const struct wprt__JobPriorityType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobFinishingsType:
		soap_serialize_wprt__JobFinishingsType(soap, (const struct wprt__JobFinishingsType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobCopiesType:
		soap_serialize_wprt__JobCopiesType(soap, (const struct wprt__JobCopiesType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobProcessingType:
		soap_serialize_wprt__JobProcessingType(soap, (const struct wprt__JobProcessingType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobDescriptionType:
		soap_serialize_wprt__JobDescriptionType(soap, (const struct wprt__JobDescriptionType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobStateReasonType:
		soap_serialize_wprt__JobStateReasonType(soap, (const struct wprt__JobStateReasonType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobSummaryType:
		soap_serialize_wprt__JobSummaryType(soap, (const struct wprt__JobSummaryType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobType:
		soap_serialize_wprt__JobType(soap, (const struct wprt__JobType *)ptr);
		break;
	case SOAP_TYPE_wprt__ListOfJobsType:
		soap_serialize_wprt__ListOfJobsType(soap, (const struct wprt__ListOfJobsType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobTableType:
		soap_serialize_wprt__JobTableType(soap, (const struct wprt__JobTableType *)ptr);
		break;
	case SOAP_TYPE_wprt__NUpDirectionType:
		soap_serialize_wprt__NUpDirectionType(soap, (const struct wprt__NUpDirectionType *)ptr);
		break;
	case SOAP_TYPE_wprt__NUpPagesPerSheetType:
		soap_serialize_wprt__NUpPagesPerSheetType(soap, (const struct wprt__NUpPagesPerSheetType *)ptr);
		break;
	case SOAP_TYPE_wprt__SidesType:
		soap_serialize_wprt__SidesType(soap, (const struct wprt__SidesType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrintQualityType:
		soap_serialize_wprt__PrintQualityType(soap, (const struct wprt__PrintQualityType *)ptr);
		break;
	case SOAP_TYPE_wprt__ResolutionType:
		soap_serialize_wprt__ResolutionType(soap, (const struct wprt__ResolutionType *)ptr);
		break;
	case SOAP_TYPE_wprt__OrientationType:
		soap_serialize_wprt__OrientationType(soap, (const struct wprt__OrientationType *)ptr);
		break;
	case SOAP_TYPE_wprt__NumberUpType:
		soap_serialize_wprt__NumberUpType(soap, (const struct wprt__NumberUpType *)ptr);
		break;
	case SOAP_TYPE_wprt__MediaColorType:
		soap_serialize_wprt__MediaColorType(soap, (const struct wprt__MediaColorType *)ptr);
		break;
	case SOAP_TYPE_wprt__MediaTypeBaseType:
		soap_serialize_wprt__MediaTypeBaseType(soap, (const struct wprt__MediaTypeBaseType *)ptr);
		break;
	case SOAP_TYPE_wprt__MediaSizeNameType:
		soap_serialize_wprt__MediaSizeNameType(soap, (const struct wprt__MediaSizeNameType *)ptr);
		break;
	case SOAP_TYPE_wprt__DocumentFormatType:
		soap_serialize_wprt__DocumentFormatType(soap, (const struct wprt__DocumentFormatType *)ptr);
		break;
	case SOAP_TYPE_wprt__CompressionType:
		soap_serialize_wprt__CompressionType(soap, (const struct wprt__CompressionType *)ptr);
		break;
	case SOAP_TYPE_wprt__DocumentsType:
		soap_serialize_wprt__DocumentsType(soap, (const struct wprt__DocumentsType *)ptr);
		break;
	case SOAP_TYPE_wprt__DocumentType:
		soap_serialize_wprt__DocumentType(soap, (const struct wprt__DocumentType *)ptr);
		break;
	case SOAP_TYPE_wprt__OutputBinEntryType:
		soap_serialize_wprt__OutputBinEntryType(soap, (const struct wprt__OutputBinEntryType *)ptr);
		break;
	case SOAP_TYPE_wprt__FinishingsType:
		soap_serialize_wprt__FinishingsType(soap, (const struct wprt__FinishingsType *)ptr);
		break;
	case SOAP_TYPE_wprt__CapacityBaseType:
		soap_serialize_wprt__CapacityBaseType(soap, (const struct wprt__CapacityBaseType *)ptr);
		break;
	case SOAP_TYPE_wprt__InputBinMediaColorType:
		soap_serialize_wprt__InputBinMediaColorType(soap, (const struct wprt__InputBinMediaColorType *)ptr);
		break;
	case SOAP_TYPE_wprt__InputBinMediaTypeBaseType:
		soap_serialize_wprt__InputBinMediaTypeBaseType(soap, (const struct wprt__InputBinMediaTypeBaseType *)ptr);
		break;
	case SOAP_TYPE_wprt__InputBinMediaSizeType:
		soap_serialize_wprt__InputBinMediaSizeType(soap, (const struct wprt__InputBinMediaSizeType *)ptr);
		break;
	case SOAP_TYPE_wprt__InputBinFeedDirectionType:
		soap_serialize_wprt__InputBinFeedDirectionType(soap, (const struct wprt__InputBinFeedDirectionType *)ptr);
		break;
	case SOAP_TYPE_wprt__InputBinEntryType:
		soap_serialize_wprt__InputBinEntryType(soap, (const struct wprt__InputBinEntryType *)ptr);
		break;
	case SOAP_TYPE_wprt__String255ExtType:
		soap_serialize_wprt__String255ExtType(soap, (const struct wprt__String255ExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__ConsumableColorType:
		soap_serialize_wprt__ConsumableColorType(soap, (const struct wprt__ConsumableColorType *)ptr);
		break;
	case SOAP_TYPE_wprt__ConsumableTypeBaseType:
		soap_serialize_wprt__ConsumableTypeBaseType(soap, (const struct wprt__ConsumableTypeBaseType *)ptr);
		break;
	case SOAP_TYPE_wprt__ConsumableEntryType:
		soap_serialize_wprt__ConsumableEntryType(soap, (const struct wprt__ConsumableEntryType *)ptr);
		break;
	case SOAP_TYPE_wprt__LevelFreeBaseType:
		soap_serialize_wprt__LevelFreeBaseType(soap, (const struct wprt__LevelFreeBaseType *)ptr);
		break;
	case SOAP_TYPE_wprt__IntOneExtType:
		soap_serialize_wprt__IntOneExtType(soap, (const struct wprt__IntOneExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__StorageTypeBaseType:
		soap_serialize_wprt__StorageTypeBaseType(soap, (const struct wprt__StorageTypeBaseType *)ptr);
		break;
	case SOAP_TYPE_wprt__StorageEntryType:
		soap_serialize_wprt__StorageEntryType(soap, (const struct wprt__StorageEntryType *)ptr);
		break;
	case SOAP_TYPE_wprt__ResolutionEntryType:
		soap_serialize_wprt__ResolutionEntryType(soap, (const struct wprt__ResolutionEntryType *)ptr);
		break;
	case SOAP_TYPE_wprt__ValueIntRangeType:
		soap_serialize_wprt__ValueIntRangeType(soap, (const struct wprt__ValueIntRangeType *)ptr);
		break;
	case SOAP_TYPE_wprt__IntExtType:
		soap_serialize_wprt__IntExtType(soap, (const struct wprt__IntExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__ValueIntListType:
		soap_serialize_wprt__ValueIntListType(soap, (const struct wprt__ValueIntListType *)ptr);
		break;
	case SOAP_TYPE_wprt__ValueStringListType:
		soap_serialize_wprt__ValueStringListType(soap, (const struct wprt__ValueStringListType *)ptr);
		break;
	case SOAP_TYPE_wprt__NMTOKENSExtType:
		soap_serialize_wprt__NMTOKENSExtType(soap, (const struct wprt__NMTOKENSExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__ValueTokenListType:
		soap_serialize_wprt__ValueTokenListType(soap, (const struct wprt__ValueTokenListType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobEndStateEventType:
		soap_serialize_wprt__JobEndStateEventType(soap, (const struct wprt__JobEndStateEventType *)ptr);
		break;
	case SOAP_TYPE_wprt__IntZeroExtType:
		soap_serialize_wprt__IntZeroExtType(soap, (const struct wprt__IntZeroExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobOriginatingUserNameType:
		soap_serialize_wprt__JobOriginatingUserNameType(soap, (const struct wprt__JobOriginatingUserNameType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobNameType:
		soap_serialize_wprt__JobNameType(soap, (const struct wprt__JobNameType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobStateReasonsType:
		soap_serialize_wprt__JobStateReasonsType(soap, (const struct wprt__JobStateReasonsType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobStateType:
		soap_serialize_wprt__JobStateType(soap, (const struct wprt__JobStateType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobEndStateType:
		soap_serialize_wprt__JobEndStateType(soap, (const struct wprt__JobEndStateType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobStatusType:
		soap_serialize_wprt__JobStatusType(soap, (const struct wprt__JobStatusType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobStatusEventType:
		soap_serialize_wprt__JobStatusEventType(soap, (const struct wprt__JobStatusEventType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType:
		soap_serialize_wprt__PrinterStatusConditionClearedEventType(soap, (const struct wprt__PrinterStatusConditionClearedEventType *)ptr);
		break;
	case SOAP_TYPE_wprt__DateTimeExtType:
		soap_serialize_wprt__DateTimeExtType(soap, (const struct wprt__DateTimeExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__DeviceConditionClearedType:
		soap_serialize_wprt__DeviceConditionClearedType(soap, (const struct wprt__DeviceConditionClearedType *)ptr);
		break;
	case SOAP_TYPE_wprt__DeviceConditionType:
		soap_serialize_wprt__DeviceConditionType(soap, (const struct wprt__DeviceConditionType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterStatusConditionEventType:
		soap_serialize_wprt__PrinterStatusConditionEventType(soap, (const struct wprt__PrinterStatusConditionEventType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterStatusSummaryEventType:
		soap_serialize_wprt__PrinterStatusSummaryEventType(soap, (const struct wprt__PrinterStatusSummaryEventType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterStateReasonsType:
		soap_serialize_wprt__PrinterStateReasonsType(soap, (const struct wprt__PrinterStateReasonsType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterStateReasonType:
		soap_serialize_wprt__PrinterStateReasonType(soap, (const struct wprt__PrinterStateReasonType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterStateType:
		soap_serialize_wprt__PrinterStateType(soap, (const struct wprt__PrinterStateType *)ptr);
		break;
	case SOAP_TYPE_wprt__StatusSummaryType:
		soap_serialize_wprt__StatusSummaryType(soap, (const struct wprt__StatusSummaryType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterElementsChangeEventType:
		soap_serialize_wprt__PrinterElementsChangeEventType(soap, (const struct wprt__PrinterElementsChangeEventType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterCapabilitiesType:
		soap_serialize_wprt__PrinterCapabilitiesType(soap, (const struct wprt__PrinterCapabilitiesType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterConfigurationType:
		soap_serialize_wprt__PrinterConfigurationType(soap, (const struct wprt__PrinterConfigurationType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterDescriptionType:
		soap_serialize_wprt__PrinterDescriptionType(soap, (const struct wprt__PrinterDescriptionType *)ptr);
		break;
	case SOAP_TYPE_wprt__ElementChangesType:
		soap_serialize_wprt__ElementChangesType(soap, (const struct wprt__ElementChangesType *)ptr);
		break;
	case SOAP_TYPE_wprt__SetEventRateResponseType:
		soap_serialize_wprt__SetEventRateResponseType(soap, (const struct wprt__SetEventRateResponseType *)ptr);
		break;
	case SOAP_TYPE_wprt__EventRateType:
		soap_serialize_wprt__EventRateType(soap, (const struct wprt__EventRateType *)ptr);
		break;
	case SOAP_TYPE_wprt__SetEventRateRequestType:
		soap_serialize_wprt__SetEventRateRequestType(soap, (const struct wprt__SetEventRateRequestType *)ptr);
		break;
	case SOAP_TYPE_wprt__GetJobHistoryResponseType:
		soap_serialize_wprt__GetJobHistoryResponseType(soap, (const struct wprt__GetJobHistoryResponseType *)ptr);
		break;
	case SOAP_TYPE_wprt__GetJobHistoryRequestType:
		soap_serialize_wprt__GetJobHistoryRequestType(soap, (const struct wprt__GetJobHistoryRequestType *)ptr);
		break;
	case SOAP_TYPE_wprt__ListOfSummarysType:
		soap_serialize_wprt__ListOfSummarysType(soap, (const struct wprt__ListOfSummarysType *)ptr);
		break;
	case SOAP_TYPE_wprt__GetActiveJobsResponseType:
		soap_serialize_wprt__GetActiveJobsResponseType(soap, (const struct wprt__GetActiveJobsResponseType *)ptr);
		break;
	case SOAP_TYPE_wprt__GetActiveJobsRequestType:
		soap_serialize_wprt__GetActiveJobsRequestType(soap, (const struct wprt__GetActiveJobsRequestType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobElementsType:
		soap_serialize_wprt__JobElementsType(soap, (const struct wprt__JobElementsType *)ptr);
		break;
	case SOAP_TYPE_wprt__GetJobElementsResponseType:
		soap_serialize_wprt__GetJobElementsResponseType(soap, (const struct wprt__GetJobElementsResponseType *)ptr);
		break;
	case SOAP_TYPE_wprt__RequestedJobElementsType:
		soap_serialize_wprt__RequestedJobElementsType(soap, (const struct wprt__RequestedJobElementsType *)ptr);
		break;
	case SOAP_TYPE_wprt__GetJobElementsRequestType:
		soap_serialize_wprt__GetJobElementsRequestType(soap, (const struct wprt__GetJobElementsRequestType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrinterElementsType:
		soap_serialize_wprt__PrinterElementsType(soap, (const struct wprt__PrinterElementsType *)ptr);
		break;
	case SOAP_TYPE_wprt__GetPrinterElementsResponseType:
		soap_serialize_wprt__GetPrinterElementsResponseType(soap, (const struct wprt__GetPrinterElementsResponseType *)ptr);
		break;
	case SOAP_TYPE_wprt__RequestedPrinterElementsType:
		soap_serialize_wprt__RequestedPrinterElementsType(soap, (const struct wprt__RequestedPrinterElementsType *)ptr);
		break;
	case SOAP_TYPE_wprt__GetPrinterElementsRequestType:
		soap_serialize_wprt__GetPrinterElementsRequestType(soap, (const struct wprt__GetPrinterElementsRequestType *)ptr);
		break;
	case SOAP_TYPE_wprt__CancelJobResponseType:
		soap_serialize_wprt__CancelJobResponseType(soap, (const struct wprt__CancelJobResponseType *)ptr);
		break;
	case SOAP_TYPE_wprt__CancelJobRequestType:
		soap_serialize_wprt__CancelJobRequestType(soap, (const struct wprt__CancelJobRequestType *)ptr);
		break;
	case SOAP_TYPE_wprt__AddDocumentResponseType:
		soap_serialize_wprt__AddDocumentResponseType(soap, (const struct wprt__AddDocumentResponseType *)ptr);
		break;
	case SOAP_TYPE_wprt__AnyURIExtType:
		soap_serialize_wprt__AnyURIExtType(soap, (const struct wprt__AnyURIExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__AddDocumentRequestType:
		soap_serialize_wprt__AddDocumentRequestType(soap, (const struct wprt__AddDocumentRequestType *)ptr);
		break;
	case SOAP_TYPE_wprt__SendDocumentResponseType:
		soap_serialize_wprt__SendDocumentResponseType(soap, (const struct wprt__SendDocumentResponseType *)ptr);
		break;
	case SOAP_TYPE_wprt__BoolExtType:
		soap_serialize_wprt__BoolExtType(soap, (const struct wprt__BoolExtType *)ptr);
		break;
	case SOAP_TYPE_wprt__DocumentProcessingType:
		soap_serialize_wprt__DocumentProcessingType(soap, (const struct wprt__DocumentProcessingType *)ptr);
		break;
	case SOAP_TYPE_wprt__DocumentDescriptionType:
		soap_serialize_wprt__DocumentDescriptionType(soap, (const struct wprt__DocumentDescriptionType *)ptr);
		break;
	case SOAP_TYPE_wprt__SendDocumentRequestType:
		soap_serialize_wprt__SendDocumentRequestType(soap, (const struct wprt__SendDocumentRequestType *)ptr);
		break;
	case SOAP_TYPE_wprt__JobIdType:
		soap_serialize_wprt__JobIdType(soap, (const struct wprt__JobIdType *)ptr);
		break;
	case SOAP_TYPE_wprt__CreatePrintJobResponseType:
		soap_serialize_wprt__CreatePrintJobResponseType(soap, (const struct wprt__CreatePrintJobResponseType *)ptr);
		break;
	case SOAP_TYPE_wprt__PrintTicketType:
		soap_serialize_wprt__PrintTicketType(soap, (const struct wprt__PrintTicketType *)ptr);
		break;
	case SOAP_TYPE_wprt__CreatePrintJobRequestType:
		soap_serialize_wprt__CreatePrintJobRequestType(soap, (const struct wprt__CreatePrintJobRequestType *)ptr);
		break;
	case SOAP_TYPE__xop__Include:
		soap_serialize__xop__Include(soap, (const struct _xop__Include *)ptr);
		break;
	case SOAP_TYPE_PointerToSOAP_ENV__Reason:
		soap_serialize_PointerToSOAP_ENV__Reason(soap, (struct SOAP_ENV__Reason *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobEndStateEventType:
		soap_serialize_PointerTowprt__JobEndStateEventType(soap, (struct wprt__JobEndStateEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobStatusEventType:
		soap_serialize_PointerTowprt__JobStatusEventType(soap, (struct wprt__JobStatusEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterStatusConditionClearedEventType:
		soap_serialize_PointerTowprt__PrinterStatusConditionClearedEventType(soap, (struct wprt__PrinterStatusConditionClearedEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterStatusConditionEventType:
		soap_serialize_PointerTowprt__PrinterStatusConditionEventType(soap, (struct wprt__PrinterStatusConditionEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterStatusSummaryEventType:
		soap_serialize_PointerTowprt__PrinterStatusSummaryEventType(soap, (struct wprt__PrinterStatusSummaryEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterElementsChangeEventType:
		soap_serialize_PointerTowprt__PrinterElementsChangeEventType(soap, (struct wprt__PrinterElementsChangeEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__SetEventRateResponseType:
		soap_serialize_PointerTowprt__SetEventRateResponseType(soap, (struct wprt__SetEventRateResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__SetEventRateRequestType:
		soap_serialize_PointerTowprt__SetEventRateRequestType(soap, (struct wprt__SetEventRateRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__GetJobHistoryResponseType:
		soap_serialize_PointerTowprt__GetJobHistoryResponseType(soap, (struct wprt__GetJobHistoryResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__GetJobHistoryRequestType:
		soap_serialize_PointerTowprt__GetJobHistoryRequestType(soap, (struct wprt__GetJobHistoryRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__GetActiveJobsResponseType:
		soap_serialize_PointerTowprt__GetActiveJobsResponseType(soap, (struct wprt__GetActiveJobsResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__GetActiveJobsRequestType:
		soap_serialize_PointerTowprt__GetActiveJobsRequestType(soap, (struct wprt__GetActiveJobsRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__GetJobElementsResponseType:
		soap_serialize_PointerTowprt__GetJobElementsResponseType(soap, (struct wprt__GetJobElementsResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__GetJobElementsRequestType:
		soap_serialize_PointerTowprt__GetJobElementsRequestType(soap, (struct wprt__GetJobElementsRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__GetPrinterElementsResponseType:
		soap_serialize_PointerTowprt__GetPrinterElementsResponseType(soap, (struct wprt__GetPrinterElementsResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__GetPrinterElementsRequestType:
		soap_serialize_PointerTowprt__GetPrinterElementsRequestType(soap, (struct wprt__GetPrinterElementsRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__CancelJobResponseType:
		soap_serialize_PointerTowprt__CancelJobResponseType(soap, (struct wprt__CancelJobResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__CancelJobRequestType:
		soap_serialize_PointerTowprt__CancelJobRequestType(soap, (struct wprt__CancelJobRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__AddDocumentResponseType:
		soap_serialize_PointerTowprt__AddDocumentResponseType(soap, (struct wprt__AddDocumentResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__AddDocumentRequestType:
		soap_serialize_PointerTowprt__AddDocumentRequestType(soap, (struct wprt__AddDocumentRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__SendDocumentResponseType:
		soap_serialize_PointerTowprt__SendDocumentResponseType(soap, (struct wprt__SendDocumentResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__SendDocumentRequestType:
		soap_serialize_PointerTowprt__SendDocumentRequestType(soap, (struct wprt__SendDocumentRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__CreatePrintJobResponseType:
		soap_serialize_PointerTowprt__CreatePrintJobResponseType(soap, (struct wprt__CreatePrintJobResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__CreatePrintJobRequestType:
		soap_serialize_PointerTowprt__CreatePrintJobRequestType(soap, (struct wprt__CreatePrintJobRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobTableType:
		soap_serialize_PointerTowprt__JobTableType(soap, (struct wprt__JobTableType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterElementDataType:
		soap_serialize_PointerTowprt__PrinterElementDataType(soap, (struct wprt__PrinterElementDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wprt__DocumentValuesType_DocumentDescription:
		soap_serialize_PointerTo_wprt__DocumentValuesType_DocumentDescription(soap, (struct _wprt__DocumentValuesType_DocumentDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ValueStringListType:
		soap_serialize_PointerTowprt__ValueStringListType(soap, (struct wprt__ValueStringListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing:
		soap_serialize_PointerTo_wprt__JobValuesType_DocumentProcessing(soap, (struct _wprt__JobValuesType_DocumentProcessing *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution:
		soap_serialize_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(soap, (struct _wprt__JobValuesType_DocumentProcessing_Resolution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ResolutionEntryType:
		soap_serialize_PointerTowprt__ResolutionEntryType(soap, (struct wprt__ResolutionEntryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp:
		soap_serialize_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(soap, (struct _wprt__JobValuesType_DocumentProcessing_NumberUp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ValueIntListType:
		soap_serialize_PointerTowprt__ValueIntListType(soap, (struct wprt__ValueIntListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing:
		soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing(soap, (struct _wprt__JobValuesType_JobProcessing *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings:
		soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(soap, (struct _wprt__JobValuesType_JobProcessing_JobFinishings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch:
		soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, (struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple:
		soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, (struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ValueTokenListType:
		soap_serialize_PointerTowprt__ValueTokenListType(soap, (struct wprt__ValueTokenListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ValueIntRangeType:
		soap_serialize_PointerTowprt__ValueIntRangeType(soap, (struct wprt__ValueIntRangeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DocumentValuesType:
		soap_serialize_PointerTowprt__DocumentValuesType(soap, (struct wprt__DocumentValuesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobValuesType:
		soap_serialize_PointerTowprt__JobValuesType(soap, (struct wprt__JobValuesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ComponentNameType:
		soap_serialize_PointerTowprt__ComponentNameType(soap, (struct wprt__ComponentNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ComponentGroupType:
		soap_serialize_PointerTowprt__ComponentGroupType(soap, (struct wprt__ComponentGroupType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ConditionSeverityType:
		soap_serialize_PointerTowprt__ConditionSeverityType(soap, (struct wprt__ConditionSeverityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ConditionComponentType:
		soap_serialize_PointerTowprt__ConditionComponentType(soap, (struct wprt__ConditionComponentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ConditionNameType:
		soap_serialize_PointerTowprt__ConditionNameType(soap, (struct wprt__ConditionNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ConditionHistoryEntryType:
		soap_serialize_PointerTowprt__ConditionHistoryEntryType(soap, (struct wprt__ConditionHistoryEntryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ConditionHistoryTableType:
		soap_serialize_PointerTowprt__ConditionHistoryTableType(soap, (struct wprt__ConditionHistoryTableType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ActiveConditionTableType:
		soap_serialize_PointerTowprt__ActiveConditionTableType(soap, (struct wprt__ActiveConditionTableType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__OutputBinEntryType:
		soap_serialize_PointerTowprt__OutputBinEntryType(soap, (struct wprt__OutputBinEntryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__InputBinEntryType:
		soap_serialize_PointerTowprt__InputBinEntryType(soap, (struct wprt__InputBinEntryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ConsumableEntryType:
		soap_serialize_PointerTowprt__ConsumableEntryType(soap, (struct wprt__ConsumableEntryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__StorageEntryType:
		soap_serialize_PointerTowprt__StorageEntryType(soap, (struct wprt__StorageEntryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__OutputBinsType:
		soap_serialize_PointerTowprt__OutputBinsType(soap, (struct wprt__OutputBinsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__FinishingsType:
		soap_serialize_PointerTowprt__FinishingsType(soap, (struct wprt__FinishingsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__InputBinsType:
		soap_serialize_PointerTowprt__InputBinsType(soap, (struct wprt__InputBinsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ConsumablesType:
		soap_serialize_PointerTowprt__ConsumablesType(soap, (struct wprt__ConsumablesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__StorageBaseType:
		soap_serialize_PointerTowprt__StorageBaseType(soap, (struct wprt__StorageBaseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__LocalizedStringType:
		soap_serialize_PointerTowprt__LocalizedStringType(soap, (struct wprt__LocalizedStringType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DeviceIdType:
		soap_serialize_PointerTowprt__DeviceIdType(soap, (struct wprt__DeviceIdType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterStatusType:
		soap_serialize_PointerTowprt__PrinterStatusType(soap, (struct wprt__PrinterStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobElementDataType:
		soap_serialize_PointerTowprt__JobElementDataType(soap, (struct wprt__JobElementDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__QNameExtType:
		soap_serialize_PointerTowprt__QNameExtType(soap, (struct wprt__QNameExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__HolePunchPatternType:
		soap_serialize_PointerTowprt__HolePunchPatternType(soap, (struct wprt__HolePunchPatternType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__HolePunchEdgeType:
		soap_serialize_PointerTowprt__HolePunchEdgeType(soap, (struct wprt__HolePunchEdgeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__StapleAngleType:
		soap_serialize_PointerTowprt__StapleAngleType(soap, (struct wprt__StapleAngleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__StapleLocationType:
		soap_serialize_PointerTowprt__StapleLocationType(soap, (struct wprt__StapleLocationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__HolePunchDetailsType:
		soap_serialize_PointerTowprt__HolePunchDetailsType(soap, (struct wprt__HolePunchDetailsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__StapleDetailsType:
		soap_serialize_PointerTowprt__StapleDetailsType(soap, (struct wprt__StapleDetailsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__BooleanExtType:
		soap_serialize_PointerTowprt__BooleanExtType(soap, (struct wprt__BooleanExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobPriorityType:
		soap_serialize_PointerTowprt__JobPriorityType(soap, (struct wprt__JobPriorityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobFinishingsType:
		soap_serialize_PointerTowprt__JobFinishingsType(soap, (struct wprt__JobFinishingsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobCopiesType:
		soap_serialize_PointerTowprt__JobCopiesType(soap, (struct wprt__JobCopiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobProcessingType:
		soap_serialize_PointerTowprt__JobProcessingType(soap, (struct wprt__JobProcessingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobDescriptionType:
		soap_serialize_PointerTowprt__JobDescriptionType(soap, (struct wprt__JobDescriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobStateReasonType:
		soap_serialize_PointerTowprt__JobStateReasonType(soap, (struct wprt__JobStateReasonType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobSummaryType:
		soap_serialize_PointerTowprt__JobSummaryType(soap, (struct wprt__JobSummaryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobType:
		soap_serialize_PointerTowprt__JobType(soap, (struct wprt__JobType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DocumentsType:
		soap_serialize_PointerTowprt__DocumentsType(soap, (struct wprt__DocumentsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ListOfJobsType:
		soap_serialize_PointerTowprt__ListOfJobsType(soap, (struct wprt__ListOfJobsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__NUpDirectionType:
		soap_serialize_PointerTowprt__NUpDirectionType(soap, (struct wprt__NUpDirectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__NUpPagesPerSheetType:
		soap_serialize_PointerTowprt__NUpPagesPerSheetType(soap, (struct wprt__NUpPagesPerSheetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__SidesType:
		soap_serialize_PointerTowprt__SidesType(soap, (struct wprt__SidesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrintQualityType:
		soap_serialize_PointerTowprt__PrintQualityType(soap, (struct wprt__PrintQualityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ResolutionType:
		soap_serialize_PointerTowprt__ResolutionType(soap, (struct wprt__ResolutionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__OrientationType:
		soap_serialize_PointerTowprt__OrientationType(soap, (struct wprt__OrientationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__NumberUpType:
		soap_serialize_PointerTowprt__NumberUpType(soap, (struct wprt__NumberUpType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__MediaColorType:
		soap_serialize_PointerTowprt__MediaColorType(soap, (struct wprt__MediaColorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__MediaTypeBaseType:
		soap_serialize_PointerTowprt__MediaTypeBaseType(soap, (struct wprt__MediaTypeBaseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__MediaSizeNameType:
		soap_serialize_PointerTowprt__MediaSizeNameType(soap, (struct wprt__MediaSizeNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DocumentFormatType:
		soap_serialize_PointerTowprt__DocumentFormatType(soap, (struct wprt__DocumentFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__CompressionType:
		soap_serialize_PointerTowprt__CompressionType(soap, (struct wprt__CompressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DocumentType:
		soap_serialize_PointerTowprt__DocumentType(soap, (struct wprt__DocumentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__CapacityBaseType:
		soap_serialize_PointerTowprt__CapacityBaseType(soap, (struct wprt__CapacityBaseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__InputBinMediaColorType:
		soap_serialize_PointerTowprt__InputBinMediaColorType(soap, (struct wprt__InputBinMediaColorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__InputBinMediaTypeBaseType:
		soap_serialize_PointerTowprt__InputBinMediaTypeBaseType(soap, (struct wprt__InputBinMediaTypeBaseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__InputBinMediaSizeType:
		soap_serialize_PointerTowprt__InputBinMediaSizeType(soap, (struct wprt__InputBinMediaSizeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__InputBinFeedDirectionType:
		soap_serialize_PointerTowprt__InputBinFeedDirectionType(soap, (struct wprt__InputBinFeedDirectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__String255ExtType:
		soap_serialize_PointerTowprt__String255ExtType(soap, (struct wprt__String255ExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ConsumableColorType:
		soap_serialize_PointerTowprt__ConsumableColorType(soap, (struct wprt__ConsumableColorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ConsumableTypeBaseType:
		soap_serialize_PointerTowprt__ConsumableTypeBaseType(soap, (struct wprt__ConsumableTypeBaseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__LevelFreeBaseType:
		soap_serialize_PointerTowprt__LevelFreeBaseType(soap, (struct wprt__LevelFreeBaseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__IntOneExtType:
		soap_serialize_PointerTowprt__IntOneExtType(soap, (struct wprt__IntOneExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__StorageTypeBaseType:
		soap_serialize_PointerTowprt__StorageTypeBaseType(soap, (struct wprt__StorageTypeBaseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__IntExtType:
		soap_serialize_PointerTowprt__IntExtType(soap, (struct wprt__IntExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__NMTOKENSExtType:
		soap_serialize_PointerTowprt__NMTOKENSExtType(soap, (struct wprt__NMTOKENSExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobEndStateType:
		soap_serialize_PointerTowprt__JobEndStateType(soap, (struct wprt__JobEndStateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__IntZeroExtType:
		soap_serialize_PointerTowprt__IntZeroExtType(soap, (struct wprt__IntZeroExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobOriginatingUserNameType:
		soap_serialize_PointerTowprt__JobOriginatingUserNameType(soap, (struct wprt__JobOriginatingUserNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobNameType:
		soap_serialize_PointerTowprt__JobNameType(soap, (struct wprt__JobNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobStateReasonsType:
		soap_serialize_PointerTowprt__JobStateReasonsType(soap, (struct wprt__JobStateReasonsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobStateType:
		soap_serialize_PointerTowprt__JobStateType(soap, (struct wprt__JobStateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobStatusType:
		soap_serialize_PointerTowprt__JobStatusType(soap, (struct wprt__JobStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DeviceConditionClearedType:
		soap_serialize_PointerTowprt__DeviceConditionClearedType(soap, (struct wprt__DeviceConditionClearedType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DateTimeExtType:
		soap_serialize_PointerTowprt__DateTimeExtType(soap, (struct wprt__DateTimeExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DeviceConditionType:
		soap_serialize_PointerTowprt__DeviceConditionType(soap, (struct wprt__DeviceConditionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__StatusSummaryType:
		soap_serialize_PointerTowprt__StatusSummaryType(soap, (struct wprt__StatusSummaryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterStateReasonsType:
		soap_serialize_PointerTowprt__PrinterStateReasonsType(soap, (struct wprt__PrinterStateReasonsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterStateReasonType:
		soap_serialize_PointerTowprt__PrinterStateReasonType(soap, (struct wprt__PrinterStateReasonType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterStateType:
		soap_serialize_PointerTowprt__PrinterStateType(soap, (struct wprt__PrinterStateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ElementChangesType:
		soap_serialize_PointerTowprt__ElementChangesType(soap, (struct wprt__ElementChangesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterCapabilitiesType:
		soap_serialize_PointerTowprt__PrinterCapabilitiesType(soap, (struct wprt__PrinterCapabilitiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterConfigurationType:
		soap_serialize_PointerTowprt__PrinterConfigurationType(soap, (struct wprt__PrinterConfigurationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterDescriptionType:
		soap_serialize_PointerTowprt__PrinterDescriptionType(soap, (struct wprt__PrinterDescriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__EventRateType:
		soap_serialize_PointerTowprt__EventRateType(soap, (struct wprt__EventRateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__ListOfSummarysType:
		soap_serialize_PointerTowprt__ListOfSummarysType(soap, (struct wprt__ListOfSummarysType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobElementsType:
		soap_serialize_PointerTowprt__JobElementsType(soap, (struct wprt__JobElementsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__RequestedJobElementsType:
		soap_serialize_PointerTowprt__RequestedJobElementsType(soap, (struct wprt__RequestedJobElementsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrinterElementsType:
		soap_serialize_PointerTowprt__PrinterElementsType(soap, (struct wprt__PrinterElementsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__RequestedPrinterElementsType:
		soap_serialize_PointerTowprt__RequestedPrinterElementsType(soap, (struct wprt__RequestedPrinterElementsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__AnyURIExtType:
		soap_serialize_PointerTowprt__AnyURIExtType(soap, (struct wprt__AnyURIExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__BoolExtType:
		soap_serialize_PointerTowprt__BoolExtType(soap, (struct wprt__BoolExtType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DocumentProcessingType:
		soap_serialize_PointerTowprt__DocumentProcessingType(soap, (struct wprt__DocumentProcessingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__DocumentDescriptionType:
		soap_serialize_PointerTowprt__DocumentDescriptionType(soap, (struct wprt__DocumentDescriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__JobIdType:
		soap_serialize_PointerTowprt__JobIdType(soap, (struct wprt__JobIdType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowprt__PrintTicketType:
		soap_serialize_PointerTowprt__PrintTicketType(soap, (struct wprt__PrintTicketType *const*)ptr);
		break;
	case SOAP_TYPE_wprt__ComponentNameBaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__LocalizedStringRestrictType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__DeviceIdBaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__JobOriginatingUserNameRestrictionType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__JobNameRestrictionType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__StringNsExtensionPatternType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__OutputBinExtensionPatternType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MimeExtensionPatternType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__KeywordNsExtensionPatternType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__InputBinExtensionPatternType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MediaNsExtensionPatternType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MediaColorExtensionPatternType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MediaTypeExtensionPatternType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MediaSizeNameExtensionPatternType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__InputBinMediaColorBaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__InputBinMediaSizeBaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__String255BaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__PrinterStateReasonBaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__PrinterStateBaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__HolePunchPatternExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__HolePunchEdgeExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__StapleAngleExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__StapleLocationExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__JobStateReasonExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__JobStateExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__SidesBaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__PrintQualityBaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__OrientationBaseType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MediaSizeNameWKVType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MediaWKVType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__OutputBinNameType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__InputBinNameType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__ConsumableColorExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__ConsumableTypeExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__StorageTypeExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MediaColorExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MediaTypeExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__MediaSizeNameExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__DocumentFormatExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_wprt__CompressionExtType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKENS:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConditionIdType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConditionIdType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConditionIdType);
	if (soap_out_wprt__ConditionIdType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConditionIdType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__ConditionIdType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__ConditionIdType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConditionIdType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__ConditionIdType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__ConditionIdType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobPriorityRestrictionType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobPriorityRestrictionType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobPriorityRestrictionType);
	if (soap_out_wprt__JobPriorityRestrictionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobPriorityRestrictionType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__JobPriorityRestrictionType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__JobPriorityRestrictionType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobPriorityRestrictionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__JobPriorityRestrictionType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__JobPriorityRestrictionType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobCopiesRestrictionType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobCopiesRestrictionType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobCopiesRestrictionType);
	if (soap_out_wprt__JobCopiesRestrictionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobCopiesRestrictionType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__JobCopiesRestrictionType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__JobCopiesRestrictionType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobCopiesRestrictionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__JobCopiesRestrictionType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__JobCopiesRestrictionType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobIdRestrictionType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobIdRestrictionType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobIdRestrictionType);
	if (soap_out_wprt__JobIdRestrictionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobIdRestrictionType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__JobIdRestrictionType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__JobIdRestrictionType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobIdRestrictionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__JobIdRestrictionType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__JobIdRestrictionType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__NUpPagesPerSheetRestrictionType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__NUpPagesPerSheetRestrictionType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__NUpPagesPerSheetRestrictionType);
	if (soap_out_wprt__NUpPagesPerSheetRestrictionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__NUpPagesPerSheetRestrictionType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__NUpPagesPerSheetRestrictionType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__NUpPagesPerSheetRestrictionType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__NUpPagesPerSheetRestrictionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__NUpPagesPerSheetRestrictionType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__NUpPagesPerSheetRestrictionType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__EventRateBaseType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__EventRateBaseType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__EventRateBaseType);
	if (soap_out_wprt__EventRateBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__EventRateBaseType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__EventRateBaseType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__EventRateBaseType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__EventRateBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__EventRateBaseType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__EventRateBaseType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DocumentIdType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DocumentIdType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DocumentIdType);
	if (soap_out_wprt__DocumentIdType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DocumentIdType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__DocumentIdType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__DocumentIdType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DocumentIdType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__DocumentIdType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__DocumentIdType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__IntOneBaseType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__IntOneBaseType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__IntOneBaseType);
	if (soap_out_wprt__IntOneBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__IntOneBaseType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__IntOneBaseType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__IntOneBaseType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__IntOneBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__IntOneBaseType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__IntOneBaseType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__IntZeroBaseType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__IntZeroBaseType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__IntZeroBaseType);
	if (soap_out_wprt__IntZeroBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__IntZeroBaseType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__IntZeroBaseType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__IntZeroBaseType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__IntZeroBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__IntZeroBaseType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__IntZeroBaseType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__CapacityRestrictType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__CapacityRestrictType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__CapacityRestrictType);
	if (soap_out_wprt__CapacityRestrictType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__CapacityRestrictType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__CapacityRestrictType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__CapacityRestrictType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__CapacityRestrictType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__CapacityRestrictType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__CapacityRestrictType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__LevelFreeRestrictType(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__LevelFreeRestrictType(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__LevelFreeRestrictType);
	if (soap_out_wprt__LevelFreeRestrictType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__LevelFreeRestrictType(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_wprt__LevelFreeRestrictType);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_wprt__LevelFreeRestrictType(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__LevelFreeRestrictType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_wprt__LevelFreeRestrictType(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_wprt__LevelFreeRestrictType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConditionSeverityBaseType(struct soap *soap, enum wprt__ConditionSeverityBaseType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__ConditionSeverityBaseType
	*a = SOAP_DEFAULT_wprt__ConditionSeverityBaseType;
#else
	*a = (enum wprt__ConditionSeverityBaseType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConditionSeverityBaseType(struct soap *soap, const enum wprt__ConditionSeverityBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConditionSeverityBaseType);
	if (soap_out_wprt__ConditionSeverityBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__ConditionSeverityBaseType[] =
{	{ (long)wprt__ConditionSeverityBaseType__Informational, "Informational" },
	{ (long)wprt__ConditionSeverityBaseType__Warning, "Warning" },
	{ (long)wprt__ConditionSeverityBaseType__Critical, "Critical" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__ConditionSeverityBaseType2s(struct soap *soap, enum wprt__ConditionSeverityBaseType n)
{	const char *s = soap_code_str(soap_codes_wprt__ConditionSeverityBaseType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConditionSeverityBaseType(struct soap *soap, const char *tag, int id, const enum wprt__ConditionSeverityBaseType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ConditionSeverityBaseType), type);
	soap_send(soap, soap_wprt__ConditionSeverityBaseType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__ConditionSeverityBaseType * SOAP_FMAC4 soap_get_wprt__ConditionSeverityBaseType(struct soap *soap, enum wprt__ConditionSeverityBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConditionSeverityBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__ConditionSeverityBaseType(struct soap *soap, const char *s, enum wprt__ConditionSeverityBaseType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__ConditionSeverityBaseType, s);
	if (map)
		*a = (enum wprt__ConditionSeverityBaseType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__ConditionSeverityBaseType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__ConditionSeverityBaseType * SOAP_FMAC4 soap_in_wprt__ConditionSeverityBaseType(struct soap *soap, const char *tag, enum wprt__ConditionSeverityBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__ConditionSeverityBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConditionSeverityBaseType, sizeof(enum wprt__ConditionSeverityBaseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__ConditionSeverityBaseType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__ConditionSeverityBaseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ConditionSeverityBaseType, 0, sizeof(enum wprt__ConditionSeverityBaseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ComponentGroupBaseType(struct soap *soap, enum wprt__ComponentGroupBaseType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__ComponentGroupBaseType
	*a = SOAP_DEFAULT_wprt__ComponentGroupBaseType;
#else
	*a = (enum wprt__ComponentGroupBaseType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ComponentGroupBaseType(struct soap *soap, const enum wprt__ComponentGroupBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ComponentGroupBaseType);
	if (soap_out_wprt__ComponentGroupBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__ComponentGroupBaseType[] =
{	{ (long)wprt__ComponentGroupBaseType__PrintService, "PrintService" },
	{ (long)wprt__ComponentGroupBaseType__InputBin, "InputBin" },
	{ (long)wprt__ComponentGroupBaseType__MediaPath, "MediaPath" },
	{ (long)wprt__ComponentGroupBaseType__OutputBin, "OutputBin" },
	{ (long)wprt__ComponentGroupBaseType__Consumable, "Consumable" },
	{ (long)wprt__ComponentGroupBaseType__CoverDoor, "CoverDoor" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__ComponentGroupBaseType2s(struct soap *soap, enum wprt__ComponentGroupBaseType n)
{	const char *s = soap_code_str(soap_codes_wprt__ComponentGroupBaseType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ComponentGroupBaseType(struct soap *soap, const char *tag, int id, const enum wprt__ComponentGroupBaseType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ComponentGroupBaseType), type);
	soap_send(soap, soap_wprt__ComponentGroupBaseType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__ComponentGroupBaseType * SOAP_FMAC4 soap_get_wprt__ComponentGroupBaseType(struct soap *soap, enum wprt__ComponentGroupBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ComponentGroupBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__ComponentGroupBaseType(struct soap *soap, const char *s, enum wprt__ComponentGroupBaseType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__ComponentGroupBaseType, s);
	if (map)
		*a = (enum wprt__ComponentGroupBaseType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__ComponentGroupBaseType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__ComponentGroupBaseType * SOAP_FMAC4 soap_in_wprt__ComponentGroupBaseType(struct soap *soap, const char *tag, enum wprt__ComponentGroupBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__ComponentGroupBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ComponentGroupBaseType, sizeof(enum wprt__ComponentGroupBaseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__ComponentGroupBaseType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__ComponentGroupBaseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ComponentGroupBaseType, 0, sizeof(enum wprt__ComponentGroupBaseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConditionNameBaseType(struct soap *soap, enum wprt__ConditionNameBaseType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__ConditionNameBaseType
	*a = SOAP_DEFAULT_wprt__ConditionNameBaseType;
#else
	*a = (enum wprt__ConditionNameBaseType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConditionNameBaseType(struct soap *soap, const enum wprt__ConditionNameBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConditionNameBaseType);
	if (soap_out_wprt__ConditionNameBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__ConditionNameBaseType[] =
{	{ (long)wprt__ConditionNameBaseType__CoverOpen, "CoverOpen" },
	{ (long)wprt__ConditionNameBaseType__InterlockOpen, "InterlockOpen" },
	{ (long)wprt__ConditionNameBaseType__Jam, "Jam" },
	{ (long)wprt__ConditionNameBaseType__DoorOpen, "DoorOpen" },
	{ (long)wprt__ConditionNameBaseType__InputTrayMissing, "InputTrayMissing" },
	{ (long)wprt__ConditionNameBaseType__InputTrayMediaSizeChange, "InputTrayMediaSizeChange" },
	{ (long)wprt__ConditionNameBaseType__InputTrayMediaTypeChange, "InputTrayMediaTypeChange" },
	{ (long)wprt__ConditionNameBaseType__InputTraySupplyLow, "InputTraySupplyLow" },
	{ (long)wprt__ConditionNameBaseType__InputTraySupplyEmpty, "InputTraySupplyEmpty" },
	{ (long)wprt__ConditionNameBaseType__OutputTrayMissing, "OutputTrayMissing" },
	{ (long)wprt__ConditionNameBaseType__OutputTrayAlmostFull, "OutputTrayAlmostFull" },
	{ (long)wprt__ConditionNameBaseType__OutputTrayFull, "OutputTrayFull" },
	{ (long)wprt__ConditionNameBaseType__FuserUnderTemperature, "FuserUnderTemperature" },
	{ (long)wprt__ConditionNameBaseType__FuserOverTemperature, "FuserOverTemperature" },
	{ (long)wprt__ConditionNameBaseType__ConsumableLow, "ConsumableLow" },
	{ (long)wprt__ConditionNameBaseType__ConsumableEmpty, "ConsumableEmpty" },
	{ (long)wprt__ConditionNameBaseType__WasteReceptacleAlmostFull, "WasteReceptacleAlmostFull" },
	{ (long)wprt__ConditionNameBaseType__WasteReceptacleFull, "WasteReceptacleFull" },
	{ (long)wprt__ConditionNameBaseType__Unknown, "Unknown" },
	{ (long)wprt__ConditionNameBaseType__ManualDuplex, "ManualDuplex" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__ConditionNameBaseType2s(struct soap *soap, enum wprt__ConditionNameBaseType n)
{	const char *s = soap_code_str(soap_codes_wprt__ConditionNameBaseType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConditionNameBaseType(struct soap *soap, const char *tag, int id, const enum wprt__ConditionNameBaseType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ConditionNameBaseType), type);
	soap_send(soap, soap_wprt__ConditionNameBaseType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__ConditionNameBaseType * SOAP_FMAC4 soap_get_wprt__ConditionNameBaseType(struct soap *soap, enum wprt__ConditionNameBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConditionNameBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__ConditionNameBaseType(struct soap *soap, const char *s, enum wprt__ConditionNameBaseType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__ConditionNameBaseType, s);
	if (map)
		*a = (enum wprt__ConditionNameBaseType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 19)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__ConditionNameBaseType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__ConditionNameBaseType * SOAP_FMAC4 soap_in_wprt__ConditionNameBaseType(struct soap *soap, const char *tag, enum wprt__ConditionNameBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__ConditionNameBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConditionNameBaseType, sizeof(enum wprt__ConditionNameBaseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__ConditionNameBaseType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__ConditionNameBaseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ConditionNameBaseType, 0, sizeof(enum wprt__ConditionNameBaseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__HolePunchPatternWKVType(struct soap *soap, enum wprt__HolePunchPatternWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__HolePunchPatternWKVType
	*a = SOAP_DEFAULT_wprt__HolePunchPatternWKVType;
#else
	*a = (enum wprt__HolePunchPatternWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__HolePunchPatternWKVType(struct soap *soap, const enum wprt__HolePunchPatternWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__HolePunchPatternWKVType);
	if (soap_out_wprt__HolePunchPatternWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__HolePunchPatternWKVType[] =
{	{ (long)wprt__HolePunchPatternWKVType__unknown, "unknown" },
	{ (long)wprt__HolePunchPatternWKVType__NotApplicable, "NotApplicable" },
	{ (long)wprt__HolePunchPatternWKVType__TwoHoleUSTop, "TwoHoleUSTop" },
	{ (long)wprt__HolePunchPatternWKVType__ThreeHoleUS, "ThreeHoleUS" },
	{ (long)wprt__HolePunchPatternWKVType__TwoHoleDIN, "TwoHoleDIN" },
	{ (long)wprt__HolePunchPatternWKVType__FourHoleDIN, "FourHoleDIN" },
	{ (long)wprt__HolePunchPatternWKVType__TwentyTwoHoleUS, "TwentyTwoHoleUS" },
	{ (long)wprt__HolePunchPatternWKVType__NineteenHoleUS, "NineteenHoleUS" },
	{ (long)wprt__HolePunchPatternWKVType__TwoHoleMetric, "TwoHoleMetric" },
	{ (long)wprt__HolePunchPatternWKVType__Swedish4Hole, "Swedish4Hole" },
	{ (long)wprt__HolePunchPatternWKVType__TwoHoleUSSide, "TwoHoleUSSide" },
	{ (long)wprt__HolePunchPatternWKVType__FiveHoleUS, "FiveHoleUS" },
	{ (long)wprt__HolePunchPatternWKVType__SevenHoleUS, "SevenHoleUS" },
	{ (long)wprt__HolePunchPatternWKVType__Mixed7H4S, "Mixed7H4S" },
	{ (long)wprt__HolePunchPatternWKVType__Norweg6Hole, "Norweg6Hole" },
	{ (long)wprt__HolePunchPatternWKVType__Metric26Hole, "Metric26Hole" },
	{ (long)wprt__HolePunchPatternWKVType__Metric30Hole, "Metric30Hole" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__HolePunchPatternWKVType2s(struct soap *soap, enum wprt__HolePunchPatternWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__HolePunchPatternWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__HolePunchPatternWKVType(struct soap *soap, const char *tag, int id, const enum wprt__HolePunchPatternWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__HolePunchPatternWKVType), type);
	soap_send(soap, soap_wprt__HolePunchPatternWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__HolePunchPatternWKVType * SOAP_FMAC4 soap_get_wprt__HolePunchPatternWKVType(struct soap *soap, enum wprt__HolePunchPatternWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__HolePunchPatternWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__HolePunchPatternWKVType(struct soap *soap, const char *s, enum wprt__HolePunchPatternWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__HolePunchPatternWKVType, s);
	if (map)
		*a = (enum wprt__HolePunchPatternWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 16)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__HolePunchPatternWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__HolePunchPatternWKVType * SOAP_FMAC4 soap_in_wprt__HolePunchPatternWKVType(struct soap *soap, const char *tag, enum wprt__HolePunchPatternWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__HolePunchPatternWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__HolePunchPatternWKVType, sizeof(enum wprt__HolePunchPatternWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__HolePunchPatternWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__HolePunchPatternWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__HolePunchPatternWKVType, 0, sizeof(enum wprt__HolePunchPatternWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__HolePunchEdgeWKVType(struct soap *soap, enum wprt__HolePunchEdgeWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__HolePunchEdgeWKVType
	*a = SOAP_DEFAULT_wprt__HolePunchEdgeWKVType;
#else
	*a = (enum wprt__HolePunchEdgeWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__HolePunchEdgeWKVType(struct soap *soap, const enum wprt__HolePunchEdgeWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__HolePunchEdgeWKVType);
	if (soap_out_wprt__HolePunchEdgeWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__HolePunchEdgeWKVType[] =
{	{ (long)wprt__HolePunchEdgeWKVType__None, "None" },
	{ (long)wprt__HolePunchEdgeWKVType__Top, "Top" },
	{ (long)wprt__HolePunchEdgeWKVType__Bottom, "Bottom" },
	{ (long)wprt__HolePunchEdgeWKVType__Left, "Left" },
	{ (long)wprt__HolePunchEdgeWKVType__Right, "Right" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__HolePunchEdgeWKVType2s(struct soap *soap, enum wprt__HolePunchEdgeWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__HolePunchEdgeWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__HolePunchEdgeWKVType(struct soap *soap, const char *tag, int id, const enum wprt__HolePunchEdgeWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__HolePunchEdgeWKVType), type);
	soap_send(soap, soap_wprt__HolePunchEdgeWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__HolePunchEdgeWKVType * SOAP_FMAC4 soap_get_wprt__HolePunchEdgeWKVType(struct soap *soap, enum wprt__HolePunchEdgeWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__HolePunchEdgeWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__HolePunchEdgeWKVType(struct soap *soap, const char *s, enum wprt__HolePunchEdgeWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__HolePunchEdgeWKVType, s);
	if (map)
		*a = (enum wprt__HolePunchEdgeWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__HolePunchEdgeWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__HolePunchEdgeWKVType * SOAP_FMAC4 soap_in_wprt__HolePunchEdgeWKVType(struct soap *soap, const char *tag, enum wprt__HolePunchEdgeWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__HolePunchEdgeWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__HolePunchEdgeWKVType, sizeof(enum wprt__HolePunchEdgeWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__HolePunchEdgeWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__HolePunchEdgeWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__HolePunchEdgeWKVType, 0, sizeof(enum wprt__HolePunchEdgeWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StapleAngleWKVType(struct soap *soap, enum wprt__StapleAngleWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__StapleAngleWKVType
	*a = SOAP_DEFAULT_wprt__StapleAngleWKVType;
#else
	*a = (enum wprt__StapleAngleWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StapleAngleWKVType(struct soap *soap, const enum wprt__StapleAngleWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StapleAngleWKVType);
	if (soap_out_wprt__StapleAngleWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__StapleAngleWKVType[] =
{	{ (long)wprt__StapleAngleWKVType__unknown, "unknown" },
	{ (long)wprt__StapleAngleWKVType__NotApplicable, "NotApplicable" },
	{ (long)wprt__StapleAngleWKVType__Any, "Any" },
	{ (long)wprt__StapleAngleWKVType__Horizontal, "Horizontal" },
	{ (long)wprt__StapleAngleWKVType__Slanted, "Slanted" },
	{ (long)wprt__StapleAngleWKVType__Vertical, "Vertical" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__StapleAngleWKVType2s(struct soap *soap, enum wprt__StapleAngleWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__StapleAngleWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StapleAngleWKVType(struct soap *soap, const char *tag, int id, const enum wprt__StapleAngleWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__StapleAngleWKVType), type);
	soap_send(soap, soap_wprt__StapleAngleWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__StapleAngleWKVType * SOAP_FMAC4 soap_get_wprt__StapleAngleWKVType(struct soap *soap, enum wprt__StapleAngleWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StapleAngleWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__StapleAngleWKVType(struct soap *soap, const char *s, enum wprt__StapleAngleWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__StapleAngleWKVType, s);
	if (map)
		*a = (enum wprt__StapleAngleWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__StapleAngleWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__StapleAngleWKVType * SOAP_FMAC4 soap_in_wprt__StapleAngleWKVType(struct soap *soap, const char *tag, enum wprt__StapleAngleWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__StapleAngleWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StapleAngleWKVType, sizeof(enum wprt__StapleAngleWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__StapleAngleWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__StapleAngleWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__StapleAngleWKVType, 0, sizeof(enum wprt__StapleAngleWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StapleLocationWKVType(struct soap *soap, enum wprt__StapleLocationWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__StapleLocationWKVType
	*a = SOAP_DEFAULT_wprt__StapleLocationWKVType;
#else
	*a = (enum wprt__StapleLocationWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StapleLocationWKVType(struct soap *soap, const enum wprt__StapleLocationWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StapleLocationWKVType);
	if (soap_out_wprt__StapleLocationWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__StapleLocationWKVType[] =
{	{ (long)wprt__StapleLocationWKVType__None, "None" },
	{ (long)wprt__StapleLocationWKVType__StapleBottomLeft, "StapleBottomLeft" },
	{ (long)wprt__StapleLocationWKVType__StapleBottomRight, "StapleBottomRight" },
	{ (long)wprt__StapleLocationWKVType__StapleTopLeft, "StapleTopLeft" },
	{ (long)wprt__StapleLocationWKVType__StapleTopRight, "StapleTopRight" },
	{ (long)wprt__StapleLocationWKVType__StapleDualBottom, "StapleDualBottom" },
	{ (long)wprt__StapleLocationWKVType__StapleDualLeft, "StapleDualLeft" },
	{ (long)wprt__StapleLocationWKVType__StapleDualRight, "StapleDualRight" },
	{ (long)wprt__StapleLocationWKVType__StapleDualTop, "StapleDualTop" },
	{ (long)wprt__StapleLocationWKVType__SaddleStitch, "SaddleStitch" },
	{ (long)wprt__StapleLocationWKVType__other, "other" },
	{ (long)wprt__StapleLocationWKVType__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__StapleLocationWKVType2s(struct soap *soap, enum wprt__StapleLocationWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__StapleLocationWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StapleLocationWKVType(struct soap *soap, const char *tag, int id, const enum wprt__StapleLocationWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__StapleLocationWKVType), type);
	soap_send(soap, soap_wprt__StapleLocationWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__StapleLocationWKVType * SOAP_FMAC4 soap_get_wprt__StapleLocationWKVType(struct soap *soap, enum wprt__StapleLocationWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StapleLocationWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__StapleLocationWKVType(struct soap *soap, const char *s, enum wprt__StapleLocationWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__StapleLocationWKVType, s);
	if (map)
		*a = (enum wprt__StapleLocationWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__StapleLocationWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__StapleLocationWKVType * SOAP_FMAC4 soap_in_wprt__StapleLocationWKVType(struct soap *soap, const char *tag, enum wprt__StapleLocationWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__StapleLocationWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StapleLocationWKVType, sizeof(enum wprt__StapleLocationWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__StapleLocationWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__StapleLocationWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__StapleLocationWKVType, 0, sizeof(enum wprt__StapleLocationWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__NUpDirectionRestrictionType(struct soap *soap, enum wprt__NUpDirectionRestrictionType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__NUpDirectionRestrictionType
	*a = SOAP_DEFAULT_wprt__NUpDirectionRestrictionType;
#else
	*a = (enum wprt__NUpDirectionRestrictionType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__NUpDirectionRestrictionType(struct soap *soap, const enum wprt__NUpDirectionRestrictionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__NUpDirectionRestrictionType);
	if (soap_out_wprt__NUpDirectionRestrictionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__NUpDirectionRestrictionType[] =
{	{ (long)wprt__NUpDirectionRestrictionType__RightDown, "RightDown" },
	{ (long)wprt__NUpDirectionRestrictionType__DownRight, "DownRight" },
	{ (long)wprt__NUpDirectionRestrictionType__LeftDown, "LeftDown" },
	{ (long)wprt__NUpDirectionRestrictionType__DownLeft, "DownLeft" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__NUpDirectionRestrictionType2s(struct soap *soap, enum wprt__NUpDirectionRestrictionType n)
{	const char *s = soap_code_str(soap_codes_wprt__NUpDirectionRestrictionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__NUpDirectionRestrictionType(struct soap *soap, const char *tag, int id, const enum wprt__NUpDirectionRestrictionType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__NUpDirectionRestrictionType), type);
	soap_send(soap, soap_wprt__NUpDirectionRestrictionType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__NUpDirectionRestrictionType * SOAP_FMAC4 soap_get_wprt__NUpDirectionRestrictionType(struct soap *soap, enum wprt__NUpDirectionRestrictionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__NUpDirectionRestrictionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__NUpDirectionRestrictionType(struct soap *soap, const char *s, enum wprt__NUpDirectionRestrictionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__NUpDirectionRestrictionType, s);
	if (map)
		*a = (enum wprt__NUpDirectionRestrictionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__NUpDirectionRestrictionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__NUpDirectionRestrictionType * SOAP_FMAC4 soap_in_wprt__NUpDirectionRestrictionType(struct soap *soap, const char *tag, enum wprt__NUpDirectionRestrictionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__NUpDirectionRestrictionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__NUpDirectionRestrictionType, sizeof(enum wprt__NUpDirectionRestrictionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__NUpDirectionRestrictionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__NUpDirectionRestrictionType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__NUpDirectionRestrictionType, 0, sizeof(enum wprt__NUpDirectionRestrictionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaColorWKVType(struct soap *soap, enum wprt__MediaColorWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__MediaColorWKVType
	*a = SOAP_DEFAULT_wprt__MediaColorWKVType;
#else
	*a = (enum wprt__MediaColorWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaColorWKVType(struct soap *soap, const enum wprt__MediaColorWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaColorWKVType);
	if (soap_out_wprt__MediaColorWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__MediaColorWKVType[] =
{	{ (long)wprt__MediaColorWKVType__unknown, "unknown" },
	{ (long)wprt__MediaColorWKVType__white, "white" },
	{ (long)wprt__MediaColorWKVType__pink, "pink" },
	{ (long)wprt__MediaColorWKVType__yellow, "yellow" },
	{ (long)wprt__MediaColorWKVType__buff, "buff" },
	{ (long)wprt__MediaColorWKVType__goldenrod, "goldenrod" },
	{ (long)wprt__MediaColorWKVType__blue, "blue" },
	{ (long)wprt__MediaColorWKVType__green, "green" },
	{ (long)wprt__MediaColorWKVType__red, "red" },
	{ (long)wprt__MediaColorWKVType__gray, "gray" },
	{ (long)wprt__MediaColorWKVType__ivory, "ivory" },
	{ (long)wprt__MediaColorWKVType__orange, "orange" },
	{ (long)wprt__MediaColorWKVType__other, "other" },
	{ (long)wprt__MediaColorWKVType__no_color, "no-color" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__MediaColorWKVType2s(struct soap *soap, enum wprt__MediaColorWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__MediaColorWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaColorWKVType(struct soap *soap, const char *tag, int id, const enum wprt__MediaColorWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__MediaColorWKVType), type);
	soap_send(soap, soap_wprt__MediaColorWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__MediaColorWKVType * SOAP_FMAC4 soap_get_wprt__MediaColorWKVType(struct soap *soap, enum wprt__MediaColorWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaColorWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__MediaColorWKVType(struct soap *soap, const char *s, enum wprt__MediaColorWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__MediaColorWKVType, s);
	if (map)
		*a = (enum wprt__MediaColorWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 13)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__MediaColorWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__MediaColorWKVType * SOAP_FMAC4 soap_in_wprt__MediaColorWKVType(struct soap *soap, const char *tag, enum wprt__MediaColorWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__MediaColorWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__MediaColorWKVType, sizeof(enum wprt__MediaColorWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__MediaColorWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__MediaColorWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__MediaColorWKVType, 0, sizeof(enum wprt__MediaColorWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaTypeWKVType(struct soap *soap, enum wprt__MediaTypeWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__MediaTypeWKVType
	*a = SOAP_DEFAULT_wprt__MediaTypeWKVType;
#else
	*a = (enum wprt__MediaTypeWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaTypeWKVType(struct soap *soap, const enum wprt__MediaTypeWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaTypeWKVType);
	if (soap_out_wprt__MediaTypeWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__MediaTypeWKVType[] =
{	{ (long)wprt__MediaTypeWKVType__cardstock, "cardstock" },
	{ (long)wprt__MediaTypeWKVType__envelope, "envelope" },
	{ (long)wprt__MediaTypeWKVType__labels, "labels" },
	{ (long)wprt__MediaTypeWKVType__photographic, "photographic" },
	{ (long)wprt__MediaTypeWKVType__photographic_glossy, "photographic-glossy" },
	{ (long)wprt__MediaTypeWKVType__photographic_matte, "photographic-matte" },
	{ (long)wprt__MediaTypeWKVType__stationery, "stationery" },
	{ (long)wprt__MediaTypeWKVType__stationery_inkjet, "stationery-inkjet" },
	{ (long)wprt__MediaTypeWKVType__transparency, "transparency" },
	{ (long)wprt__MediaTypeWKVType__other, "other" },
	{ (long)wprt__MediaTypeWKVType__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__MediaTypeWKVType2s(struct soap *soap, enum wprt__MediaTypeWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__MediaTypeWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaTypeWKVType(struct soap *soap, const char *tag, int id, const enum wprt__MediaTypeWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__MediaTypeWKVType), type);
	soap_send(soap, soap_wprt__MediaTypeWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__MediaTypeWKVType * SOAP_FMAC4 soap_get_wprt__MediaTypeWKVType(struct soap *soap, enum wprt__MediaTypeWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaTypeWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__MediaTypeWKVType(struct soap *soap, const char *s, enum wprt__MediaTypeWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__MediaTypeWKVType, s);
	if (map)
		*a = (enum wprt__MediaTypeWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__MediaTypeWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__MediaTypeWKVType * SOAP_FMAC4 soap_in_wprt__MediaTypeWKVType(struct soap *soap, const char *tag, enum wprt__MediaTypeWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__MediaTypeWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__MediaTypeWKVType, sizeof(enum wprt__MediaTypeWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__MediaTypeWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__MediaTypeWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__MediaTypeWKVType, 0, sizeof(enum wprt__MediaTypeWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaSizeSelfDescribingNameWKVType(struct soap *soap, enum wprt__MediaSizeSelfDescribingNameWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__MediaSizeSelfDescribingNameWKVType
	*a = SOAP_DEFAULT_wprt__MediaSizeSelfDescribingNameWKVType;
#else
	*a = (enum wprt__MediaSizeSelfDescribingNameWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaSizeSelfDescribingNameWKVType(struct soap *soap, const enum wprt__MediaSizeSelfDescribingNameWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaSizeSelfDescribingNameWKVType);
	if (soap_out_wprt__MediaSizeSelfDescribingNameWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__MediaSizeSelfDescribingNameWKVType[] =
{	{ (long)wprt__MediaSizeSelfDescribingNameWKVType__iso_USCOREa4_USCORE210x297mm, "iso_a4_210x297mm" },
	{ (long)wprt__MediaSizeSelfDescribingNameWKVType__iso_USCOREc5_USCORE162x229mm, "iso_c5_162x229mm" },
	{ (long)wprt__MediaSizeSelfDescribingNameWKVType__iso_USCOREdl_USCORE110x220mm, "iso_dl_110x220mm" },
	{ (long)wprt__MediaSizeSelfDescribingNameWKVType__jis_USCOREb4_USCORE257x364mm, "jis_b4_257x364mm" },
	{ (long)wprt__MediaSizeSelfDescribingNameWKVType__na_USCORElegal_USCORE8_x002e5x14in, "na_legal_8.5x14in" },
	{ (long)wprt__MediaSizeSelfDescribingNameWKVType__na_USCOREletter_USCORE8_x002e5x11in, "na_letter_8.5x11in" },
	{ (long)wprt__MediaSizeSelfDescribingNameWKVType__pwg_USCOREletter_or_a4_USCOREchoice, "pwg_letter-or-a4_choice" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__MediaSizeSelfDescribingNameWKVType2s(struct soap *soap, enum wprt__MediaSizeSelfDescribingNameWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__MediaSizeSelfDescribingNameWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaSizeSelfDescribingNameWKVType(struct soap *soap, const char *tag, int id, const enum wprt__MediaSizeSelfDescribingNameWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__MediaSizeSelfDescribingNameWKVType), type);
	soap_send(soap, soap_wprt__MediaSizeSelfDescribingNameWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__MediaSizeSelfDescribingNameWKVType * SOAP_FMAC4 soap_get_wprt__MediaSizeSelfDescribingNameWKVType(struct soap *soap, enum wprt__MediaSizeSelfDescribingNameWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaSizeSelfDescribingNameWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__MediaSizeSelfDescribingNameWKVType(struct soap *soap, const char *s, enum wprt__MediaSizeSelfDescribingNameWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__MediaSizeSelfDescribingNameWKVType, s);
	if (map)
		*a = (enum wprt__MediaSizeSelfDescribingNameWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__MediaSizeSelfDescribingNameWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__MediaSizeSelfDescribingNameWKVType * SOAP_FMAC4 soap_in_wprt__MediaSizeSelfDescribingNameWKVType(struct soap *soap, const char *tag, enum wprt__MediaSizeSelfDescribingNameWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__MediaSizeSelfDescribingNameWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__MediaSizeSelfDescribingNameWKVType, sizeof(enum wprt__MediaSizeSelfDescribingNameWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__MediaSizeSelfDescribingNameWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__MediaSizeSelfDescribingNameWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__MediaSizeSelfDescribingNameWKVType, 0, sizeof(enum wprt__MediaSizeSelfDescribingNameWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__SidesWKVType(struct soap *soap, enum wprt__SidesWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__SidesWKVType
	*a = SOAP_DEFAULT_wprt__SidesWKVType;
#else
	*a = (enum wprt__SidesWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__SidesWKVType(struct soap *soap, const enum wprt__SidesWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__SidesWKVType);
	if (soap_out_wprt__SidesWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__SidesWKVType[] =
{	{ (long)wprt__SidesWKVType__OneSided, "OneSided" },
	{ (long)wprt__SidesWKVType__TwoSidedLongEdge, "TwoSidedLongEdge" },
	{ (long)wprt__SidesWKVType__TwoSidedShortEdge, "TwoSidedShortEdge" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__SidesWKVType2s(struct soap *soap, enum wprt__SidesWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__SidesWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__SidesWKVType(struct soap *soap, const char *tag, int id, const enum wprt__SidesWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__SidesWKVType), type);
	soap_send(soap, soap_wprt__SidesWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__SidesWKVType * SOAP_FMAC4 soap_get_wprt__SidesWKVType(struct soap *soap, enum wprt__SidesWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__SidesWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__SidesWKVType(struct soap *soap, const char *s, enum wprt__SidesWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__SidesWKVType, s);
	if (map)
		*a = (enum wprt__SidesWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__SidesWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__SidesWKVType * SOAP_FMAC4 soap_in_wprt__SidesWKVType(struct soap *soap, const char *tag, enum wprt__SidesWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__SidesWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__SidesWKVType, sizeof(enum wprt__SidesWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__SidesWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__SidesWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__SidesWKVType, 0, sizeof(enum wprt__SidesWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStateReasonsWKVType(struct soap *soap, enum wprt__PrinterStateReasonsWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__PrinterStateReasonsWKVType
	*a = SOAP_DEFAULT_wprt__PrinterStateReasonsWKVType;
#else
	*a = (enum wprt__PrinterStateReasonsWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStateReasonsWKVType(struct soap *soap, const enum wprt__PrinterStateReasonsWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStateReasonsWKVType);
	if (soap_out_wprt__PrinterStateReasonsWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__PrinterStateReasonsWKVType[] =
{	{ (long)wprt__PrinterStateReasonsWKVType__AttentionRequired, "AttentionRequired" },
	{ (long)wprt__PrinterStateReasonsWKVType__DoorOpen, "DoorOpen" },
	{ (long)wprt__PrinterStateReasonsWKVType__MarkerSupplyEmpty, "MarkerSupplyEmpty" },
	{ (long)wprt__PrinterStateReasonsWKVType__MarkerSupplyLow, "MarkerSupplyLow" },
	{ (long)wprt__PrinterStateReasonsWKVType__MediaEmpty, "MediaEmpty" },
	{ (long)wprt__PrinterStateReasonsWKVType__MediaJam, "MediaJam" },
	{ (long)wprt__PrinterStateReasonsWKVType__MediaLow, "MediaLow" },
	{ (long)wprt__PrinterStateReasonsWKVType__MediaNeeded, "MediaNeeded" },
	{ (long)wprt__PrinterStateReasonsWKVType__None, "None" },
	{ (long)wprt__PrinterStateReasonsWKVType__Paused, "Paused" },
	{ (long)wprt__PrinterStateReasonsWKVType__OutputAreaAlmostFull, "OutputAreaAlmostFull" },
	{ (long)wprt__PrinterStateReasonsWKVType__OutputAreaFull, "OutputAreaFull" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__PrinterStateReasonsWKVType2s(struct soap *soap, enum wprt__PrinterStateReasonsWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__PrinterStateReasonsWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStateReasonsWKVType(struct soap *soap, const char *tag, int id, const enum wprt__PrinterStateReasonsWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterStateReasonsWKVType), type);
	soap_send(soap, soap_wprt__PrinterStateReasonsWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__PrinterStateReasonsWKVType * SOAP_FMAC4 soap_get_wprt__PrinterStateReasonsWKVType(struct soap *soap, enum wprt__PrinterStateReasonsWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStateReasonsWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__PrinterStateReasonsWKVType(struct soap *soap, const char *s, enum wprt__PrinterStateReasonsWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__PrinterStateReasonsWKVType, s);
	if (map)
		*a = (enum wprt__PrinterStateReasonsWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__PrinterStateReasonsWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__PrinterStateReasonsWKVType * SOAP_FMAC4 soap_in_wprt__PrinterStateReasonsWKVType(struct soap *soap, const char *tag, enum wprt__PrinterStateReasonsWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__PrinterStateReasonsWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterStateReasonsWKVType, sizeof(enum wprt__PrinterStateReasonsWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__PrinterStateReasonsWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__PrinterStateReasonsWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterStateReasonsWKVType, 0, sizeof(enum wprt__PrinterStateReasonsWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStateWKVType(struct soap *soap, enum wprt__PrinterStateWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__PrinterStateWKVType
	*a = SOAP_DEFAULT_wprt__PrinterStateWKVType;
#else
	*a = (enum wprt__PrinterStateWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStateWKVType(struct soap *soap, const enum wprt__PrinterStateWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStateWKVType);
	if (soap_out_wprt__PrinterStateWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__PrinterStateWKVType[] =
{	{ (long)wprt__PrinterStateWKVType__Idle, "Idle" },
	{ (long)wprt__PrinterStateWKVType__Processing, "Processing" },
	{ (long)wprt__PrinterStateWKVType__Stopped, "Stopped" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__PrinterStateWKVType2s(struct soap *soap, enum wprt__PrinterStateWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__PrinterStateWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStateWKVType(struct soap *soap, const char *tag, int id, const enum wprt__PrinterStateWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterStateWKVType), type);
	soap_send(soap, soap_wprt__PrinterStateWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__PrinterStateWKVType * SOAP_FMAC4 soap_get_wprt__PrinterStateWKVType(struct soap *soap, enum wprt__PrinterStateWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStateWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__PrinterStateWKVType(struct soap *soap, const char *s, enum wprt__PrinterStateWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__PrinterStateWKVType, s);
	if (map)
		*a = (enum wprt__PrinterStateWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__PrinterStateWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__PrinterStateWKVType * SOAP_FMAC4 soap_in_wprt__PrinterStateWKVType(struct soap *soap, const char *tag, enum wprt__PrinterStateWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__PrinterStateWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterStateWKVType, sizeof(enum wprt__PrinterStateWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__PrinterStateWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__PrinterStateWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterStateWKVType, 0, sizeof(enum wprt__PrinterStateWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrintQualityWKVType(struct soap *soap, enum wprt__PrintQualityWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__PrintQualityWKVType
	*a = SOAP_DEFAULT_wprt__PrintQualityWKVType;
#else
	*a = (enum wprt__PrintQualityWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrintQualityWKVType(struct soap *soap, const enum wprt__PrintQualityWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrintQualityWKVType);
	if (soap_out_wprt__PrintQualityWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__PrintQualityWKVType[] =
{	{ (long)wprt__PrintQualityWKVType__Draft, "Draft" },
	{ (long)wprt__PrintQualityWKVType__High, "High" },
	{ (long)wprt__PrintQualityWKVType__Normal, "Normal" },
	{ (long)wprt__PrintQualityWKVType__Photo, "Photo" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__PrintQualityWKVType2s(struct soap *soap, enum wprt__PrintQualityWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__PrintQualityWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrintQualityWKVType(struct soap *soap, const char *tag, int id, const enum wprt__PrintQualityWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrintQualityWKVType), type);
	soap_send(soap, soap_wprt__PrintQualityWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__PrintQualityWKVType * SOAP_FMAC4 soap_get_wprt__PrintQualityWKVType(struct soap *soap, enum wprt__PrintQualityWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrintQualityWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__PrintQualityWKVType(struct soap *soap, const char *s, enum wprt__PrintQualityWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__PrintQualityWKVType, s);
	if (map)
		*a = (enum wprt__PrintQualityWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__PrintQualityWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__PrintQualityWKVType * SOAP_FMAC4 soap_in_wprt__PrintQualityWKVType(struct soap *soap, const char *tag, enum wprt__PrintQualityWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__PrintQualityWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrintQualityWKVType, sizeof(enum wprt__PrintQualityWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__PrintQualityWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__PrintQualityWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrintQualityWKVType, 0, sizeof(enum wprt__PrintQualityWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__OutputBinWKVType(struct soap *soap, enum wprt__OutputBinWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__OutputBinWKVType
	*a = SOAP_DEFAULT_wprt__OutputBinWKVType;
#else
	*a = (enum wprt__OutputBinWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__OutputBinWKVType(struct soap *soap, const enum wprt__OutputBinWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__OutputBinWKVType);
	if (soap_out_wprt__OutputBinWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__OutputBinWKVType[] =
{	{ (long)wprt__OutputBinWKVType__Bottom, "Bottom" },
	{ (long)wprt__OutputBinWKVType__Center, "Center" },
	{ (long)wprt__OutputBinWKVType__Face_down, "Face-down" },
	{ (long)wprt__OutputBinWKVType__Face_up, "Face-up" },
	{ (long)wprt__OutputBinWKVType__Finisher, "Finisher" },
	{ (long)wprt__OutputBinWKVType__Large_capacity, "Large-capacity" },
	{ (long)wprt__OutputBinWKVType__Left, "Left" },
	{ (long)wprt__OutputBinWKVType__Middle, "Middle" },
	{ (long)wprt__OutputBinWKVType__My_mailbox, "My-mailbox" },
	{ (long)wprt__OutputBinWKVType__Rear, "Rear" },
	{ (long)wprt__OutputBinWKVType__Right, "Right" },
	{ (long)wprt__OutputBinWKVType__Side, "Side" },
	{ (long)wprt__OutputBinWKVType__Top, "Top" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__OutputBinWKVType2s(struct soap *soap, enum wprt__OutputBinWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__OutputBinWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__OutputBinWKVType(struct soap *soap, const char *tag, int id, const enum wprt__OutputBinWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__OutputBinWKVType), type);
	soap_send(soap, soap_wprt__OutputBinWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__OutputBinWKVType * SOAP_FMAC4 soap_get_wprt__OutputBinWKVType(struct soap *soap, enum wprt__OutputBinWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__OutputBinWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__OutputBinWKVType(struct soap *soap, const char *s, enum wprt__OutputBinWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__OutputBinWKVType, s);
	if (map)
		*a = (enum wprt__OutputBinWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 12)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__OutputBinWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__OutputBinWKVType * SOAP_FMAC4 soap_in_wprt__OutputBinWKVType(struct soap *soap, const char *tag, enum wprt__OutputBinWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__OutputBinWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__OutputBinWKVType, sizeof(enum wprt__OutputBinWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__OutputBinWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__OutputBinWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__OutputBinWKVType, 0, sizeof(enum wprt__OutputBinWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__OrientationWKVType(struct soap *soap, enum wprt__OrientationWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__OrientationWKVType
	*a = SOAP_DEFAULT_wprt__OrientationWKVType;
#else
	*a = (enum wprt__OrientationWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__OrientationWKVType(struct soap *soap, const enum wprt__OrientationWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__OrientationWKVType);
	if (soap_out_wprt__OrientationWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__OrientationWKVType[] =
{	{ (long)wprt__OrientationWKVType__Landscape, "Landscape" },
	{ (long)wprt__OrientationWKVType__Portrait, "Portrait" },
	{ (long)wprt__OrientationWKVType__ReverseLandscape, "ReverseLandscape" },
	{ (long)wprt__OrientationWKVType__ReversePortrait, "ReversePortrait" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__OrientationWKVType2s(struct soap *soap, enum wprt__OrientationWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__OrientationWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__OrientationWKVType(struct soap *soap, const char *tag, int id, const enum wprt__OrientationWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__OrientationWKVType), type);
	soap_send(soap, soap_wprt__OrientationWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__OrientationWKVType * SOAP_FMAC4 soap_get_wprt__OrientationWKVType(struct soap *soap, enum wprt__OrientationWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__OrientationWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__OrientationWKVType(struct soap *soap, const char *s, enum wprt__OrientationWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__OrientationWKVType, s);
	if (map)
		*a = (enum wprt__OrientationWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__OrientationWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__OrientationWKVType * SOAP_FMAC4 soap_in_wprt__OrientationWKVType(struct soap *soap, const char *tag, enum wprt__OrientationWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__OrientationWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__OrientationWKVType, sizeof(enum wprt__OrientationWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__OrientationWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__OrientationWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__OrientationWKVType, 0, sizeof(enum wprt__OrientationWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobStateReasonsWKVType(struct soap *soap, enum wprt__JobStateReasonsWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__JobStateReasonsWKVType
	*a = SOAP_DEFAULT_wprt__JobStateReasonsWKVType;
#else
	*a = (enum wprt__JobStateReasonsWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobStateReasonsWKVType(struct soap *soap, const enum wprt__JobStateReasonsWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobStateReasonsWKVType);
	if (soap_out_wprt__JobStateReasonsWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__JobStateReasonsWKVType[] =
{	{ (long)wprt__JobStateReasonsWKVType__CompressionError, "CompressionError" },
	{ (long)wprt__JobStateReasonsWKVType__DocumentAccessError, "DocumentAccessError" },
	{ (long)wprt__JobStateReasonsWKVType__DocumentFormatError, "DocumentFormatError" },
	{ (long)wprt__JobStateReasonsWKVType__DocumentTimeoutError, "DocumentTimeoutError" },
	{ (long)wprt__JobStateReasonsWKVType__DocumentTransferError, "DocumentTransferError" },
	{ (long)wprt__JobStateReasonsWKVType__JobCanceledAtDevice, "JobCanceledAtDevice" },
	{ (long)wprt__JobStateReasonsWKVType__JobCanceledByUser, "JobCanceledByUser" },
	{ (long)wprt__JobStateReasonsWKVType__JobCompletedSuccessfully, "JobCompletedSuccessfully" },
	{ (long)wprt__JobStateReasonsWKVType__JobCompletedWithErrors, "JobCompletedWithErrors" },
	{ (long)wprt__JobStateReasonsWKVType__JobCompletedWithWarnings, "JobCompletedWithWarnings" },
	{ (long)wprt__JobStateReasonsWKVType__JobIncoming, "JobIncoming" },
	{ (long)wprt__JobStateReasonsWKVType__JobPasswordWait, "JobPasswordWait" },
	{ (long)wprt__JobStateReasonsWKVType__JobPrinting, "JobPrinting" },
	{ (long)wprt__JobStateReasonsWKVType__None, "None" },
	{ (long)wprt__JobStateReasonsWKVType__PrinterStopped, "PrinterStopped" },
	{ (long)wprt__JobStateReasonsWKVType__UnsupportedCompression, "UnsupportedCompression" },
	{ (long)wprt__JobStateReasonsWKVType__UnsupportedDocumentFormat, "UnsupportedDocumentFormat" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__JobStateReasonsWKVType2s(struct soap *soap, enum wprt__JobStateReasonsWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__JobStateReasonsWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobStateReasonsWKVType(struct soap *soap, const char *tag, int id, const enum wprt__JobStateReasonsWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobStateReasonsWKVType), type);
	soap_send(soap, soap_wprt__JobStateReasonsWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__JobStateReasonsWKVType * SOAP_FMAC4 soap_get_wprt__JobStateReasonsWKVType(struct soap *soap, enum wprt__JobStateReasonsWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobStateReasonsWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__JobStateReasonsWKVType(struct soap *soap, const char *s, enum wprt__JobStateReasonsWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__JobStateReasonsWKVType, s);
	if (map)
		*a = (enum wprt__JobStateReasonsWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 16)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__JobStateReasonsWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__JobStateReasonsWKVType * SOAP_FMAC4 soap_in_wprt__JobStateReasonsWKVType(struct soap *soap, const char *tag, enum wprt__JobStateReasonsWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__JobStateReasonsWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobStateReasonsWKVType, sizeof(enum wprt__JobStateReasonsWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__JobStateReasonsWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__JobStateReasonsWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobStateReasonsWKVType, 0, sizeof(enum wprt__JobStateReasonsWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobStateWKVType(struct soap *soap, enum wprt__JobStateWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__JobStateWKVType
	*a = SOAP_DEFAULT_wprt__JobStateWKVType;
#else
	*a = (enum wprt__JobStateWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobStateWKVType(struct soap *soap, const enum wprt__JobStateWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobStateWKVType);
	if (soap_out_wprt__JobStateWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__JobStateWKVType[] =
{	{ (long)wprt__JobStateWKVType__Aborted, "Aborted" },
	{ (long)wprt__JobStateWKVType__Canceled, "Canceled" },
	{ (long)wprt__JobStateWKVType__Completed, "Completed" },
	{ (long)wprt__JobStateWKVType__Pending, "Pending" },
	{ (long)wprt__JobStateWKVType__Pending_Held, "Pending-Held" },
	{ (long)wprt__JobStateWKVType__Processing, "Processing" },
	{ (long)wprt__JobStateWKVType__ProcessingStopped, "ProcessingStopped" },
	{ (long)wprt__JobStateWKVType__Started, "Started" },
	{ (long)wprt__JobStateWKVType__Terminating, "Terminating" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__JobStateWKVType2s(struct soap *soap, enum wprt__JobStateWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__JobStateWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobStateWKVType(struct soap *soap, const char *tag, int id, const enum wprt__JobStateWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobStateWKVType), type);
	soap_send(soap, soap_wprt__JobStateWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__JobStateWKVType * SOAP_FMAC4 soap_get_wprt__JobStateWKVType(struct soap *soap, enum wprt__JobStateWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobStateWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__JobStateWKVType(struct soap *soap, const char *s, enum wprt__JobStateWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__JobStateWKVType, s);
	if (map)
		*a = (enum wprt__JobStateWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__JobStateWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__JobStateWKVType * SOAP_FMAC4 soap_in_wprt__JobStateWKVType(struct soap *soap, const char *tag, enum wprt__JobStateWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__JobStateWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobStateWKVType, sizeof(enum wprt__JobStateWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__JobStateWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__JobStateWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobStateWKVType, 0, sizeof(enum wprt__JobStateWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinWKVType(struct soap *soap, enum wprt__InputBinWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__InputBinWKVType
	*a = SOAP_DEFAULT_wprt__InputBinWKVType;
#else
	*a = (enum wprt__InputBinWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinWKVType(struct soap *soap, const enum wprt__InputBinWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinWKVType);
	if (soap_out_wprt__InputBinWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__InputBinWKVType[] =
{	{ (long)wprt__InputBinWKVType__Bottom, "Bottom" },
	{ (long)wprt__InputBinWKVType__Bypass, "Bypass" },
	{ (long)wprt__InputBinWKVType__Envelope, "Envelope" },
	{ (long)wprt__InputBinWKVType__EnvelopeManual, "EnvelopeManual" },
	{ (long)wprt__InputBinWKVType__LargeCapacity, "LargeCapacity" },
	{ (long)wprt__InputBinWKVType__Manual, "Manual" },
	{ (long)wprt__InputBinWKVType__Middle, "Middle" },
	{ (long)wprt__InputBinWKVType__Multipurpose, "Multipurpose" },
	{ (long)wprt__InputBinWKVType__Top, "Top" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__InputBinWKVType2s(struct soap *soap, enum wprt__InputBinWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__InputBinWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinWKVType(struct soap *soap, const char *tag, int id, const enum wprt__InputBinWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__InputBinWKVType), type);
	soap_send(soap, soap_wprt__InputBinWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__InputBinWKVType * SOAP_FMAC4 soap_get_wprt__InputBinWKVType(struct soap *soap, enum wprt__InputBinWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__InputBinWKVType(struct soap *soap, const char *s, enum wprt__InputBinWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__InputBinWKVType, s);
	if (map)
		*a = (enum wprt__InputBinWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__InputBinWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__InputBinWKVType * SOAP_FMAC4 soap_in_wprt__InputBinWKVType(struct soap *soap, const char *tag, enum wprt__InputBinWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__InputBinWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__InputBinWKVType, sizeof(enum wprt__InputBinWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__InputBinWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__InputBinWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__InputBinWKVType, 0, sizeof(enum wprt__InputBinWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DocumentFormatWKVType(struct soap *soap, enum wprt__DocumentFormatWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__DocumentFormatWKVType
	*a = SOAP_DEFAULT_wprt__DocumentFormatWKVType;
#else
	*a = (enum wprt__DocumentFormatWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DocumentFormatWKVType(struct soap *soap, const enum wprt__DocumentFormatWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DocumentFormatWKVType);
	if (soap_out_wprt__DocumentFormatWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__DocumentFormatWKVType[] =
{	{ (long)wprt__DocumentFormatWKVType__application_x002foctet_stream, "application/octet-stream" },
	{ (long)wprt__DocumentFormatWKVType__application_x002fpostscript, "application/postscript" },
	{ (long)wprt__DocumentFormatWKVType__application_x002fvnd_x002ehp_PCL, "application/vnd.hp-PCL" },
	{ (long)wprt__DocumentFormatWKVType__application_x002fvnd_x002ems_xpsdocument, "application/vnd.ms-xpsdocument" },
	{ (long)wprt__DocumentFormatWKVType__application_x002fvnd_x002epwg_xhtml_print_x002bxml, "application/vnd.pwg-xhtml-print+xml" },
	{ (long)wprt__DocumentFormatWKVType__image_x002fg3fax, "image/g3fax" },
	{ (long)wprt__DocumentFormatWKVType__image_x002fgif, "image/gif" },
	{ (long)wprt__DocumentFormatWKVType__image_x002fjpeg, "image/jpeg" },
	{ (long)wprt__DocumentFormatWKVType__image_x002fpng, "image/png" },
	{ (long)wprt__DocumentFormatWKVType__image_x002ftiff, "image/tiff" },
	{ (long)wprt__DocumentFormatWKVType__image_x002ftiff_fx, "image/tiff-fx" },
	{ (long)wprt__DocumentFormatWKVType__text_x002fhtml, "text/html" },
	{ (long)wprt__DocumentFormatWKVType__text_x002fplain, "text/plain" },
	{ (long)wprt__DocumentFormatWKVType__text_x002fplain_x003bcharset_x003dutf_8, "text/plain;charset=utf-8" },
	{ (long)wprt__DocumentFormatWKVType__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__DocumentFormatWKVType2s(struct soap *soap, enum wprt__DocumentFormatWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__DocumentFormatWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DocumentFormatWKVType(struct soap *soap, const char *tag, int id, const enum wprt__DocumentFormatWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__DocumentFormatWKVType), type);
	soap_send(soap, soap_wprt__DocumentFormatWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__DocumentFormatWKVType * SOAP_FMAC4 soap_get_wprt__DocumentFormatWKVType(struct soap *soap, enum wprt__DocumentFormatWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DocumentFormatWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__DocumentFormatWKVType(struct soap *soap, const char *s, enum wprt__DocumentFormatWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__DocumentFormatWKVType, s);
	if (map)
		*a = (enum wprt__DocumentFormatWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 14)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__DocumentFormatWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__DocumentFormatWKVType * SOAP_FMAC4 soap_in_wprt__DocumentFormatWKVType(struct soap *soap, const char *tag, enum wprt__DocumentFormatWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__DocumentFormatWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DocumentFormatWKVType, sizeof(enum wprt__DocumentFormatWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__DocumentFormatWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__DocumentFormatWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__DocumentFormatWKVType, 0, sizeof(enum wprt__DocumentFormatWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__CompressionWKVType(struct soap *soap, enum wprt__CompressionWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__CompressionWKVType
	*a = SOAP_DEFAULT_wprt__CompressionWKVType;
#else
	*a = (enum wprt__CompressionWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__CompressionWKVType(struct soap *soap, const enum wprt__CompressionWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__CompressionWKVType);
	if (soap_out_wprt__CompressionWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__CompressionWKVType[] =
{	{ (long)wprt__CompressionWKVType__None, "None" },
	{ (long)wprt__CompressionWKVType__Gzip, "Gzip" },
	{ (long)wprt__CompressionWKVType__Compress, "Compress" },
	{ (long)wprt__CompressionWKVType__Deflate, "Deflate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__CompressionWKVType2s(struct soap *soap, enum wprt__CompressionWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__CompressionWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__CompressionWKVType(struct soap *soap, const char *tag, int id, const enum wprt__CompressionWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__CompressionWKVType), type);
	soap_send(soap, soap_wprt__CompressionWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__CompressionWKVType * SOAP_FMAC4 soap_get_wprt__CompressionWKVType(struct soap *soap, enum wprt__CompressionWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__CompressionWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__CompressionWKVType(struct soap *soap, const char *s, enum wprt__CompressionWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__CompressionWKVType, s);
	if (map)
		*a = (enum wprt__CompressionWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__CompressionWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__CompressionWKVType * SOAP_FMAC4 soap_in_wprt__CompressionWKVType(struct soap *soap, const char *tag, enum wprt__CompressionWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__CompressionWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__CompressionWKVType, sizeof(enum wprt__CompressionWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__CompressionWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__CompressionWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__CompressionWKVType, 0, sizeof(enum wprt__CompressionWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinFeedDirectionBaseType(struct soap *soap, enum wprt__InputBinFeedDirectionBaseType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__InputBinFeedDirectionBaseType
	*a = SOAP_DEFAULT_wprt__InputBinFeedDirectionBaseType;
#else
	*a = (enum wprt__InputBinFeedDirectionBaseType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinFeedDirectionBaseType(struct soap *soap, const enum wprt__InputBinFeedDirectionBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinFeedDirectionBaseType);
	if (soap_out_wprt__InputBinFeedDirectionBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__InputBinFeedDirectionBaseType[] =
{	{ (long)wprt__InputBinFeedDirectionBaseType__LongEdgeFirst, "LongEdgeFirst" },
	{ (long)wprt__InputBinFeedDirectionBaseType__ShortEdgeFirst, "ShortEdgeFirst" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__InputBinFeedDirectionBaseType2s(struct soap *soap, enum wprt__InputBinFeedDirectionBaseType n)
{	const char *s = soap_code_str(soap_codes_wprt__InputBinFeedDirectionBaseType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinFeedDirectionBaseType(struct soap *soap, const char *tag, int id, const enum wprt__InputBinFeedDirectionBaseType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__InputBinFeedDirectionBaseType), type);
	soap_send(soap, soap_wprt__InputBinFeedDirectionBaseType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__InputBinFeedDirectionBaseType * SOAP_FMAC4 soap_get_wprt__InputBinFeedDirectionBaseType(struct soap *soap, enum wprt__InputBinFeedDirectionBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinFeedDirectionBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__InputBinFeedDirectionBaseType(struct soap *soap, const char *s, enum wprt__InputBinFeedDirectionBaseType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__InputBinFeedDirectionBaseType, s);
	if (map)
		*a = (enum wprt__InputBinFeedDirectionBaseType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__InputBinFeedDirectionBaseType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__InputBinFeedDirectionBaseType * SOAP_FMAC4 soap_in_wprt__InputBinFeedDirectionBaseType(struct soap *soap, const char *tag, enum wprt__InputBinFeedDirectionBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__InputBinFeedDirectionBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__InputBinFeedDirectionBaseType, sizeof(enum wprt__InputBinFeedDirectionBaseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__InputBinFeedDirectionBaseType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__InputBinFeedDirectionBaseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__InputBinFeedDirectionBaseType, 0, sizeof(enum wprt__InputBinFeedDirectionBaseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConsumableColorWKVType(struct soap *soap, enum wprt__ConsumableColorWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__ConsumableColorWKVType
	*a = SOAP_DEFAULT_wprt__ConsumableColorWKVType;
#else
	*a = (enum wprt__ConsumableColorWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConsumableColorWKVType(struct soap *soap, const enum wprt__ConsumableColorWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConsumableColorWKVType);
	if (soap_out_wprt__ConsumableColorWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__ConsumableColorWKVType[] =
{	{ (long)wprt__ConsumableColorWKVType__Black, "Black" },
	{ (long)wprt__ConsumableColorWKVType__Blue, "Blue" },
	{ (long)wprt__ConsumableColorWKVType__Color, "Color" },
	{ (long)wprt__ConsumableColorWKVType__Cyan, "Cyan" },
	{ (long)wprt__ConsumableColorWKVType__Gray, "Gray" },
	{ (long)wprt__ConsumableColorWKVType__Green, "Green" },
	{ (long)wprt__ConsumableColorWKVType__Magenta, "Magenta" },
	{ (long)wprt__ConsumableColorWKVType__PhotoBlack, "PhotoBlack" },
	{ (long)wprt__ConsumableColorWKVType__PhotoColor, "PhotoColor" },
	{ (long)wprt__ConsumableColorWKVType__PhotoCyan, "PhotoCyan" },
	{ (long)wprt__ConsumableColorWKVType__PhotoMagenta, "PhotoMagenta" },
	{ (long)wprt__ConsumableColorWKVType__PhotoYellow, "PhotoYellow" },
	{ (long)wprt__ConsumableColorWKVType__Red, "Red" },
	{ (long)wprt__ConsumableColorWKVType__White, "White" },
	{ (long)wprt__ConsumableColorWKVType__Yellow, "Yellow" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__ConsumableColorWKVType2s(struct soap *soap, enum wprt__ConsumableColorWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__ConsumableColorWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConsumableColorWKVType(struct soap *soap, const char *tag, int id, const enum wprt__ConsumableColorWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ConsumableColorWKVType), type);
	soap_send(soap, soap_wprt__ConsumableColorWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__ConsumableColorWKVType * SOAP_FMAC4 soap_get_wprt__ConsumableColorWKVType(struct soap *soap, enum wprt__ConsumableColorWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConsumableColorWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__ConsumableColorWKVType(struct soap *soap, const char *s, enum wprt__ConsumableColorWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__ConsumableColorWKVType, s);
	if (map)
		*a = (enum wprt__ConsumableColorWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 14)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__ConsumableColorWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__ConsumableColorWKVType * SOAP_FMAC4 soap_in_wprt__ConsumableColorWKVType(struct soap *soap, const char *tag, enum wprt__ConsumableColorWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__ConsumableColorWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConsumableColorWKVType, sizeof(enum wprt__ConsumableColorWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__ConsumableColorWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__ConsumableColorWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ConsumableColorWKVType, 0, sizeof(enum wprt__ConsumableColorWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConsumableTypeWKVType(struct soap *soap, enum wprt__ConsumableTypeWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__ConsumableTypeWKVType
	*a = SOAP_DEFAULT_wprt__ConsumableTypeWKVType;
#else
	*a = (enum wprt__ConsumableTypeWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConsumableTypeWKVType(struct soap *soap, const enum wprt__ConsumableTypeWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConsumableTypeWKVType);
	if (soap_out_wprt__ConsumableTypeWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__ConsumableTypeWKVType[] =
{	{ (long)wprt__ConsumableTypeWKVType__Toner, "Toner" },
	{ (long)wprt__ConsumableTypeWKVType__WasteToner, "WasteToner" },
	{ (long)wprt__ConsumableTypeWKVType__Ink, "Ink" },
	{ (long)wprt__ConsumableTypeWKVType__WasteInk, "WasteInk" },
	{ (long)wprt__ConsumableTypeWKVType__Opc, "Opc" },
	{ (long)wprt__ConsumableTypeWKVType__Developer, "Developer" },
	{ (long)wprt__ConsumableTypeWKVType__FuserOil, "FuserOil" },
	{ (long)wprt__ConsumableTypeWKVType__Wax, "Wax" },
	{ (long)wprt__ConsumableTypeWKVType__WasteWax, "WasteWax" },
	{ (long)wprt__ConsumableTypeWKVType__Staples, "Staples" },
	{ (long)wprt__ConsumableTypeWKVType__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__ConsumableTypeWKVType2s(struct soap *soap, enum wprt__ConsumableTypeWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__ConsumableTypeWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConsumableTypeWKVType(struct soap *soap, const char *tag, int id, const enum wprt__ConsumableTypeWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ConsumableTypeWKVType), type);
	soap_send(soap, soap_wprt__ConsumableTypeWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__ConsumableTypeWKVType * SOAP_FMAC4 soap_get_wprt__ConsumableTypeWKVType(struct soap *soap, enum wprt__ConsumableTypeWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConsumableTypeWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__ConsumableTypeWKVType(struct soap *soap, const char *s, enum wprt__ConsumableTypeWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__ConsumableTypeWKVType, s);
	if (map)
		*a = (enum wprt__ConsumableTypeWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__ConsumableTypeWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__ConsumableTypeWKVType * SOAP_FMAC4 soap_in_wprt__ConsumableTypeWKVType(struct soap *soap, const char *tag, enum wprt__ConsumableTypeWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__ConsumableTypeWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConsumableTypeWKVType, sizeof(enum wprt__ConsumableTypeWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__ConsumableTypeWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__ConsumableTypeWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ConsumableTypeWKVType, 0, sizeof(enum wprt__ConsumableTypeWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StorageTypeWKVType(struct soap *soap, enum wprt__StorageTypeWKVType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__StorageTypeWKVType
	*a = SOAP_DEFAULT_wprt__StorageTypeWKVType;
#else
	*a = (enum wprt__StorageTypeWKVType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StorageTypeWKVType(struct soap *soap, const enum wprt__StorageTypeWKVType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StorageTypeWKVType);
	if (soap_out_wprt__StorageTypeWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__StorageTypeWKVType[] =
{	{ (long)wprt__StorageTypeWKVType__RAM, "RAM" },
	{ (long)wprt__StorageTypeWKVType__PSMemory, "PSMemory" },
	{ (long)wprt__StorageTypeWKVType__NonRemovableFlash, "NonRemovableFlash" },
	{ (long)wprt__StorageTypeWKVType__HardDisk, "HardDisk" },
	{ (long)wprt__StorageTypeWKVType__SmartMedia, "SmartMedia" },
	{ (long)wprt__StorageTypeWKVType__CompactFlash, "CompactFlash" },
	{ (long)wprt__StorageTypeWKVType__MemoryStick, "MemoryStick" },
	{ (long)wprt__StorageTypeWKVType__SecureDigital, "SecureDigital" },
	{ (long)wprt__StorageTypeWKVType__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__StorageTypeWKVType2s(struct soap *soap, enum wprt__StorageTypeWKVType n)
{	const char *s = soap_code_str(soap_codes_wprt__StorageTypeWKVType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StorageTypeWKVType(struct soap *soap, const char *tag, int id, const enum wprt__StorageTypeWKVType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__StorageTypeWKVType), type);
	soap_send(soap, soap_wprt__StorageTypeWKVType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__StorageTypeWKVType * SOAP_FMAC4 soap_get_wprt__StorageTypeWKVType(struct soap *soap, enum wprt__StorageTypeWKVType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StorageTypeWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__StorageTypeWKVType(struct soap *soap, const char *s, enum wprt__StorageTypeWKVType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wprt__StorageTypeWKVType, s);
	if (map)
		*a = (enum wprt__StorageTypeWKVType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__StorageTypeWKVType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__StorageTypeWKVType * SOAP_FMAC4 soap_in_wprt__StorageTypeWKVType(struct soap *soap, const char *tag, enum wprt__StorageTypeWKVType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__StorageTypeWKVType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StorageTypeWKVType, sizeof(enum wprt__StorageTypeWKVType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__StorageTypeWKVType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__StorageTypeWKVType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__StorageTypeWKVType, 0, sizeof(enum wprt__StorageTypeWKVType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrintServiceFaultValuesType(struct soap *soap, enum wprt__PrintServiceFaultValuesType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wprt__PrintServiceFaultValuesType
	*a = SOAP_DEFAULT_wprt__PrintServiceFaultValuesType;
#else
	*a = (enum wprt__PrintServiceFaultValuesType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrintServiceFaultValuesType(struct soap *soap, const enum wprt__PrintServiceFaultValuesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrintServiceFaultValuesType);
	if (soap_out_wprt__PrintServiceFaultValuesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wprt__PrintServiceFaultValuesType[] =
{	{ (long)wprt__PrintServiceFaultValuesType__wprt__InvalidArgs, "wprt:InvalidArgs" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__OperationFailed, "wprt:OperationFailed" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ClientErrorCompressionNotSupported, "wprt:ClientErrorCompressionNotSupported" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ClientErrorDocumentURLNotFound, "wprt:ClientErrorDocumentURLNotFound" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ClientErrorDocumentURLSchemeNotSupported, "wprt:ClientErrorDocumentURLSchemeNotSupported" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ClientErrorFormatNotSupported, "wprt:ClientErrorFormatNotSupported" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ClientErrorJobIdNotFound, "wprt:ClientErrorJobIdNotFound" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ClientErrorLastDocumentAlreadySent, "wprt:ClientErrorLastDocumentAlreadySent" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ClientErrorMultipleDocumentsNotSupported, "wprt:ClientErrorMultipleDocumentsNotSupported" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ServerErrorAddDocumentNotSupported, "wprt:ServerErrorAddDocumentNotSupported" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ServerErrorDocumentActive, "wprt:ServerErrorDocumentActive" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ServerErrorInternalError, "wprt:ServerErrorInternalError" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ServerErrorJobCancelled, "wprt:ServerErrorJobCancelled" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ServerErrorNotAcceptingJobs, "wprt:ServerErrorNotAcceptingJobs" },
	{ (long)wprt__PrintServiceFaultValuesType__wprt__ServerErrorTemporaryError, "wprt:ServerErrorTemporaryError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wprt__PrintServiceFaultValuesType2s(struct soap *soap, enum wprt__PrintServiceFaultValuesType n)
{	const char *s = soap_code_str(soap_codes_wprt__PrintServiceFaultValuesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrintServiceFaultValuesType(struct soap *soap, const char *tag, int id, const enum wprt__PrintServiceFaultValuesType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrintServiceFaultValuesType), type);
	soap_send(soap, soap_wprt__PrintServiceFaultValuesType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wprt__PrintServiceFaultValuesType * SOAP_FMAC4 soap_get_wprt__PrintServiceFaultValuesType(struct soap *soap, enum wprt__PrintServiceFaultValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrintServiceFaultValuesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wprt__PrintServiceFaultValuesType(struct soap *soap, const char *s, enum wprt__PrintServiceFaultValuesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wprt__PrintServiceFaultValuesType, t);
	if (map)
		*a = (enum wprt__PrintServiceFaultValuesType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 14)))
			return soap->error = SOAP_TYPE;
		*a = (enum wprt__PrintServiceFaultValuesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wprt__PrintServiceFaultValuesType * SOAP_FMAC4 soap_in_wprt__PrintServiceFaultValuesType(struct soap *soap, const char *tag, enum wprt__PrintServiceFaultValuesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wprt__PrintServiceFaultValuesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrintServiceFaultValuesType, sizeof(enum wprt__PrintServiceFaultValuesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wprt__PrintServiceFaultValuesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wprt__PrintServiceFaultValuesType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrintServiceFaultValuesType, 0, sizeof(enum wprt__PrintServiceFaultValuesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{	const char *s = soap_code_str(soap_codes_xsd__boolean, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type);
	soap_send(soap, soap_xsd__boolean2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_set_attr(soap, "xml:lang", "en-us");
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	dpws_headers_out(dpws_soap2dpws(soap));
	if (a) {
	/* transient dummy skipped */
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (!dpws_header_in(dpws_soap2dpws(soap)))
				continue;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__JobEndStateEvent(struct soap *soap, const struct __wprt__JobEndStateEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobEndStateEventType(soap, &a->wprt__JobEndStateEvent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__JobEndStateEvent(struct soap *soap, struct __wprt__JobEndStateEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__JobEndStateEvent = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__JobEndStateEvent(struct soap *soap, const struct __wprt__JobEndStateEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__JobEndStateEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__JobEndStateEvent(struct soap *soap, const char *tag, int id, const struct __wprt__JobEndStateEvent *a, const char *type)
{
	soap_out_PointerTowprt__JobEndStateEventType(soap, "wprt:JobEndStateEvent", -1, &a->wprt__JobEndStateEvent, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__JobEndStateEvent * SOAP_FMAC4 soap_get___wprt__JobEndStateEvent(struct soap *soap, struct __wprt__JobEndStateEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__JobEndStateEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__JobEndStateEvent * SOAP_FMAC4 soap_in___wprt__JobEndStateEvent(struct soap *soap, const char *tag, struct __wprt__JobEndStateEvent *a, const char *type)
{
	short soap_flag_wprt__JobEndStateEvent = 1;
	a = (struct __wprt__JobEndStateEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__JobEndStateEvent, sizeof(struct __wprt__JobEndStateEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__JobEndStateEvent(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__JobEndStateEvent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobEndStateEventType(soap, "wprt:JobEndStateEvent", &a->wprt__JobEndStateEvent, "wprt:JobEndStateEventType"))
				{	soap_flag_wprt__JobEndStateEvent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__JobStatusEvent(struct soap *soap, const struct __wprt__JobStatusEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobStatusEventType(soap, &a->wprt__JobStatusEvent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__JobStatusEvent(struct soap *soap, struct __wprt__JobStatusEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__JobStatusEvent = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__JobStatusEvent(struct soap *soap, const struct __wprt__JobStatusEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__JobStatusEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__JobStatusEvent(struct soap *soap, const char *tag, int id, const struct __wprt__JobStatusEvent *a, const char *type)
{
	soap_out_PointerTowprt__JobStatusEventType(soap, "wprt:JobStatusEvent", -1, &a->wprt__JobStatusEvent, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__JobStatusEvent * SOAP_FMAC4 soap_get___wprt__JobStatusEvent(struct soap *soap, struct __wprt__JobStatusEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__JobStatusEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__JobStatusEvent * SOAP_FMAC4 soap_in___wprt__JobStatusEvent(struct soap *soap, const char *tag, struct __wprt__JobStatusEvent *a, const char *type)
{
	short soap_flag_wprt__JobStatusEvent = 1;
	a = (struct __wprt__JobStatusEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__JobStatusEvent, sizeof(struct __wprt__JobStatusEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__JobStatusEvent(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__JobStatusEvent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobStatusEventType(soap, "wprt:JobStatusEvent", &a->wprt__JobStatusEvent, "wprt:JobStatusEventType"))
				{	soap_flag_wprt__JobStatusEvent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__PrinterStatusConditionClearedEvent(struct soap *soap, const struct __wprt__PrinterStatusConditionClearedEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrinterStatusConditionClearedEventType(soap, &a->wprt__PrinterStatusConditionClearedEvent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__PrinterStatusConditionClearedEvent(struct soap *soap, struct __wprt__PrinterStatusConditionClearedEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__PrinterStatusConditionClearedEvent = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__PrinterStatusConditionClearedEvent(struct soap *soap, const struct __wprt__PrinterStatusConditionClearedEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__PrinterStatusConditionClearedEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__PrinterStatusConditionClearedEvent(struct soap *soap, const char *tag, int id, const struct __wprt__PrinterStatusConditionClearedEvent *a, const char *type)
{
	soap_out_PointerTowprt__PrinterStatusConditionClearedEventType(soap, "wprt:PrinterStatusConditionClearedEvent", -1, &a->wprt__PrinterStatusConditionClearedEvent, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__PrinterStatusConditionClearedEvent * SOAP_FMAC4 soap_get___wprt__PrinterStatusConditionClearedEvent(struct soap *soap, struct __wprt__PrinterStatusConditionClearedEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__PrinterStatusConditionClearedEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__PrinterStatusConditionClearedEvent * SOAP_FMAC4 soap_in___wprt__PrinterStatusConditionClearedEvent(struct soap *soap, const char *tag, struct __wprt__PrinterStatusConditionClearedEvent *a, const char *type)
{
	short soap_flag_wprt__PrinterStatusConditionClearedEvent = 1;
	a = (struct __wprt__PrinterStatusConditionClearedEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__PrinterStatusConditionClearedEvent, sizeof(struct __wprt__PrinterStatusConditionClearedEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__PrinterStatusConditionClearedEvent(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__PrinterStatusConditionClearedEvent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStatusConditionClearedEventType(soap, "wprt:PrinterStatusConditionClearedEvent", &a->wprt__PrinterStatusConditionClearedEvent, "wprt:PrinterStatusConditionClearedEventType"))
				{	soap_flag_wprt__PrinterStatusConditionClearedEvent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__PrinterStatusConditionEvent(struct soap *soap, const struct __wprt__PrinterStatusConditionEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrinterStatusConditionEventType(soap, &a->wprt__PrinterStatusConditionEvent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__PrinterStatusConditionEvent(struct soap *soap, struct __wprt__PrinterStatusConditionEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__PrinterStatusConditionEvent = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__PrinterStatusConditionEvent(struct soap *soap, const struct __wprt__PrinterStatusConditionEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__PrinterStatusConditionEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__PrinterStatusConditionEvent(struct soap *soap, const char *tag, int id, const struct __wprt__PrinterStatusConditionEvent *a, const char *type)
{
	soap_out_PointerTowprt__PrinterStatusConditionEventType(soap, "wprt:PrinterStatusConditionEvent", -1, &a->wprt__PrinterStatusConditionEvent, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__PrinterStatusConditionEvent * SOAP_FMAC4 soap_get___wprt__PrinterStatusConditionEvent(struct soap *soap, struct __wprt__PrinterStatusConditionEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__PrinterStatusConditionEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__PrinterStatusConditionEvent * SOAP_FMAC4 soap_in___wprt__PrinterStatusConditionEvent(struct soap *soap, const char *tag, struct __wprt__PrinterStatusConditionEvent *a, const char *type)
{
	short soap_flag_wprt__PrinterStatusConditionEvent = 1;
	a = (struct __wprt__PrinterStatusConditionEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__PrinterStatusConditionEvent, sizeof(struct __wprt__PrinterStatusConditionEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__PrinterStatusConditionEvent(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__PrinterStatusConditionEvent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStatusConditionEventType(soap, "wprt:PrinterStatusConditionEvent", &a->wprt__PrinterStatusConditionEvent, "wprt:PrinterStatusConditionEventType"))
				{	soap_flag_wprt__PrinterStatusConditionEvent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__PrinterStatusSummaryEvent(struct soap *soap, const struct __wprt__PrinterStatusSummaryEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrinterStatusSummaryEventType(soap, &a->wprt__PrinterStatusSummaryEvent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__PrinterStatusSummaryEvent(struct soap *soap, struct __wprt__PrinterStatusSummaryEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__PrinterStatusSummaryEvent = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__PrinterStatusSummaryEvent(struct soap *soap, const struct __wprt__PrinterStatusSummaryEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__PrinterStatusSummaryEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__PrinterStatusSummaryEvent(struct soap *soap, const char *tag, int id, const struct __wprt__PrinterStatusSummaryEvent *a, const char *type)
{
	soap_out_PointerTowprt__PrinterStatusSummaryEventType(soap, "wprt:PrinterStatusSummaryEvent", -1, &a->wprt__PrinterStatusSummaryEvent, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__PrinterStatusSummaryEvent * SOAP_FMAC4 soap_get___wprt__PrinterStatusSummaryEvent(struct soap *soap, struct __wprt__PrinterStatusSummaryEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__PrinterStatusSummaryEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__PrinterStatusSummaryEvent * SOAP_FMAC4 soap_in___wprt__PrinterStatusSummaryEvent(struct soap *soap, const char *tag, struct __wprt__PrinterStatusSummaryEvent *a, const char *type)
{
	short soap_flag_wprt__PrinterStatusSummaryEvent = 1;
	a = (struct __wprt__PrinterStatusSummaryEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__PrinterStatusSummaryEvent, sizeof(struct __wprt__PrinterStatusSummaryEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__PrinterStatusSummaryEvent(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__PrinterStatusSummaryEvent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStatusSummaryEventType(soap, "wprt:PrinterStatusSummaryEvent", &a->wprt__PrinterStatusSummaryEvent, "wprt:PrinterStatusSummaryEventType"))
				{	soap_flag_wprt__PrinterStatusSummaryEvent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__PrinterElementsChangeEvent(struct soap *soap, const struct __wprt__PrinterElementsChangeEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrinterElementsChangeEventType(soap, &a->wprt__PrinterElementsChangeEvent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__PrinterElementsChangeEvent(struct soap *soap, struct __wprt__PrinterElementsChangeEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__PrinterElementsChangeEvent = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__PrinterElementsChangeEvent(struct soap *soap, const struct __wprt__PrinterElementsChangeEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__PrinterElementsChangeEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__PrinterElementsChangeEvent(struct soap *soap, const char *tag, int id, const struct __wprt__PrinterElementsChangeEvent *a, const char *type)
{
	soap_out_PointerTowprt__PrinterElementsChangeEventType(soap, "wprt:PrinterElementsChangeEvent", -1, &a->wprt__PrinterElementsChangeEvent, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__PrinterElementsChangeEvent * SOAP_FMAC4 soap_get___wprt__PrinterElementsChangeEvent(struct soap *soap, struct __wprt__PrinterElementsChangeEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__PrinterElementsChangeEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__PrinterElementsChangeEvent * SOAP_FMAC4 soap_in___wprt__PrinterElementsChangeEvent(struct soap *soap, const char *tag, struct __wprt__PrinterElementsChangeEvent *a, const char *type)
{
	short soap_flag_wprt__PrinterElementsChangeEvent = 1;
	a = (struct __wprt__PrinterElementsChangeEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__PrinterElementsChangeEvent, sizeof(struct __wprt__PrinterElementsChangeEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__PrinterElementsChangeEvent(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__PrinterElementsChangeEvent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterElementsChangeEventType(soap, "wprt:PrinterElementsChangeEvent", &a->wprt__PrinterElementsChangeEvent, "wprt:PrinterElementsChangeEventType"))
				{	soap_flag_wprt__PrinterElementsChangeEvent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__SetEventRate(struct soap *soap, const struct __wprt__SetEventRate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__SetEventRateRequestType(soap, &a->wprt__SetEventRateRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__SetEventRate(struct soap *soap, struct __wprt__SetEventRate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__SetEventRateRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__SetEventRate(struct soap *soap, const struct __wprt__SetEventRate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__SetEventRate(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__SetEventRate(struct soap *soap, const char *tag, int id, const struct __wprt__SetEventRate *a, const char *type)
{
	soap_out_PointerTowprt__SetEventRateRequestType(soap, "wprt:SetEventRateRequest", -1, &a->wprt__SetEventRateRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__SetEventRate * SOAP_FMAC4 soap_get___wprt__SetEventRate(struct soap *soap, struct __wprt__SetEventRate *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__SetEventRate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__SetEventRate * SOAP_FMAC4 soap_in___wprt__SetEventRate(struct soap *soap, const char *tag, struct __wprt__SetEventRate *a, const char *type)
{
	short soap_flag_wprt__SetEventRateRequest = 1;
	a = (struct __wprt__SetEventRate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__SetEventRate, sizeof(struct __wprt__SetEventRate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__SetEventRate(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__SetEventRateRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__SetEventRateRequestType(soap, "wprt:SetEventRateRequest", &a->wprt__SetEventRateRequest, "wprt:SetEventRateRequestType"))
				{	soap_flag_wprt__SetEventRateRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__GetJobHistory(struct soap *soap, const struct __wprt__GetJobHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__GetJobHistoryRequestType(soap, &a->wprt__GetJobHistoryRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__GetJobHistory(struct soap *soap, struct __wprt__GetJobHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__GetJobHistoryRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__GetJobHistory(struct soap *soap, const struct __wprt__GetJobHistory *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__GetJobHistory(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__GetJobHistory(struct soap *soap, const char *tag, int id, const struct __wprt__GetJobHistory *a, const char *type)
{
	soap_out_PointerTowprt__GetJobHistoryRequestType(soap, "wprt:GetJobHistoryRequest", -1, &a->wprt__GetJobHistoryRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__GetJobHistory * SOAP_FMAC4 soap_get___wprt__GetJobHistory(struct soap *soap, struct __wprt__GetJobHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__GetJobHistory(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__GetJobHistory * SOAP_FMAC4 soap_in___wprt__GetJobHistory(struct soap *soap, const char *tag, struct __wprt__GetJobHistory *a, const char *type)
{
	short soap_flag_wprt__GetJobHistoryRequest = 1;
	a = (struct __wprt__GetJobHistory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__GetJobHistory, sizeof(struct __wprt__GetJobHistory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__GetJobHistory(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__GetJobHistoryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__GetJobHistoryRequestType(soap, "wprt:GetJobHistoryRequest", &a->wprt__GetJobHistoryRequest, "wprt:GetJobHistoryRequestType"))
				{	soap_flag_wprt__GetJobHistoryRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__GetActiveJobs(struct soap *soap, const struct __wprt__GetActiveJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__GetActiveJobsRequestType(soap, &a->wprt__GetActiveJobsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__GetActiveJobs(struct soap *soap, struct __wprt__GetActiveJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__GetActiveJobsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__GetActiveJobs(struct soap *soap, const struct __wprt__GetActiveJobs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__GetActiveJobs(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__GetActiveJobs(struct soap *soap, const char *tag, int id, const struct __wprt__GetActiveJobs *a, const char *type)
{
	soap_out_PointerTowprt__GetActiveJobsRequestType(soap, "wprt:GetActiveJobsRequest", -1, &a->wprt__GetActiveJobsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__GetActiveJobs * SOAP_FMAC4 soap_get___wprt__GetActiveJobs(struct soap *soap, struct __wprt__GetActiveJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__GetActiveJobs(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__GetActiveJobs * SOAP_FMAC4 soap_in___wprt__GetActiveJobs(struct soap *soap, const char *tag, struct __wprt__GetActiveJobs *a, const char *type)
{
	short soap_flag_wprt__GetActiveJobsRequest = 1;
	a = (struct __wprt__GetActiveJobs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__GetActiveJobs, sizeof(struct __wprt__GetActiveJobs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__GetActiveJobs(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__GetActiveJobsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__GetActiveJobsRequestType(soap, "wprt:GetActiveJobsRequest", &a->wprt__GetActiveJobsRequest, "wprt:GetActiveJobsRequestType"))
				{	soap_flag_wprt__GetActiveJobsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__GetJobElements(struct soap *soap, const struct __wprt__GetJobElements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__GetJobElementsRequestType(soap, &a->wprt__GetJobElementsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__GetJobElements(struct soap *soap, struct __wprt__GetJobElements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__GetJobElementsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__GetJobElements(struct soap *soap, const struct __wprt__GetJobElements *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__GetJobElements(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__GetJobElements(struct soap *soap, const char *tag, int id, const struct __wprt__GetJobElements *a, const char *type)
{
	soap_out_PointerTowprt__GetJobElementsRequestType(soap, "wprt:GetJobElementsRequest", -1, &a->wprt__GetJobElementsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__GetJobElements * SOAP_FMAC4 soap_get___wprt__GetJobElements(struct soap *soap, struct __wprt__GetJobElements *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__GetJobElements(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__GetJobElements * SOAP_FMAC4 soap_in___wprt__GetJobElements(struct soap *soap, const char *tag, struct __wprt__GetJobElements *a, const char *type)
{
	short soap_flag_wprt__GetJobElementsRequest = 1;
	a = (struct __wprt__GetJobElements *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__GetJobElements, sizeof(struct __wprt__GetJobElements), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__GetJobElements(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__GetJobElementsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__GetJobElementsRequestType(soap, "wprt:GetJobElementsRequest", &a->wprt__GetJobElementsRequest, "wprt:GetJobElementsRequestType"))
				{	soap_flag_wprt__GetJobElementsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__GetPrinterElements(struct soap *soap, const struct __wprt__GetPrinterElements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__GetPrinterElementsRequestType(soap, &a->wprt__GetPrinterElementsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__GetPrinterElements(struct soap *soap, struct __wprt__GetPrinterElements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__GetPrinterElementsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__GetPrinterElements(struct soap *soap, const struct __wprt__GetPrinterElements *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__GetPrinterElements(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__GetPrinterElements(struct soap *soap, const char *tag, int id, const struct __wprt__GetPrinterElements *a, const char *type)
{
	soap_out_PointerTowprt__GetPrinterElementsRequestType(soap, "wprt:GetPrinterElementsRequest", -1, &a->wprt__GetPrinterElementsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__GetPrinterElements * SOAP_FMAC4 soap_get___wprt__GetPrinterElements(struct soap *soap, struct __wprt__GetPrinterElements *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__GetPrinterElements(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__GetPrinterElements * SOAP_FMAC4 soap_in___wprt__GetPrinterElements(struct soap *soap, const char *tag, struct __wprt__GetPrinterElements *a, const char *type)
{
	short soap_flag_wprt__GetPrinterElementsRequest = 1;
	a = (struct __wprt__GetPrinterElements *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__GetPrinterElements, sizeof(struct __wprt__GetPrinterElements), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__GetPrinterElements(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__GetPrinterElementsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__GetPrinterElementsRequestType(soap, "wprt:GetPrinterElementsRequest", &a->wprt__GetPrinterElementsRequest, "wprt:GetPrinterElementsRequestType"))
				{	soap_flag_wprt__GetPrinterElementsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__CancelJob(struct soap *soap, const struct __wprt__CancelJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__CancelJobRequestType(soap, &a->wprt__CancelJobRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__CancelJob(struct soap *soap, struct __wprt__CancelJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__CancelJobRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__CancelJob(struct soap *soap, const struct __wprt__CancelJob *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__CancelJob(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__CancelJob(struct soap *soap, const char *tag, int id, const struct __wprt__CancelJob *a, const char *type)
{
	soap_out_PointerTowprt__CancelJobRequestType(soap, "wprt:CancelJobRequest", -1, &a->wprt__CancelJobRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__CancelJob * SOAP_FMAC4 soap_get___wprt__CancelJob(struct soap *soap, struct __wprt__CancelJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__CancelJob(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__CancelJob * SOAP_FMAC4 soap_in___wprt__CancelJob(struct soap *soap, const char *tag, struct __wprt__CancelJob *a, const char *type)
{
	short soap_flag_wprt__CancelJobRequest = 1;
	a = (struct __wprt__CancelJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__CancelJob, sizeof(struct __wprt__CancelJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__CancelJob(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__CancelJobRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__CancelJobRequestType(soap, "wprt:CancelJobRequest", &a->wprt__CancelJobRequest, "wprt:CancelJobRequestType"))
				{	soap_flag_wprt__CancelJobRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__AddDocument(struct soap *soap, const struct __wprt__AddDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__AddDocumentRequestType(soap, &a->wprt__AddDocumentRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__AddDocument(struct soap *soap, struct __wprt__AddDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__AddDocumentRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__AddDocument(struct soap *soap, const struct __wprt__AddDocument *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__AddDocument(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__AddDocument(struct soap *soap, const char *tag, int id, const struct __wprt__AddDocument *a, const char *type)
{
	soap_out_PointerTowprt__AddDocumentRequestType(soap, "wprt:AddDocumentRequest", -1, &a->wprt__AddDocumentRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__AddDocument * SOAP_FMAC4 soap_get___wprt__AddDocument(struct soap *soap, struct __wprt__AddDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__AddDocument(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__AddDocument * SOAP_FMAC4 soap_in___wprt__AddDocument(struct soap *soap, const char *tag, struct __wprt__AddDocument *a, const char *type)
{
	short soap_flag_wprt__AddDocumentRequest = 1;
	a = (struct __wprt__AddDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__AddDocument, sizeof(struct __wprt__AddDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__AddDocument(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__AddDocumentRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__AddDocumentRequestType(soap, "wprt:AddDocumentRequest", &a->wprt__AddDocumentRequest, "wprt:AddDocumentRequestType"))
				{	soap_flag_wprt__AddDocumentRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__SendDocument(struct soap *soap, const struct __wprt__SendDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__SendDocumentRequestType(soap, &a->wprt__SendDocumentRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__SendDocument(struct soap *soap, struct __wprt__SendDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__SendDocumentRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__SendDocument(struct soap *soap, const struct __wprt__SendDocument *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__SendDocument(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__SendDocument(struct soap *soap, const char *tag, int id, const struct __wprt__SendDocument *a, const char *type)
{
	soap_out_PointerTowprt__SendDocumentRequestType(soap, "wprt:SendDocumentRequest", -1, &a->wprt__SendDocumentRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__SendDocument * SOAP_FMAC4 soap_get___wprt__SendDocument(struct soap *soap, struct __wprt__SendDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__SendDocument(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__SendDocument * SOAP_FMAC4 soap_in___wprt__SendDocument(struct soap *soap, const char *tag, struct __wprt__SendDocument *a, const char *type)
{
	short soap_flag_wprt__SendDocumentRequest = 1;
	a = (struct __wprt__SendDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__SendDocument, sizeof(struct __wprt__SendDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__SendDocument(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__SendDocumentRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__SendDocumentRequestType(soap, "wprt:SendDocumentRequest", &a->wprt__SendDocumentRequest, "wprt:SendDocumentRequestType"))
				{	soap_flag_wprt__SendDocumentRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wprt__CreatePrintJob(struct soap *soap, const struct __wprt__CreatePrintJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__CreatePrintJobRequestType(soap, &a->wprt__CreatePrintJobRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wprt__CreatePrintJob(struct soap *soap, struct __wprt__CreatePrintJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wprt__CreatePrintJobRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wprt__CreatePrintJob(struct soap *soap, const struct __wprt__CreatePrintJob *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wprt__CreatePrintJob(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wprt__CreatePrintJob(struct soap *soap, const char *tag, int id, const struct __wprt__CreatePrintJob *a, const char *type)
{
	soap_out_PointerTowprt__CreatePrintJobRequestType(soap, "wprt:CreatePrintJobRequest", -1, &a->wprt__CreatePrintJobRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __wprt__CreatePrintJob * SOAP_FMAC4 soap_get___wprt__CreatePrintJob(struct soap *soap, struct __wprt__CreatePrintJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___wprt__CreatePrintJob(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __wprt__CreatePrintJob * SOAP_FMAC4 soap_in___wprt__CreatePrintJob(struct soap *soap, const char *tag, struct __wprt__CreatePrintJob *a, const char *type)
{
	short soap_flag_wprt__CreatePrintJobRequest = 1;
	a = (struct __wprt__CreatePrintJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___wprt__CreatePrintJob, sizeof(struct __wprt__CreatePrintJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wprt__CreatePrintJob(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wprt__CreatePrintJobRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__CreatePrintJobRequestType(soap, "wprt:CreatePrintJobRequest", &a->wprt__CreatePrintJobRequest, "wprt:CreatePrintJobRequestType"))
				{	soap_flag_wprt__CreatePrintJobRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__Printer(struct soap *soap, const struct _wprt__Printer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrinterDescriptionType(soap, &a->PrinterDescription);
	soap_serialize_PointerTowprt__PrinterConfigurationType(soap, &a->PrinterConfiguration);
	soap_serialize_PointerTowprt__PrinterStatusType(soap, &a->PrinterStatus);
	soap_serialize_PointerTowprt__PrintTicketType(soap, &a->DefaultPrintTicket);
	soap_serialize_PointerTowprt__PrinterCapabilitiesType(soap, &a->PrinterCapabilities);
	soap_serialize_PointerTowprt__JobTableType(soap, &a->JobTable);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wprt__Printer(struct soap *soap, struct _wprt__Printer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PrinterDescription = NULL;
	a->PrinterConfiguration = NULL;
	a->PrinterStatus = NULL;
	a->DefaultPrintTicket = NULL;
	a->PrinterCapabilities = NULL;
	a->JobTable = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wprt__Printer(struct soap *soap, const struct _wprt__Printer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wprt__Printer);
	if (soap_out__wprt__Printer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__Printer(struct soap *soap, const char *tag, int id, const struct _wprt__Printer *a, const char *type)
{
	printf("%s enter\n", __FUNCTION__);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wprt__Printer), type);
	soap_out_PointerTowprt__PrinterDescriptionType(soap, "wprt:PrinterDescription", -1, &a->PrinterDescription, "");
	soap_out_PointerTowprt__PrinterConfigurationType(soap, "wprt:PrinterConfiguration", -1, &a->PrinterConfiguration, "");
	soap_out_PointerTowprt__PrinterStatusType(soap, "wprt:PrinterStatus", -1, &a->PrinterStatus, "");
	soap_out_PointerTowprt__PrintTicketType(soap, "wprt:DefaultPrintTicket", -1, &a->DefaultPrintTicket, "");
	soap_out_PointerTowprt__PrinterCapabilitiesType(soap, "wprt:PrinterCapabilities", -1, &a->PrinterCapabilities, "");
	soap_out_PointerTowprt__JobTableType(soap, "wprt:JobTable", -1, &a->JobTable, "");
	soap_element_end_out(soap, tag);
	printf("%s exit\n", __FUNCTION__);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wprt__Printer * SOAP_FMAC4 soap_get__wprt__Printer(struct soap *soap, struct _wprt__Printer *p, const char *tag, const char *type)
{
	if ((p = soap_in__wprt__Printer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__Printer * SOAP_FMAC4 soap_in__wprt__Printer(struct soap *soap, const char *tag, struct _wprt__Printer *a, const char *type)
{
	short soap_flag_PrinterDescription = 1, soap_flag_PrinterConfiguration = 1, soap_flag_PrinterStatus = 1, soap_flag_DefaultPrintTicket = 1, soap_flag_PrinterCapabilities = 1, soap_flag_JobTable = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wprt__Printer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wprt__Printer, sizeof(struct _wprt__Printer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wprt__Printer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrinterDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterDescriptionType(soap, "PrinterDescription", &a->PrinterDescription, "wprt:PrinterDescriptionType"))
				{	soap_flag_PrinterDescription--;
					continue;
				}
			if (soap_flag_PrinterConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterConfigurationType(soap, "PrinterConfiguration", &a->PrinterConfiguration, "wprt:PrinterConfigurationType"))
				{	soap_flag_PrinterConfiguration--;
					continue;
				}
			if (soap_flag_PrinterStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStatusType(soap, "PrinterStatus", &a->PrinterStatus, "wprt:PrinterStatusType"))
				{	soap_flag_PrinterStatus--;
					continue;
				}
			if (soap_flag_DefaultPrintTicket && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrintTicketType(soap, "DefaultPrintTicket", &a->DefaultPrintTicket, "wprt:PrintTicketType"))
				{	soap_flag_DefaultPrintTicket--;
					continue;
				}
			if (soap_flag_PrinterCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterCapabilitiesType(soap, "PrinterCapabilities", &a->PrinterCapabilities, "wprt:PrinterCapabilitiesType"))
				{	soap_flag_PrinterCapabilities--;
					continue;
				}
			if (soap_flag_JobTable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobTableType(soap, "JobTable", &a->JobTable, "wprt:JobTableType"))
				{	soap_flag_JobTable--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PrinterDescription > 0 || soap_flag_PrinterConfiguration > 0 || soap_flag_PrinterStatus > 0 || soap_flag_DefaultPrintTicket > 0 || soap_flag_PrinterCapabilities > 0 || soap_flag_JobTable > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wprt__Printer *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__wprt__Printer, 0, sizeof(struct _wprt__Printer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterElementDataType(struct soap *soap, const struct wprt__PrinterElementDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wprt__union_PrinterElementDataType(soap, a->__union_PrinterElementDataType, &a->union_PrinterElementDataType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterElementDataType(struct soap *soap, struct wprt__PrinterElementDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_PrinterElementDataType = 0;
	soap_default_xsd__QName(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->Valid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterElementDataType(struct soap *soap, const struct wprt__PrinterElementDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterElementDataType);
	if (soap_out_wprt__PrinterElementDataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterElementDataType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterElementDataType *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_QName2s(soap, a->Name));
	soap_set_attr(soap, "Valid", soap_xsd__boolean2s(soap, a->Valid));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterElementDataType), type);
	soap_out__wprt__union_PrinterElementDataType(soap, a->__union_PrinterElementDataType, &a->union_PrinterElementDataType);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterElementDataType * SOAP_FMAC4 soap_get_wprt__PrinterElementDataType(struct soap *soap, struct wprt__PrinterElementDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterElementDataType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterElementDataType * SOAP_FMAC4 soap_in_wprt__PrinterElementDataType(struct soap *soap, const char *tag, struct wprt__PrinterElementDataType *a, const char *type)
{
	short soap_flag_union_PrinterElementDataType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterElementDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterElementDataType, sizeof(struct wprt__PrinterElementDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterElementDataType(soap, a);
	if (soap_s2QName(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "Valid", 1), &a->Valid))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_PrinterElementDataType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wprt__union_PrinterElementDataType(soap, &a->__union_PrinterElementDataType, &a->union_PrinterElementDataType))
				{	soap_flag_union_PrinterElementDataType = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_PrinterElementDataType))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterElementDataType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterElementDataType, 0, sizeof(struct wprt__PrinterElementDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__DocumentValuesType_DocumentDescription(struct soap *soap, const struct _wprt__DocumentValuesType_DocumentDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->Compression);
	soap_serialize_PointerTowprt__ValueStringListType(soap, &a->Format);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wprt__DocumentValuesType_DocumentDescription(struct soap *soap, struct _wprt__DocumentValuesType_DocumentDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Compression = NULL;
	a->Format = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wprt__DocumentValuesType_DocumentDescription(struct soap *soap, const struct _wprt__DocumentValuesType_DocumentDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription);
	if (soap_out__wprt__DocumentValuesType_DocumentDescription(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__DocumentValuesType_DocumentDescription(struct soap *soap, const char *tag, int id, const struct _wprt__DocumentValuesType_DocumentDescription *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription), type);
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:Compression", -1, &a->Compression, "");
	soap_out_PointerTowprt__ValueStringListType(soap, "wprt:Format", -1, &a->Format, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wprt__DocumentValuesType_DocumentDescription * SOAP_FMAC4 soap_get__wprt__DocumentValuesType_DocumentDescription(struct soap *soap, struct _wprt__DocumentValuesType_DocumentDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wprt__DocumentValuesType_DocumentDescription(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__DocumentValuesType_DocumentDescription * SOAP_FMAC4 soap_in__wprt__DocumentValuesType_DocumentDescription(struct soap *soap, const char *tag, struct _wprt__DocumentValuesType_DocumentDescription *a, const char *type)
{
	short soap_flag_Compression = 1, soap_flag_Format = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wprt__DocumentValuesType_DocumentDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription, sizeof(struct _wprt__DocumentValuesType_DocumentDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wprt__DocumentValuesType_DocumentDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Compression && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "Compression", &a->Compression, "wprt:ValueTokenListType"))
				{	soap_flag_Compression--;
					continue;
				}
			if (soap_flag_Format && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueStringListType(soap, "Format", &a->Format, "wprt:ValueStringListType"))
				{	soap_flag_Format--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wprt__DocumentValuesType_DocumentDescription *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription, 0, sizeof(struct _wprt__DocumentValuesType_DocumentDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, const struct _wprt__JobValuesType_DocumentProcessing_Resolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AllowedValue)
	{	int i;
		for (i = 0; i < a->__sizeAllowedValue; i++)
		{
			soap_embedded(soap, a->AllowedValue + i, SOAP_TYPE_wprt__ResolutionEntryType);
			soap_serialize_wprt__ResolutionEntryType(soap, a->AllowedValue + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_Resolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAllowedValue = 0;
	a->AllowedValue = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, const struct _wprt__JobValuesType_DocumentProcessing_Resolution *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution);
	if (soap_out__wprt__JobValuesType_DocumentProcessing_Resolution(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, const char *tag, int id, const struct _wprt__JobValuesType_DocumentProcessing_Resolution *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution), type);
	if (a->AllowedValue)
	{	int i;
		for (i = 0; i < a->__sizeAllowedValue; i++)
			soap_out_wprt__ResolutionEntryType(soap, "wprt:AllowedValue", -1, a->AllowedValue + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing_Resolution * SOAP_FMAC4 soap_get__wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_Resolution *p, const char *tag, const char *type)
{
	if ((p = soap_in__wprt__JobValuesType_DocumentProcessing_Resolution(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing_Resolution * SOAP_FMAC4 soap_in__wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, const char *tag, struct _wprt__JobValuesType_DocumentProcessing_Resolution *a, const char *type)
{
	short soap_flag_AllowedValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wprt__JobValuesType_DocumentProcessing_Resolution *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution, sizeof(struct _wprt__JobValuesType_DocumentProcessing_Resolution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wprt__JobValuesType_DocumentProcessing_Resolution(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AllowedValue && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__ResolutionEntryType *p;
				soap_new_block(soap);
				for (a->__sizeAllowedValue = 0; !soap_element_begin_in(soap, "AllowedValue", 1, NULL); a->__sizeAllowedValue++)
				{	p = (struct wprt__ResolutionEntryType *)soap_push_block(soap, sizeof(struct wprt__ResolutionEntryType));
					soap_default_wprt__ResolutionEntryType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__ResolutionEntryType(soap, "AllowedValue", p, "wprt:ResolutionEntryType"))
						break;
					soap_flag_AllowedValue = 0;
				}
				a->AllowedValue = (struct wprt__ResolutionEntryType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_AllowedValue && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_DocumentProcessing_Resolution *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution, 0, sizeof(struct _wprt__JobValuesType_DocumentProcessing_Resolution), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, const struct _wprt__JobValuesType_DocumentProcessing_NumberUp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ValueIntListType(soap, &a->PagesPerSheet);
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->Direction);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_NumberUp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PagesPerSheet = NULL;
	a->Direction = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, const struct _wprt__JobValuesType_DocumentProcessing_NumberUp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp);
	if (soap_out__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, const char *tag, int id, const struct _wprt__JobValuesType_DocumentProcessing_NumberUp *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp), type);
	soap_out_PointerTowprt__ValueIntListType(soap, "wprt:PagesPerSheet", -1, &a->PagesPerSheet, "");
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:Direction", -1, &a->Direction, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing_NumberUp * SOAP_FMAC4 soap_get__wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_NumberUp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing_NumberUp * SOAP_FMAC4 soap_in__wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, const char *tag, struct _wprt__JobValuesType_DocumentProcessing_NumberUp *a, const char *type)
{
	short soap_flag_PagesPerSheet = 1, soap_flag_Direction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wprt__JobValuesType_DocumentProcessing_NumberUp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp, sizeof(struct _wprt__JobValuesType_DocumentProcessing_NumberUp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PagesPerSheet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueIntListType(soap, "PagesPerSheet", &a->PagesPerSheet, "wprt:ValueIntListType"))
				{	soap_flag_PagesPerSheet--;
					continue;
				}
			if (soap_flag_Direction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "Direction", &a->Direction, "wprt:ValueTokenListType"))
				{	soap_flag_Direction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PagesPerSheet > 0 || soap_flag_Direction > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_DocumentProcessing_NumberUp *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp, 0, sizeof(struct _wprt__JobValuesType_DocumentProcessing_NumberUp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__JobValuesType_DocumentProcessing(struct soap *soap, const struct _wprt__JobValuesType_DocumentProcessing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->MediaSizeName);
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->MediaType);
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->MediaColor);
	soap_serialize_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(soap, &a->NumberUp);
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->Orientation);
	soap_serialize_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(soap, &a->Resolution);
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->PrintQuality);
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->Sides);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wprt__JobValuesType_DocumentProcessing(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaSizeName = NULL;
	a->MediaType = NULL;
	a->MediaColor = NULL;
	a->NumberUp = NULL;
	a->Orientation = NULL;
	a->Resolution = NULL;
	a->PrintQuality = NULL;
	a->Sides = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wprt__JobValuesType_DocumentProcessing(struct soap *soap, const struct _wprt__JobValuesType_DocumentProcessing *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing);
	if (soap_out__wprt__JobValuesType_DocumentProcessing(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__JobValuesType_DocumentProcessing(struct soap *soap, const char *tag, int id, const struct _wprt__JobValuesType_DocumentProcessing *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing), type);
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:MediaSizeName", -1, &a->MediaSizeName, "");
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:MediaType", -1, &a->MediaType, "");
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:MediaColor", -1, &a->MediaColor, "");
	soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(soap, "wprt:NumberUp", -1, &a->NumberUp, "");
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:Orientation", -1, &a->Orientation, "");
	soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(soap, "wprt:Resolution", -1, &a->Resolution, "");
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:PrintQuality", -1, &a->PrintQuality, "");
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:Sides", -1, &a->Sides, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing * SOAP_FMAC4 soap_get__wprt__JobValuesType_DocumentProcessing(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing *p, const char *tag, const char *type)
{
	if ((p = soap_in__wprt__JobValuesType_DocumentProcessing(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing * SOAP_FMAC4 soap_in__wprt__JobValuesType_DocumentProcessing(struct soap *soap, const char *tag, struct _wprt__JobValuesType_DocumentProcessing *a, const char *type)
{
	short soap_flag_MediaSizeName = 1, soap_flag_MediaType = 1, soap_flag_MediaColor = 1, soap_flag_NumberUp = 1, soap_flag_Orientation = 1, soap_flag_Resolution = 1, soap_flag_PrintQuality = 1, soap_flag_Sides = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wprt__JobValuesType_DocumentProcessing *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing, sizeof(struct _wprt__JobValuesType_DocumentProcessing), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wprt__JobValuesType_DocumentProcessing(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaSizeName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "MediaSizeName", &a->MediaSizeName, "wprt:ValueTokenListType"))
				{	soap_flag_MediaSizeName--;
					continue;
				}
			if (soap_flag_MediaType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "MediaType", &a->MediaType, "wprt:ValueTokenListType"))
				{	soap_flag_MediaType--;
					continue;
				}
			if (soap_flag_MediaColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "MediaColor", &a->MediaColor, "wprt:ValueTokenListType"))
				{	soap_flag_MediaColor--;
					continue;
				}
			if (soap_flag_NumberUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(soap, "NumberUp", &a->NumberUp, ""))
				{	soap_flag_NumberUp--;
					continue;
				}
			if (soap_flag_Orientation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "Orientation", &a->Orientation, "wprt:ValueTokenListType"))
				{	soap_flag_Orientation--;
					continue;
				}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(soap, "Resolution", &a->Resolution, ""))
				{	soap_flag_Resolution--;
					continue;
				}
			if (soap_flag_PrintQuality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "PrintQuality", &a->PrintQuality, "wprt:ValueTokenListType"))
				{	soap_flag_PrintQuality--;
					continue;
				}
			if (soap_flag_Sides && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "Sides", &a->Sides, "wprt:ValueTokenListType"))
				{	soap_flag_Sides--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_DocumentProcessing *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing, 0, sizeof(struct _wprt__JobValuesType_DocumentProcessing), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, const struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->Edge);
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->Pattern);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Edge = NULL;
	a->Pattern = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, const struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch);
	if (soap_out__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, const char *tag, int id, const struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch), type);
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:Edge", -1, &a->Edge, "");
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:Pattern", -1, &a->Pattern, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch * SOAP_FMAC4 soap_get__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *p, const char *tag, const char *type)
{
	if ((p = soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch * SOAP_FMAC4 soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, const char *tag, struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *a, const char *type)
{
	short soap_flag_Edge = 1, soap_flag_Pattern = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Edge && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "Edge", &a->Edge, "wprt:ValueTokenListType"))
				{	soap_flag_Edge--;
					continue;
				}
			if (soap_flag_Pattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "Pattern", &a->Pattern, "wprt:ValueTokenListType"))
				{	soap_flag_Pattern--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Edge > 0 || soap_flag_Pattern > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch, 0, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, const struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->Location);
	soap_serialize_PointerTowprt__ValueTokenListType(soap, &a->Angle);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Location = NULL;
	a->Angle = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, const struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple);
	if (soap_out__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, const char *tag, int id, const struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple), type);
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:Location", -1, &a->Location, "");
	soap_out_PointerTowprt__ValueTokenListType(soap, "wprt:Angle", -1, &a->Angle, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple * SOAP_FMAC4 soap_get__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *p, const char *tag, const char *type)
{
	if ((p = soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple * SOAP_FMAC4 soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, const char *tag, struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *a, const char *type)
{
	short soap_flag_Location = 1, soap_flag_Angle = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Location && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "Location", &a->Location, "wprt:ValueTokenListType"))
				{	soap_flag_Location--;
					continue;
				}
			if (soap_flag_Angle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueTokenListType(soap, "Angle", &a->Angle, "wprt:ValueTokenListType"))
				{	soap_flag_Angle--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Location > 0 || soap_flag_Angle > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple, 0, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, const struct _wprt__JobValuesType_JobProcessing_JobFinishings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, &a->Staple);
	soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, &a->HolePunch);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Staple = NULL;
	a->HolePunch = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, const struct _wprt__JobValuesType_JobProcessing_JobFinishings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings);
	if (soap_out__wprt__JobValuesType_JobProcessing_JobFinishings(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, const char *tag, int id, const struct _wprt__JobValuesType_JobProcessing_JobFinishings *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings), type);
	soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, "wprt:Staple", -1, &a->Staple, "");
	soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, "wprt:HolePunch", -1, &a->HolePunch, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings * SOAP_FMAC4 soap_get__wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings *p, const char *tag, const char *type)
{
	if ((p = soap_in__wprt__JobValuesType_JobProcessing_JobFinishings(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings * SOAP_FMAC4 soap_in__wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, const char *tag, struct _wprt__JobValuesType_JobProcessing_JobFinishings *a, const char *type)
{
	short soap_flag_Staple = 1, soap_flag_HolePunch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wprt__JobValuesType_JobProcessing_JobFinishings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Staple && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, "Staple", &a->Staple, ""))
				{	soap_flag_Staple--;
					continue;
				}
			if (soap_flag_HolePunch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, "HolePunch", &a->HolePunch, ""))
				{	soap_flag_HolePunch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings, 0, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__JobValuesType_JobProcessing(struct soap *soap, const struct _wprt__JobValuesType_JobProcessing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ValueIntRangeType(soap, &a->Copies);
	soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(soap, &a->JobFinishings);
	soap_serialize_PointerTowprt__ValueIntRangeType(soap, &a->Priority);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wprt__JobValuesType_JobProcessing(struct soap *soap, struct _wprt__JobValuesType_JobProcessing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Copies = NULL;
	a->JobFinishings = NULL;
	a->Priority = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wprt__JobValuesType_JobProcessing(struct soap *soap, const struct _wprt__JobValuesType_JobProcessing *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wprt__JobValuesType_JobProcessing);
	if (soap_out__wprt__JobValuesType_JobProcessing(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__JobValuesType_JobProcessing(struct soap *soap, const char *tag, int id, const struct _wprt__JobValuesType_JobProcessing *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wprt__JobValuesType_JobProcessing), type);
	soap_out_PointerTowprt__ValueIntRangeType(soap, "wprt:Copies", -1, &a->Copies, "");
	soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(soap, "wprt:JobFinishings", -1, &a->JobFinishings, "");
	soap_out_PointerTowprt__ValueIntRangeType(soap, "wprt:Priority", -1, &a->Priority, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing * SOAP_FMAC4 soap_get__wprt__JobValuesType_JobProcessing(struct soap *soap, struct _wprt__JobValuesType_JobProcessing *p, const char *tag, const char *type)
{
	if ((p = soap_in__wprt__JobValuesType_JobProcessing(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing * SOAP_FMAC4 soap_in__wprt__JobValuesType_JobProcessing(struct soap *soap, const char *tag, struct _wprt__JobValuesType_JobProcessing *a, const char *type)
{
	short soap_flag_Copies = 1, soap_flag_JobFinishings = 1, soap_flag_Priority = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wprt__JobValuesType_JobProcessing *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wprt__JobValuesType_JobProcessing, sizeof(struct _wprt__JobValuesType_JobProcessing), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wprt__JobValuesType_JobProcessing(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Copies && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueIntRangeType(soap, "Copies", &a->Copies, "wprt:ValueIntRangeType"))
				{	soap_flag_Copies--;
					continue;
				}
			if (soap_flag_JobFinishings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(soap, "JobFinishings", &a->JobFinishings, ""))
				{	soap_flag_JobFinishings--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ValueIntRangeType(soap, "Priority", &a->Priority, "wprt:ValueIntRangeType"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_JobProcessing *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__wprt__JobValuesType_JobProcessing, 0, sizeof(struct _wprt__JobValuesType_JobProcessing), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DocumentValuesType(struct soap *soap, const struct wprt__DocumentValuesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wprt__DocumentValuesType_DocumentDescription(soap, &a->DocumentDescription);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DocumentValuesType(struct soap *soap, struct wprt__DocumentValuesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DocumentDescription = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DocumentValuesType(struct soap *soap, const struct wprt__DocumentValuesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DocumentValuesType);
	if (soap_out_wprt__DocumentValuesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DocumentValuesType(struct soap *soap, const char *tag, int id, const struct wprt__DocumentValuesType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__DocumentValuesType), type);
	soap_out_PointerTo_wprt__DocumentValuesType_DocumentDescription(soap, "wprt:DocumentDescription", -1, &a->DocumentDescription, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__DocumentValuesType * SOAP_FMAC4 soap_get_wprt__DocumentValuesType(struct soap *soap, struct wprt__DocumentValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DocumentValuesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentValuesType * SOAP_FMAC4 soap_in_wprt__DocumentValuesType(struct soap *soap, const char *tag, struct wprt__DocumentValuesType *a, const char *type)
{
	short soap_flag_DocumentDescription = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__DocumentValuesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DocumentValuesType, sizeof(struct wprt__DocumentValuesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__DocumentValuesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocumentDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wprt__DocumentValuesType_DocumentDescription(soap, "DocumentDescription", &a->DocumentDescription, ""))
				{	soap_flag_DocumentDescription--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentValuesType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__DocumentValuesType, 0, sizeof(struct wprt__DocumentValuesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobValuesType(struct soap *soap, const struct wprt__JobValuesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing(soap, &a->JobProcessing);
	soap_serialize_PointerTo_wprt__JobValuesType_DocumentProcessing(soap, &a->DocumentProcessing);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobValuesType(struct soap *soap, struct wprt__JobValuesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobProcessing = NULL;
	a->DocumentProcessing = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobValuesType(struct soap *soap, const struct wprt__JobValuesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobValuesType);
	if (soap_out_wprt__JobValuesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobValuesType(struct soap *soap, const char *tag, int id, const struct wprt__JobValuesType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobValuesType), type);
	soap_out_PointerTo_wprt__JobValuesType_JobProcessing(soap, "wprt:JobProcessing", -1, &a->JobProcessing, "");
	soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing(soap, "wprt:DocumentProcessing", -1, &a->DocumentProcessing, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobValuesType * SOAP_FMAC4 soap_get_wprt__JobValuesType(struct soap *soap, struct wprt__JobValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobValuesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobValuesType * SOAP_FMAC4 soap_in_wprt__JobValuesType(struct soap *soap, const char *tag, struct wprt__JobValuesType *a, const char *type)
{
	short soap_flag_JobProcessing = 1, soap_flag_DocumentProcessing = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobValuesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobValuesType, sizeof(struct wprt__JobValuesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobValuesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobProcessing && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wprt__JobValuesType_JobProcessing(soap, "JobProcessing", &a->JobProcessing, ""))
				{	soap_flag_JobProcessing--;
					continue;
				}
			if (soap_flag_DocumentProcessing && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing(soap, "DocumentProcessing", &a->DocumentProcessing, ""))
				{	soap_flag_DocumentProcessing--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobValuesType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobValuesType, 0, sizeof(struct wprt__JobValuesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ComponentNameType(struct soap *soap, const struct wprt__ComponentNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__ComponentNameBaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ComponentNameType(struct soap *soap, struct wprt__ComponentNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__ComponentNameBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ComponentNameType(struct soap *soap, const struct wprt__ComponentNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ComponentNameType);
	if (soap_out_wprt__ComponentNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ComponentNameType(struct soap *soap, const char *tag, int id, const struct wprt__ComponentNameType *a, const char *type)
{
	return soap_out_wprt__ComponentNameBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__ComponentNameType * SOAP_FMAC4 soap_get_wprt__ComponentNameType(struct soap *soap, struct wprt__ComponentNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ComponentNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ComponentNameType * SOAP_FMAC4 soap_in_wprt__ComponentNameType(struct soap *soap, const char *tag, struct wprt__ComponentNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__ComponentNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ComponentNameType, sizeof(struct wprt__ComponentNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__ComponentNameType(soap, a);
	if (!soap_in_wprt__ComponentNameBaseType(soap, tag, &a->__item, "wprt:ComponentNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ComponentGroupType(struct soap *soap, const struct wprt__ComponentGroupType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ComponentGroupType(struct soap *soap, struct wprt__ComponentGroupType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__ComponentGroupBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ComponentGroupType(struct soap *soap, const struct wprt__ComponentGroupType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ComponentGroupType);
	if (soap_out_wprt__ComponentGroupType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ComponentGroupType(struct soap *soap, const char *tag, int id, const struct wprt__ComponentGroupType *a, const char *type)
{
	return soap_out_wprt__ComponentGroupBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__ComponentGroupType * SOAP_FMAC4 soap_get_wprt__ComponentGroupType(struct soap *soap, struct wprt__ComponentGroupType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ComponentGroupType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ComponentGroupType * SOAP_FMAC4 soap_in_wprt__ComponentGroupType(struct soap *soap, const char *tag, struct wprt__ComponentGroupType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__ComponentGroupType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ComponentGroupType, sizeof(struct wprt__ComponentGroupType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__ComponentGroupType(soap, a);
	if (!soap_in_wprt__ComponentGroupBaseType(soap, tag, &a->__item, "wprt:ComponentGroupType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConditionSeverityType(struct soap *soap, const struct wprt__ConditionSeverityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConditionSeverityType(struct soap *soap, struct wprt__ConditionSeverityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__ConditionSeverityBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConditionSeverityType(struct soap *soap, const struct wprt__ConditionSeverityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConditionSeverityType);
	if (soap_out_wprt__ConditionSeverityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConditionSeverityType(struct soap *soap, const char *tag, int id, const struct wprt__ConditionSeverityType *a, const char *type)
{
	return soap_out_wprt__ConditionSeverityBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__ConditionSeverityType * SOAP_FMAC4 soap_get_wprt__ConditionSeverityType(struct soap *soap, struct wprt__ConditionSeverityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConditionSeverityType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionSeverityType * SOAP_FMAC4 soap_in_wprt__ConditionSeverityType(struct soap *soap, const char *tag, struct wprt__ConditionSeverityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__ConditionSeverityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConditionSeverityType, sizeof(struct wprt__ConditionSeverityType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__ConditionSeverityType(soap, a);
	if (!soap_in_wprt__ConditionSeverityBaseType(soap, tag, &a->__item, "wprt:ConditionSeverityType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConditionComponentType(struct soap *soap, const struct wprt__ConditionComponentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ComponentGroupType(soap, &a->Group);
	soap_serialize_PointerTowprt__ComponentNameType(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConditionComponentType(struct soap *soap, struct wprt__ConditionComponentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Group = NULL;
	a->Name = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConditionComponentType(struct soap *soap, const struct wprt__ConditionComponentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConditionComponentType);
	if (soap_out_wprt__ConditionComponentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConditionComponentType(struct soap *soap, const char *tag, int id, const struct wprt__ConditionComponentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ConditionComponentType), type);
	soap_out_PointerTowprt__ComponentGroupType(soap, "wprt:Group", -1, &a->Group, "");
	soap_out_PointerTowprt__ComponentNameType(soap, "wprt:Name", -1, &a->Name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ConditionComponentType * SOAP_FMAC4 soap_get_wprt__ConditionComponentType(struct soap *soap, struct wprt__ConditionComponentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConditionComponentType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionComponentType * SOAP_FMAC4 soap_in_wprt__ConditionComponentType(struct soap *soap, const char *tag, struct wprt__ConditionComponentType *a, const char *type)
{
	short soap_flag_Group = 1, soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ConditionComponentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConditionComponentType, sizeof(struct wprt__ConditionComponentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ConditionComponentType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Group && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ComponentGroupType(soap, "Group", &a->Group, "wprt:ComponentGroupType"))
				{	soap_flag_Group--;
					continue;
				}
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ComponentNameType(soap, "Name", &a->Name, "wprt:ComponentNameType"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Group > 0 || soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ConditionComponentType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ConditionComponentType, 0, sizeof(struct wprt__ConditionComponentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConditionNameType(struct soap *soap, const struct wprt__ConditionNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConditionNameType(struct soap *soap, struct wprt__ConditionNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__ConditionNameBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConditionNameType(struct soap *soap, const struct wprt__ConditionNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConditionNameType);
	if (soap_out_wprt__ConditionNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConditionNameType(struct soap *soap, const char *tag, int id, const struct wprt__ConditionNameType *a, const char *type)
{
	return soap_out_wprt__ConditionNameBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__ConditionNameType * SOAP_FMAC4 soap_get_wprt__ConditionNameType(struct soap *soap, struct wprt__ConditionNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConditionNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionNameType * SOAP_FMAC4 soap_in_wprt__ConditionNameType(struct soap *soap, const char *tag, struct wprt__ConditionNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__ConditionNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConditionNameType, sizeof(struct wprt__ConditionNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__ConditionNameType(soap, a);
	if (!soap_in_wprt__ConditionNameBaseType(soap, tag, &a->__item, "wprt:ConditionNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConditionHistoryEntryType(struct soap *soap, const struct wprt__ConditionHistoryEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__DateTimeExtType(soap, &a->Time);
	soap_serialize_PointerTowprt__ConditionNameType(soap, &a->Name);
	soap_serialize_PointerTowprt__ConditionComponentType(soap, &a->Component);
	soap_serialize_PointerTowprt__ConditionSeverityType(soap, &a->Severity);
	soap_serialize_PointerTowprt__DateTimeExtType(soap, &a->ClearTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConditionHistoryEntryType(struct soap *soap, struct wprt__ConditionHistoryEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Time = NULL;
	a->Name = NULL;
	a->Component = NULL;
	a->Severity = NULL;
	soap_default_wprt__ConditionIdType(soap, &a->Id);
	a->ClearTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConditionHistoryEntryType(struct soap *soap, const struct wprt__ConditionHistoryEntryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConditionHistoryEntryType);
	if (soap_out_wprt__ConditionHistoryEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConditionHistoryEntryType(struct soap *soap, const char *tag, int id, const struct wprt__ConditionHistoryEntryType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_int2s(soap, a->Id));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ConditionHistoryEntryType), type);
	soap_out_PointerTowprt__DateTimeExtType(soap, "wprt:Time", -1, &a->Time, "");
	soap_out_PointerTowprt__ConditionNameType(soap, "wprt:Name", -1, &a->Name, "");
	soap_out_PointerTowprt__ConditionComponentType(soap, "wprt:Component", -1, &a->Component, "");
	soap_out_PointerTowprt__ConditionSeverityType(soap, "wprt:Severity", -1, &a->Severity, "");
	soap_out_PointerTowprt__DateTimeExtType(soap, "wprt:ClearTime", -1, &a->ClearTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ConditionHistoryEntryType * SOAP_FMAC4 soap_get_wprt__ConditionHistoryEntryType(struct soap *soap, struct wprt__ConditionHistoryEntryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConditionHistoryEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionHistoryEntryType * SOAP_FMAC4 soap_in_wprt__ConditionHistoryEntryType(struct soap *soap, const char *tag, struct wprt__ConditionHistoryEntryType *a, const char *type)
{
	short soap_flag_Time = 1, soap_flag_Name = 1, soap_flag_Component = 1, soap_flag_Severity = 1, soap_flag_ClearTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ConditionHistoryEntryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConditionHistoryEntryType, sizeof(struct wprt__ConditionHistoryEntryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ConditionHistoryEntryType(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "Id", 1), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DateTimeExtType(soap, "Time", &a->Time, "wprt:DateTimeExtType"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConditionNameType(soap, "Name", &a->Name, "wprt:ConditionNameType"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Component && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConditionComponentType(soap, "Component", &a->Component, "wprt:ConditionComponentType"))
				{	soap_flag_Component--;
					continue;
				}
			if (soap_flag_Severity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConditionSeverityType(soap, "Severity", &a->Severity, "wprt:ConditionSeverityType"))
				{	soap_flag_Severity--;
					continue;
				}
			if (soap_flag_ClearTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DateTimeExtType(soap, "ClearTime", &a->ClearTime, "wprt:DateTimeExtType"))
				{	soap_flag_ClearTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0 || soap_flag_Name > 0 || soap_flag_Component > 0 || soap_flag_Severity > 0 || soap_flag_ClearTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ConditionHistoryEntryType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ConditionHistoryEntryType, 0, sizeof(struct wprt__ConditionHistoryEntryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConditionHistoryTableType(struct soap *soap, const struct wprt__ConditionHistoryTableType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ConditionHistoryEntry)
	{	int i;
		for (i = 0; i < a->__sizeConditionHistoryEntry; i++)
		{
			soap_embedded(soap, a->ConditionHistoryEntry + i, SOAP_TYPE_wprt__ConditionHistoryEntryType);
			soap_serialize_wprt__ConditionHistoryEntryType(soap, a->ConditionHistoryEntry + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConditionHistoryTableType(struct soap *soap, struct wprt__ConditionHistoryTableType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConditionHistoryEntry = 0;
	a->ConditionHistoryEntry = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConditionHistoryTableType(struct soap *soap, const struct wprt__ConditionHistoryTableType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConditionHistoryTableType);
	if (soap_out_wprt__ConditionHistoryTableType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConditionHistoryTableType(struct soap *soap, const char *tag, int id, const struct wprt__ConditionHistoryTableType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ConditionHistoryTableType), type);
	if (a->ConditionHistoryEntry)
	{	int i;
		for (i = 0; i < a->__sizeConditionHistoryEntry; i++)
			soap_out_wprt__ConditionHistoryEntryType(soap, "wprt:ConditionHistoryEntry", -1, a->ConditionHistoryEntry + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ConditionHistoryTableType * SOAP_FMAC4 soap_get_wprt__ConditionHistoryTableType(struct soap *soap, struct wprt__ConditionHistoryTableType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConditionHistoryTableType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionHistoryTableType * SOAP_FMAC4 soap_in_wprt__ConditionHistoryTableType(struct soap *soap, const char *tag, struct wprt__ConditionHistoryTableType *a, const char *type)
{
	short soap_flag_ConditionHistoryEntry = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ConditionHistoryTableType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConditionHistoryTableType, sizeof(struct wprt__ConditionHistoryTableType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ConditionHistoryTableType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConditionHistoryEntry && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__ConditionHistoryEntryType *p;
				soap_new_block(soap);
				for (a->__sizeConditionHistoryEntry = 0; !soap_element_begin_in(soap, "ConditionHistoryEntry", 1, NULL); a->__sizeConditionHistoryEntry++)
				{	p = (struct wprt__ConditionHistoryEntryType *)soap_push_block(soap, sizeof(struct wprt__ConditionHistoryEntryType));
					soap_default_wprt__ConditionHistoryEntryType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__ConditionHistoryEntryType(soap, "ConditionHistoryEntry", p, "wprt:ConditionHistoryEntryType"))
						break;
					soap_flag_ConditionHistoryEntry = 0;
				}
				a->ConditionHistoryEntry = (struct wprt__ConditionHistoryEntryType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ConditionHistoryEntry && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ConditionHistoryTableType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ConditionHistoryTableType, 0, sizeof(struct wprt__ConditionHistoryTableType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ActiveConditionTableType(struct soap *soap, const struct wprt__ActiveConditionTableType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->DeviceCondition)
	{	int i;
		for (i = 0; i < a->__sizeDeviceCondition; i++)
		{
			soap_embedded(soap, a->DeviceCondition + i, SOAP_TYPE_wprt__DeviceConditionType);
			soap_serialize_wprt__DeviceConditionType(soap, a->DeviceCondition + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ActiveConditionTableType(struct soap *soap, struct wprt__ActiveConditionTableType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDeviceCondition = 0;
	a->DeviceCondition = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ActiveConditionTableType(struct soap *soap, const struct wprt__ActiveConditionTableType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ActiveConditionTableType);
	if (soap_out_wprt__ActiveConditionTableType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ActiveConditionTableType(struct soap *soap, const char *tag, int id, const struct wprt__ActiveConditionTableType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ActiveConditionTableType), type);
	if (a->DeviceCondition)
	{	int i;
		for (i = 0; i < a->__sizeDeviceCondition; i++)
			soap_out_wprt__DeviceConditionType(soap, "wprt:DeviceCondition", -1, a->DeviceCondition + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ActiveConditionTableType * SOAP_FMAC4 soap_get_wprt__ActiveConditionTableType(struct soap *soap, struct wprt__ActiveConditionTableType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ActiveConditionTableType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ActiveConditionTableType * SOAP_FMAC4 soap_in_wprt__ActiveConditionTableType(struct soap *soap, const char *tag, struct wprt__ActiveConditionTableType *a, const char *type)
{
	short soap_flag_DeviceCondition = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ActiveConditionTableType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ActiveConditionTableType, sizeof(struct wprt__ActiveConditionTableType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ActiveConditionTableType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceCondition && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__DeviceConditionType *p;
				soap_new_block(soap);
				for (a->__sizeDeviceCondition = 0; !soap_element_begin_in(soap, "DeviceCondition", 1, NULL); a->__sizeDeviceCondition++)
				{	p = (struct wprt__DeviceConditionType *)soap_push_block(soap, sizeof(struct wprt__DeviceConditionType));
					soap_default_wprt__DeviceConditionType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__DeviceConditionType(soap, "DeviceCondition", p, "wprt:DeviceConditionType"))
						break;
					soap_flag_DeviceCondition = 0;
				}
				a->DeviceCondition = (struct wprt__DeviceConditionType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_DeviceCondition && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ActiveConditionTableType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ActiveConditionTableType, 0, sizeof(struct wprt__ActiveConditionTableType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__OutputBinsType(struct soap *soap, const struct wprt__OutputBinsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->OutputBinEntry)
	{	int i;
		for (i = 0; i < a->__sizeOutputBinEntry; i++)
		{
			soap_embedded(soap, a->OutputBinEntry + i, SOAP_TYPE_wprt__OutputBinEntryType);
			soap_serialize_wprt__OutputBinEntryType(soap, a->OutputBinEntry + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__OutputBinsType(struct soap *soap, struct wprt__OutputBinsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOutputBinEntry = 0;
	a->OutputBinEntry = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__OutputBinsType(struct soap *soap, const struct wprt__OutputBinsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__OutputBinsType);
	if (soap_out_wprt__OutputBinsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__OutputBinsType(struct soap *soap, const char *tag, int id, const struct wprt__OutputBinsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__OutputBinsType), type);
	if (a->OutputBinEntry)
	{	int i;
		for (i = 0; i < a->__sizeOutputBinEntry; i++)
			soap_out_wprt__OutputBinEntryType(soap, "wprt:OutputBinEntry", -1, a->OutputBinEntry + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__OutputBinsType * SOAP_FMAC4 soap_get_wprt__OutputBinsType(struct soap *soap, struct wprt__OutputBinsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__OutputBinsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__OutputBinsType * SOAP_FMAC4 soap_in_wprt__OutputBinsType(struct soap *soap, const char *tag, struct wprt__OutputBinsType *a, const char *type)
{
	short soap_flag_OutputBinEntry = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__OutputBinsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__OutputBinsType, sizeof(struct wprt__OutputBinsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__OutputBinsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OutputBinEntry && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__OutputBinEntryType *p;
				soap_new_block(soap);
				for (a->__sizeOutputBinEntry = 0; !soap_element_begin_in(soap, "OutputBinEntry", 1, NULL); a->__sizeOutputBinEntry++)
				{	p = (struct wprt__OutputBinEntryType *)soap_push_block(soap, sizeof(struct wprt__OutputBinEntryType));
					soap_default_wprt__OutputBinEntryType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__OutputBinEntryType(soap, "OutputBinEntry", p, "wprt:OutputBinEntryType"))
						break;
					soap_flag_OutputBinEntry = 0;
				}
				a->OutputBinEntry = (struct wprt__OutputBinEntryType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_OutputBinEntry && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__OutputBinsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__OutputBinsType, 0, sizeof(struct wprt__OutputBinsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinsType(struct soap *soap, const struct wprt__InputBinsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->InputBinEntry)
	{	int i;
		for (i = 0; i < a->__sizeInputBinEntry; i++)
		{
			soap_embedded(soap, a->InputBinEntry + i, SOAP_TYPE_wprt__InputBinEntryType);
			soap_serialize_wprt__InputBinEntryType(soap, a->InputBinEntry + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinsType(struct soap *soap, struct wprt__InputBinsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeInputBinEntry = 0;
	a->InputBinEntry = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinsType(struct soap *soap, const struct wprt__InputBinsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinsType);
	if (soap_out_wprt__InputBinsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinsType(struct soap *soap, const char *tag, int id, const struct wprt__InputBinsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__InputBinsType), type);
	if (a->InputBinEntry)
	{	int i;
		for (i = 0; i < a->__sizeInputBinEntry; i++)
			soap_out_wprt__InputBinEntryType(soap, "wprt:InputBinEntry", -1, a->InputBinEntry + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__InputBinsType * SOAP_FMAC4 soap_get_wprt__InputBinsType(struct soap *soap, struct wprt__InputBinsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinsType * SOAP_FMAC4 soap_in_wprt__InputBinsType(struct soap *soap, const char *tag, struct wprt__InputBinsType *a, const char *type)
{
	short soap_flag_InputBinEntry = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__InputBinsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__InputBinsType, sizeof(struct wprt__InputBinsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__InputBinsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputBinEntry && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__InputBinEntryType *p;
				soap_new_block(soap);
				for (a->__sizeInputBinEntry = 0; !soap_element_begin_in(soap, "InputBinEntry", 1, NULL); a->__sizeInputBinEntry++)
				{	p = (struct wprt__InputBinEntryType *)soap_push_block(soap, sizeof(struct wprt__InputBinEntryType));
					soap_default_wprt__InputBinEntryType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__InputBinEntryType(soap, "InputBinEntry", p, "wprt:InputBinEntryType"))
						break;
					soap_flag_InputBinEntry = 0;
				}
				a->InputBinEntry = (struct wprt__InputBinEntryType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_InputBinEntry && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__InputBinsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__InputBinsType, 0, sizeof(struct wprt__InputBinsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConsumablesType(struct soap *soap, const struct wprt__ConsumablesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ConsumableEntry)
	{	int i;
		for (i = 0; i < a->__sizeConsumableEntry; i++)
		{
			soap_embedded(soap, a->ConsumableEntry + i, SOAP_TYPE_wprt__ConsumableEntryType);
			soap_serialize_wprt__ConsumableEntryType(soap, a->ConsumableEntry + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConsumablesType(struct soap *soap, struct wprt__ConsumablesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConsumableEntry = 0;
	a->ConsumableEntry = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConsumablesType(struct soap *soap, const struct wprt__ConsumablesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConsumablesType);
	if (soap_out_wprt__ConsumablesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConsumablesType(struct soap *soap, const char *tag, int id, const struct wprt__ConsumablesType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ConsumablesType), type);
	if (a->ConsumableEntry)
	{	int i;
		for (i = 0; i < a->__sizeConsumableEntry; i++)
			soap_out_wprt__ConsumableEntryType(soap, "wprt:ConsumableEntry", -1, a->ConsumableEntry + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ConsumablesType * SOAP_FMAC4 soap_get_wprt__ConsumablesType(struct soap *soap, struct wprt__ConsumablesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConsumablesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConsumablesType * SOAP_FMAC4 soap_in_wprt__ConsumablesType(struct soap *soap, const char *tag, struct wprt__ConsumablesType *a, const char *type)
{
	short soap_flag_ConsumableEntry = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ConsumablesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConsumablesType, sizeof(struct wprt__ConsumablesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ConsumablesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumableEntry && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__ConsumableEntryType *p;
				soap_new_block(soap);
				for (a->__sizeConsumableEntry = 0; !soap_element_begin_in(soap, "ConsumableEntry", 1, NULL); a->__sizeConsumableEntry++)
				{	p = (struct wprt__ConsumableEntryType *)soap_push_block(soap, sizeof(struct wprt__ConsumableEntryType));
					soap_default_wprt__ConsumableEntryType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__ConsumableEntryType(soap, "ConsumableEntry", p, "wprt:ConsumableEntryType"))
						break;
					soap_flag_ConsumableEntry = 0;
				}
				a->ConsumableEntry = (struct wprt__ConsumableEntryType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ConsumableEntry && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ConsumablesType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ConsumablesType, 0, sizeof(struct wprt__ConsumablesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StorageBaseType(struct soap *soap, const struct wprt__StorageBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->StorageEntry)
	{	int i;
		for (i = 0; i < a->__sizeStorageEntry; i++)
		{
			soap_embedded(soap, a->StorageEntry + i, SOAP_TYPE_wprt__StorageEntryType);
			soap_serialize_wprt__StorageEntryType(soap, a->StorageEntry + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StorageBaseType(struct soap *soap, struct wprt__StorageBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeStorageEntry = 0;
	a->StorageEntry = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StorageBaseType(struct soap *soap, const struct wprt__StorageBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StorageBaseType);
	if (soap_out_wprt__StorageBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StorageBaseType(struct soap *soap, const char *tag, int id, const struct wprt__StorageBaseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__StorageBaseType), type);
	if (a->StorageEntry)
	{	int i;
		for (i = 0; i < a->__sizeStorageEntry; i++)
			soap_out_wprt__StorageEntryType(soap, "wprt:StorageEntry", -1, a->StorageEntry + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__StorageBaseType * SOAP_FMAC4 soap_get_wprt__StorageBaseType(struct soap *soap, struct wprt__StorageBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StorageBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StorageBaseType * SOAP_FMAC4 soap_in_wprt__StorageBaseType(struct soap *soap, const char *tag, struct wprt__StorageBaseType *a, const char *type)
{
	short soap_flag_StorageEntry = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__StorageBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StorageBaseType, sizeof(struct wprt__StorageBaseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__StorageBaseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageEntry && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__StorageEntryType *p;
				soap_new_block(soap);
				for (a->__sizeStorageEntry = 0; !soap_element_begin_in(soap, "StorageEntry", 1, NULL); a->__sizeStorageEntry++)
				{	p = (struct wprt__StorageEntryType *)soap_push_block(soap, sizeof(struct wprt__StorageEntryType));
					soap_default_wprt__StorageEntryType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__StorageEntryType(soap, "StorageEntry", p, "wprt:StorageEntryType"))
						break;
					soap_flag_StorageEntry = 0;
				}
				a->StorageEntry = (struct wprt__StorageEntryType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_StorageEntry && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__StorageBaseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__StorageBaseType, 0, sizeof(struct wprt__StorageBaseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__LocalizedStringType(struct soap *soap, const struct wprt__LocalizedStringType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__LocalizedStringRestrictType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__LocalizedStringType(struct soap *soap, struct wprt__LocalizedStringType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__LocalizedStringRestrictType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__LocalizedStringType(struct soap *soap, const struct wprt__LocalizedStringType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__LocalizedStringType);
	if (soap_out_wprt__LocalizedStringType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__LocalizedStringType(struct soap *soap, const char *tag, int id, const struct wprt__LocalizedStringType *a, const char *type)
{
	return soap_out_wprt__LocalizedStringRestrictType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__LocalizedStringType * SOAP_FMAC4 soap_get_wprt__LocalizedStringType(struct soap *soap, struct wprt__LocalizedStringType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__LocalizedStringType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__LocalizedStringType * SOAP_FMAC4 soap_in_wprt__LocalizedStringType(struct soap *soap, const char *tag, struct wprt__LocalizedStringType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__LocalizedStringType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__LocalizedStringType, sizeof(struct wprt__LocalizedStringType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__LocalizedStringType(soap, a);
	if (!soap_in_wprt__LocalizedStringRestrictType(soap, tag, &a->__item, "wprt:LocalizedStringType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DeviceIdType(struct soap *soap, const struct wprt__DeviceIdType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__DeviceIdBaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DeviceIdType(struct soap *soap, struct wprt__DeviceIdType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__DeviceIdBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DeviceIdType(struct soap *soap, const struct wprt__DeviceIdType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DeviceIdType);
	if (soap_out_wprt__DeviceIdType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DeviceIdType(struct soap *soap, const char *tag, int id, const struct wprt__DeviceIdType *a, const char *type)
{
	return soap_out_wprt__DeviceIdBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__DeviceIdType * SOAP_FMAC4 soap_get_wprt__DeviceIdType(struct soap *soap, struct wprt__DeviceIdType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DeviceIdType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DeviceIdType * SOAP_FMAC4 soap_in_wprt__DeviceIdType(struct soap *soap, const char *tag, struct wprt__DeviceIdType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__DeviceIdType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DeviceIdType, sizeof(struct wprt__DeviceIdType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__DeviceIdType(soap, a);
	if (!soap_in_wprt__DeviceIdBaseType(soap, tag, &a->__item, "wprt:DeviceIdType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterStatusType(struct soap *soap, const struct wprt__PrinterStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__DateTimeExtType(soap, &a->PrinterCurrentTime);
	soap_serialize_PointerTowprt__PrinterStateType(soap, &a->PrinterState);
	soap_serialize_PointerTowprt__PrinterStateReasonType(soap, &a->PrinterPrimaryStateReason);
	soap_serialize_PointerTowprt__PrinterStateReasonsType(soap, &a->PrinterStateReasons);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->QueuedJobCount);
	soap_serialize_PointerTowprt__ActiveConditionTableType(soap, &a->ActiveCondition);
	soap_serialize_PointerTowprt__ConditionHistoryTableType(soap, &a->ConditionHistory);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStatusType(struct soap *soap, struct wprt__PrinterStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PrinterCurrentTime = NULL;
	a->PrinterState = NULL;
	a->PrinterPrimaryStateReason = NULL;
	a->PrinterStateReasons = NULL;
	a->QueuedJobCount = NULL;
	a->ActiveCondition = NULL;
	a->ConditionHistory = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStatusType(struct soap *soap, const struct wprt__PrinterStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStatusType);
	if (soap_out_wprt__PrinterStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStatusType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterStatusType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterStatusType), type);
	soap_out_PointerTowprt__DateTimeExtType(soap, "wprt:PrinterCurrentTime", -1, &a->PrinterCurrentTime, "");
	soap_out_PointerTowprt__PrinterStateType(soap, "wprt:PrinterState", -1, &a->PrinterState, "");
	soap_out_PointerTowprt__PrinterStateReasonType(soap, "wprt:PrinterPrimaryStateReason", -1, &a->PrinterPrimaryStateReason, "");
	soap_out_PointerTowprt__PrinterStateReasonsType(soap, "wprt:PrinterStateReasons", -1, &a->PrinterStateReasons, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:QueuedJobCount", -1, &a->QueuedJobCount, "");
	soap_out_PointerTowprt__ActiveConditionTableType(soap, "wprt:ActiveCondition", -1, &a->ActiveCondition, "");
	soap_out_PointerTowprt__ConditionHistoryTableType(soap, "wprt:ConditionHistory", -1, &a->ConditionHistory, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterStatusType * SOAP_FMAC4 soap_get_wprt__PrinterStatusType(struct soap *soap, struct wprt__PrinterStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStatusType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStatusType * SOAP_FMAC4 soap_in_wprt__PrinterStatusType(struct soap *soap, const char *tag, struct wprt__PrinterStatusType *a, const char *type)
{
	short soap_flag_PrinterCurrentTime = 1, soap_flag_PrinterState = 1, soap_flag_PrinterPrimaryStateReason = 1, soap_flag_PrinterStateReasons = 1, soap_flag_QueuedJobCount = 1, soap_flag_ActiveCondition = 1, soap_flag_ConditionHistory = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterStatusType, sizeof(struct wprt__PrinterStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterStatusType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrinterCurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DateTimeExtType(soap, "PrinterCurrentTime", &a->PrinterCurrentTime, "wprt:DateTimeExtType"))
				{	soap_flag_PrinterCurrentTime--;
					continue;
				}
			if (soap_flag_PrinterState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStateType(soap, "PrinterState", &a->PrinterState, "wprt:PrinterStateType"))
				{	soap_flag_PrinterState--;
					continue;
				}
			if (soap_flag_PrinterPrimaryStateReason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStateReasonType(soap, "PrinterPrimaryStateReason", &a->PrinterPrimaryStateReason, "wprt:PrinterStateReasonType"))
				{	soap_flag_PrinterPrimaryStateReason--;
					continue;
				}
			if (soap_flag_PrinterStateReasons && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStateReasonsType(soap, "PrinterStateReasons", &a->PrinterStateReasons, "wprt:PrinterStateReasonsType"))
				{	soap_flag_PrinterStateReasons--;
					continue;
				}
			if (soap_flag_QueuedJobCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "QueuedJobCount", &a->QueuedJobCount, "wprt:IntZeroExtType"))
				{	soap_flag_QueuedJobCount--;
					continue;
				}
			if (soap_flag_ActiveCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ActiveConditionTableType(soap, "ActiveCondition", &a->ActiveCondition, "wprt:ActiveConditionTableType"))
				{	soap_flag_ActiveCondition--;
					continue;
				}
			if (soap_flag_ConditionHistory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConditionHistoryTableType(soap, "ConditionHistory", &a->ConditionHistory, "wprt:ConditionHistoryTableType"))
				{	soap_flag_ConditionHistory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PrinterCurrentTime > 0 || soap_flag_PrinterState > 0 || soap_flag_QueuedJobCount > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStatusType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterStatusType, 0, sizeof(struct wprt__PrinterStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterType(struct soap *soap, const struct wprt__PrinterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrinterDescriptionType(soap, &a->PrinterDescription);
	soap_serialize_PointerTowprt__PrinterConfigurationType(soap, &a->PrinterConfiguration);
	soap_serialize_PointerTowprt__PrinterStatusType(soap, &a->PrinterStatus);
	soap_serialize_PointerTowprt__PrintTicketType(soap, &a->DefaultPrintTicket);
	soap_serialize_PointerTowprt__PrinterCapabilitiesType(soap, &a->PrinterCapabilities);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterType(struct soap *soap, struct wprt__PrinterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PrinterDescription = NULL;
	a->PrinterConfiguration = NULL;
	a->PrinterStatus = NULL;
	a->DefaultPrintTicket = NULL;
	a->PrinterCapabilities = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterType(struct soap *soap, const struct wprt__PrinterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterType);
	if (soap_out_wprt__PrinterType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterType *a, const char *type)
{
	printf("%s enter\n", __FUNCTION__);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterType), type);
	soap_out_PointerTowprt__PrinterDescriptionType(soap, "wprt:PrinterDescription", -1, &a->PrinterDescription, "");
	soap_out_PointerTowprt__PrinterConfigurationType(soap, "wprt:PrinterConfiguration", -1, &a->PrinterConfiguration, "");
	soap_out_PointerTowprt__PrinterStatusType(soap, "wprt:PrinterStatus", -1, &a->PrinterStatus, "");
	soap_out_PointerTowprt__PrintTicketType(soap, "wprt:DefaultPrintTicket", -1, &a->DefaultPrintTicket, "");
	soap_out_PointerTowprt__PrinterCapabilitiesType(soap, "wprt:PrinterCapabilities", -1, &a->PrinterCapabilities, "");
	soap_element_end_out(soap, tag);
	printf("%s exit\n", __FUNCTION__);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterType * SOAP_FMAC4 soap_get_wprt__PrinterType(struct soap *soap, struct wprt__PrinterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterType * SOAP_FMAC4 soap_in_wprt__PrinterType(struct soap *soap, const char *tag, struct wprt__PrinterType *a, const char *type)
{
	short soap_flag_PrinterDescription = 1, soap_flag_PrinterConfiguration = 1, soap_flag_PrinterStatus = 1, soap_flag_DefaultPrintTicket = 1, soap_flag_PrinterCapabilities = 1;
	
	printf("%s enter\n", __FUNCTION__);
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterType, sizeof(struct wprt__PrinterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrinterDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterDescriptionType(soap, "PrinterDescription", &a->PrinterDescription, "wprt:PrinterDescriptionType"))
				{	soap_flag_PrinterDescription--;
					continue;
				}
			if (soap_flag_PrinterConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterConfigurationType(soap, "PrinterConfiguration", &a->PrinterConfiguration, "wprt:PrinterConfigurationType"))
				{	soap_flag_PrinterConfiguration--;
					continue;
				}
			if (soap_flag_PrinterStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStatusType(soap, "PrinterStatus", &a->PrinterStatus, "wprt:PrinterStatusType"))
				{	soap_flag_PrinterStatus--;
					continue;
				}
			if (soap_flag_DefaultPrintTicket && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrintTicketType(soap, "DefaultPrintTicket", &a->DefaultPrintTicket, "wprt:PrintTicketType"))
				{	soap_flag_DefaultPrintTicket--;
					continue;
				}
			if (soap_flag_PrinterCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterCapabilitiesType(soap, "PrinterCapabilities", &a->PrinterCapabilities, "wprt:PrinterCapabilitiesType"))
				{	soap_flag_PrinterCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PrinterDescription > 0 || soap_flag_PrinterConfiguration > 0 || soap_flag_PrinterStatus > 0 || soap_flag_DefaultPrintTicket > 0 || soap_flag_PrinterCapabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterType, 0, sizeof(struct wprt__PrinterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	printf("%s exit \n", __FUNCTION__);
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobElementDataType(struct soap *soap, const struct wprt__JobElementDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wprt__union_JobElementDataType(soap, a->__union_JobElementDataType, &a->union_JobElementDataType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobElementDataType(struct soap *soap, struct wprt__JobElementDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_JobElementDataType = 0;
	soap_default_xsd__QName(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->Valid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobElementDataType(struct soap *soap, const struct wprt__JobElementDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobElementDataType);
	if (soap_out_wprt__JobElementDataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobElementDataType(struct soap *soap, const char *tag, int id, const struct wprt__JobElementDataType *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_QName2s(soap, a->Name));
	soap_set_attr(soap, "Valid", soap_xsd__boolean2s(soap, a->Valid));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobElementDataType), type);
	soap_out__wprt__union_JobElementDataType(soap, a->__union_JobElementDataType, &a->union_JobElementDataType);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobElementDataType * SOAP_FMAC4 soap_get_wprt__JobElementDataType(struct soap *soap, struct wprt__JobElementDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobElementDataType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobElementDataType * SOAP_FMAC4 soap_in_wprt__JobElementDataType(struct soap *soap, const char *tag, struct wprt__JobElementDataType *a, const char *type)
{
	short soap_flag_union_JobElementDataType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobElementDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobElementDataType, sizeof(struct wprt__JobElementDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobElementDataType(soap, a);
	if (soap_s2QName(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "Valid", 1), &a->Valid))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_JobElementDataType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wprt__union_JobElementDataType(soap, &a->__union_JobElementDataType, &a->union_JobElementDataType))
				{	soap_flag_union_JobElementDataType = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_JobElementDataType))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobElementDataType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobElementDataType, 0, sizeof(struct wprt__JobElementDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__QNameExtType(struct soap *soap, const struct wprt__QNameExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__QName(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__QNameExtType(struct soap *soap, struct wprt__QNameExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__QNameExtType(struct soap *soap, const struct wprt__QNameExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__QNameExtType);
	if (soap_out_wprt__QNameExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__QNameExtType(struct soap *soap, const char *tag, int id, const struct wprt__QNameExtType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	return soap_out_xsd__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wprt__QNameExtType * SOAP_FMAC4 soap_get_wprt__QNameExtType(struct soap *soap, struct wprt__QNameExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__QNameExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__QNameExtType * SOAP_FMAC4 soap_in_wprt__QNameExtType(struct soap *soap, const char *tag, struct wprt__QNameExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__QNameExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__QNameExtType, sizeof(struct wprt__QNameExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__QNameExtType(soap, a);
	if (!soap_in_xsd__QName(soap, tag, &a->__item, "wprt:QNameExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__HolePunchPatternType(struct soap *soap, const struct wprt__HolePunchPatternType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__HolePunchPatternExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__HolePunchPatternType(struct soap *soap, struct wprt__HolePunchPatternType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__HolePunchPatternExtType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__HolePunchPatternType(struct soap *soap, const struct wprt__HolePunchPatternType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__HolePunchPatternType);
	if (soap_out_wprt__HolePunchPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__HolePunchPatternType(struct soap *soap, const char *tag, int id, const struct wprt__HolePunchPatternType *a, const char *type)
{
	return soap_out_wprt__HolePunchPatternExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__HolePunchPatternType * SOAP_FMAC4 soap_get_wprt__HolePunchPatternType(struct soap *soap, struct wprt__HolePunchPatternType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__HolePunchPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__HolePunchPatternType * SOAP_FMAC4 soap_in_wprt__HolePunchPatternType(struct soap *soap, const char *tag, struct wprt__HolePunchPatternType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__HolePunchPatternType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__HolePunchPatternType, sizeof(struct wprt__HolePunchPatternType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__HolePunchPatternType(soap, a);
	if (!soap_in_wprt__HolePunchPatternExtType(soap, tag, &a->__item, "wprt:HolePunchPatternType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__HolePunchEdgeType(struct soap *soap, const struct wprt__HolePunchEdgeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__HolePunchEdgeExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__HolePunchEdgeType(struct soap *soap, struct wprt__HolePunchEdgeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__HolePunchEdgeExtType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__HolePunchEdgeType(struct soap *soap, const struct wprt__HolePunchEdgeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__HolePunchEdgeType);
	if (soap_out_wprt__HolePunchEdgeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__HolePunchEdgeType(struct soap *soap, const char *tag, int id, const struct wprt__HolePunchEdgeType *a, const char *type)
{
	return soap_out_wprt__HolePunchEdgeExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__HolePunchEdgeType * SOAP_FMAC4 soap_get_wprt__HolePunchEdgeType(struct soap *soap, struct wprt__HolePunchEdgeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__HolePunchEdgeType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__HolePunchEdgeType * SOAP_FMAC4 soap_in_wprt__HolePunchEdgeType(struct soap *soap, const char *tag, struct wprt__HolePunchEdgeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__HolePunchEdgeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__HolePunchEdgeType, sizeof(struct wprt__HolePunchEdgeType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__HolePunchEdgeType(soap, a);
	if (!soap_in_wprt__HolePunchEdgeExtType(soap, tag, &a->__item, "wprt:HolePunchEdgeType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StapleAngleType(struct soap *soap, const struct wprt__StapleAngleType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__StapleAngleExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StapleAngleType(struct soap *soap, struct wprt__StapleAngleType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__StapleAngleExtType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StapleAngleType(struct soap *soap, const struct wprt__StapleAngleType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StapleAngleType);
	if (soap_out_wprt__StapleAngleType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StapleAngleType(struct soap *soap, const char *tag, int id, const struct wprt__StapleAngleType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__StapleAngleExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__StapleAngleType * SOAP_FMAC4 soap_get_wprt__StapleAngleType(struct soap *soap, struct wprt__StapleAngleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StapleAngleType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StapleAngleType * SOAP_FMAC4 soap_in_wprt__StapleAngleType(struct soap *soap, const char *tag, struct wprt__StapleAngleType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__StapleAngleType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StapleAngleType, sizeof(struct wprt__StapleAngleType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__StapleAngleType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__StapleAngleExtType(soap, tag, &a->__item, "wprt:StapleAngleType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StapleLocationType(struct soap *soap, const struct wprt__StapleLocationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__StapleLocationExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StapleLocationType(struct soap *soap, struct wprt__StapleLocationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__StapleLocationExtType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StapleLocationType(struct soap *soap, const struct wprt__StapleLocationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StapleLocationType);
	if (soap_out_wprt__StapleLocationType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StapleLocationType(struct soap *soap, const char *tag, int id, const struct wprt__StapleLocationType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__StapleLocationExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__StapleLocationType * SOAP_FMAC4 soap_get_wprt__StapleLocationType(struct soap *soap, struct wprt__StapleLocationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StapleLocationType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StapleLocationType * SOAP_FMAC4 soap_in_wprt__StapleLocationType(struct soap *soap, const char *tag, struct wprt__StapleLocationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__StapleLocationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StapleLocationType, sizeof(struct wprt__StapleLocationType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__StapleLocationType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__StapleLocationExtType(soap, tag, &a->__item, "wprt:StapleLocationType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__HolePunchDetailsType(struct soap *soap, const struct wprt__HolePunchDetailsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__HolePunchEdgeType(soap, &a->Edge);
	soap_serialize_PointerTowprt__HolePunchPatternType(soap, &a->Pattern);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__HolePunchDetailsType(struct soap *soap, struct wprt__HolePunchDetailsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Edge = NULL;
	a->Pattern = NULL;
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__HolePunchDetailsType(struct soap *soap, const struct wprt__HolePunchDetailsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__HolePunchDetailsType);
	if (soap_out_wprt__HolePunchDetailsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__HolePunchDetailsType(struct soap *soap, const char *tag, int id, const struct wprt__HolePunchDetailsType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__HolePunchDetailsType), type);
	soap_out_PointerTowprt__HolePunchEdgeType(soap, "wprt:Edge", -1, &a->Edge, "");
	soap_out_PointerTowprt__HolePunchPatternType(soap, "wprt:Pattern", -1, &a->Pattern, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__HolePunchDetailsType * SOAP_FMAC4 soap_get_wprt__HolePunchDetailsType(struct soap *soap, struct wprt__HolePunchDetailsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__HolePunchDetailsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__HolePunchDetailsType * SOAP_FMAC4 soap_in_wprt__HolePunchDetailsType(struct soap *soap, const char *tag, struct wprt__HolePunchDetailsType *a, const char *type)
{
	short soap_flag_Edge = 1, soap_flag_Pattern = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__HolePunchDetailsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__HolePunchDetailsType, sizeof(struct wprt__HolePunchDetailsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__HolePunchDetailsType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Edge && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__HolePunchEdgeType(soap, "Edge", &a->Edge, "wprt:HolePunchEdgeType"))
				{	soap_flag_Edge--;
					continue;
				}
			if (soap_flag_Pattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__HolePunchPatternType(soap, "Pattern", &a->Pattern, "wprt:HolePunchPatternType"))
				{	soap_flag_Pattern--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Edge > 0 || soap_flag_Pattern > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__HolePunchDetailsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__HolePunchDetailsType, 0, sizeof(struct wprt__HolePunchDetailsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StapleDetailsType(struct soap *soap, const struct wprt__StapleDetailsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__StapleLocationType(soap, &a->Location);
	soap_serialize_PointerTowprt__StapleAngleType(soap, &a->Angle);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StapleDetailsType(struct soap *soap, struct wprt__StapleDetailsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Location = NULL;
	a->Angle = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StapleDetailsType(struct soap *soap, const struct wprt__StapleDetailsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StapleDetailsType);
	if (soap_out_wprt__StapleDetailsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StapleDetailsType(struct soap *soap, const char *tag, int id, const struct wprt__StapleDetailsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__StapleDetailsType), type);
	soap_out_PointerTowprt__StapleLocationType(soap, "wprt:Location", -1, &a->Location, "");
	soap_out_PointerTowprt__StapleAngleType(soap, "wprt:Angle", -1, &a->Angle, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__StapleDetailsType * SOAP_FMAC4 soap_get_wprt__StapleDetailsType(struct soap *soap, struct wprt__StapleDetailsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StapleDetailsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StapleDetailsType * SOAP_FMAC4 soap_in_wprt__StapleDetailsType(struct soap *soap, const char *tag, struct wprt__StapleDetailsType *a, const char *type)
{
	short soap_flag_Location = 1, soap_flag_Angle = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__StapleDetailsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StapleDetailsType, sizeof(struct wprt__StapleDetailsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__StapleDetailsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Location && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__StapleLocationType(soap, "Location", &a->Location, "wprt:StapleLocationType"))
				{	soap_flag_Location--;
					continue;
				}
			if (soap_flag_Angle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__StapleAngleType(soap, "Angle", &a->Angle, "wprt:StapleAngleType"))
				{	soap_flag_Angle--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Location > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__StapleDetailsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__StapleDetailsType, 0, sizeof(struct wprt__StapleDetailsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__BooleanExtType(struct soap *soap, const struct wprt__BooleanExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->__item, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__BooleanExtType(struct soap *soap, struct wprt__BooleanExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__BooleanExtType(struct soap *soap, const struct wprt__BooleanExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__BooleanExtType);
	if (soap_out_wprt__BooleanExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__BooleanExtType(struct soap *soap, const char *tag, int id, const struct wprt__BooleanExtType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_xsd__boolean(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__BooleanExtType * SOAP_FMAC4 soap_get_wprt__BooleanExtType(struct soap *soap, struct wprt__BooleanExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__BooleanExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__BooleanExtType * SOAP_FMAC4 soap_in_wprt__BooleanExtType(struct soap *soap, const char *tag, struct wprt__BooleanExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__BooleanExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__BooleanExtType, sizeof(struct wprt__BooleanExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__BooleanExtType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_xsd__boolean(soap, tag, &a->__item, "wprt:BooleanExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobPriorityType(struct soap *soap, const struct wprt__JobPriorityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobPriorityType(struct soap *soap, struct wprt__JobPriorityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__JobPriorityRestrictionType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobPriorityType(struct soap *soap, const struct wprt__JobPriorityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobPriorityType);
	if (soap_out_wprt__JobPriorityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobPriorityType(struct soap *soap, const char *tag, int id, const struct wprt__JobPriorityType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__JobPriorityRestrictionType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__JobPriorityType * SOAP_FMAC4 soap_get_wprt__JobPriorityType(struct soap *soap, struct wprt__JobPriorityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobPriorityType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobPriorityType * SOAP_FMAC4 soap_in_wprt__JobPriorityType(struct soap *soap, const char *tag, struct wprt__JobPriorityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__JobPriorityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobPriorityType, sizeof(struct wprt__JobPriorityType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__JobPriorityType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__JobPriorityRestrictionType(soap, tag, &a->__item, "wprt:JobPriorityType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobFinishingsType(struct soap *soap, const struct wprt__JobFinishingsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__BooleanExtType(soap, &a->Collate);
	soap_serialize_PointerTowprt__BooleanExtType(soap, &a->JogOffset);
	soap_serialize_PointerTowprt__StapleDetailsType(soap, &a->Staple);
	soap_serialize_PointerTowprt__HolePunchDetailsType(soap, &a->HolePunch);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobFinishingsType(struct soap *soap, struct wprt__JobFinishingsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Collate = NULL;
	a->JogOffset = NULL;
	a->Staple = NULL;
	a->HolePunch = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobFinishingsType(struct soap *soap, const struct wprt__JobFinishingsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobFinishingsType);
	if (soap_out_wprt__JobFinishingsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobFinishingsType(struct soap *soap, const char *tag, int id, const struct wprt__JobFinishingsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobFinishingsType), type);
	soap_out_PointerTowprt__BooleanExtType(soap, "wprt:Collate", -1, &a->Collate, "");
	soap_out_PointerTowprt__BooleanExtType(soap, "wprt:JogOffset", -1, &a->JogOffset, "");
	soap_out_PointerTowprt__StapleDetailsType(soap, "wprt:Staple", -1, &a->Staple, "");
	soap_out_PointerTowprt__HolePunchDetailsType(soap, "wprt:HolePunch", -1, &a->HolePunch, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobFinishingsType * SOAP_FMAC4 soap_get_wprt__JobFinishingsType(struct soap *soap, struct wprt__JobFinishingsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobFinishingsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobFinishingsType * SOAP_FMAC4 soap_in_wprt__JobFinishingsType(struct soap *soap, const char *tag, struct wprt__JobFinishingsType *a, const char *type)
{
	short soap_flag_Collate = 1, soap_flag_JogOffset = 1, soap_flag_Staple = 1, soap_flag_HolePunch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobFinishingsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobFinishingsType, sizeof(struct wprt__JobFinishingsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobFinishingsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BooleanExtType(soap, "Collate", &a->Collate, "wprt:BooleanExtType"))
				{	soap_flag_Collate--;
					continue;
				}
			if (soap_flag_JogOffset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BooleanExtType(soap, "JogOffset", &a->JogOffset, "wprt:BooleanExtType"))
				{	soap_flag_JogOffset--;
					continue;
				}
			if (soap_flag_Staple && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__StapleDetailsType(soap, "Staple", &a->Staple, "wprt:StapleDetailsType"))
				{	soap_flag_Staple--;
					continue;
				}
			if (soap_flag_HolePunch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__HolePunchDetailsType(soap, "HolePunch", &a->HolePunch, "wprt:HolePunchDetailsType"))
				{	soap_flag_HolePunch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobFinishingsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobFinishingsType, 0, sizeof(struct wprt__JobFinishingsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobCopiesType(struct soap *soap, const struct wprt__JobCopiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobCopiesType(struct soap *soap, struct wprt__JobCopiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__JobCopiesRestrictionType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobCopiesType(struct soap *soap, const struct wprt__JobCopiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobCopiesType);
	if (soap_out_wprt__JobCopiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobCopiesType(struct soap *soap, const char *tag, int id, const struct wprt__JobCopiesType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__JobCopiesRestrictionType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__JobCopiesType * SOAP_FMAC4 soap_get_wprt__JobCopiesType(struct soap *soap, struct wprt__JobCopiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobCopiesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobCopiesType * SOAP_FMAC4 soap_in_wprt__JobCopiesType(struct soap *soap, const char *tag, struct wprt__JobCopiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__JobCopiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobCopiesType, sizeof(struct wprt__JobCopiesType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__JobCopiesType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__JobCopiesRestrictionType(soap, tag, &a->__item, "wprt:JobCopiesType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobProcessingType(struct soap *soap, const struct wprt__JobProcessingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobCopiesType(soap, &a->Copies);
	soap_serialize_PointerTowprt__JobFinishingsType(soap, &a->JobFinishings);
	soap_serialize_PointerTowprt__JobPriorityType(soap, &a->Priority);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobProcessingType(struct soap *soap, struct wprt__JobProcessingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Copies = NULL;
	a->JobFinishings = NULL;
	a->Priority = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobProcessingType(struct soap *soap, const struct wprt__JobProcessingType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobProcessingType);
	if (soap_out_wprt__JobProcessingType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobProcessingType(struct soap *soap, const char *tag, int id, const struct wprt__JobProcessingType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobProcessingType), type);
	soap_out_PointerTowprt__JobCopiesType(soap, "wprt:Copies", -1, &a->Copies, "");
	soap_out_PointerTowprt__JobFinishingsType(soap, "wprt:JobFinishings", -1, &a->JobFinishings, "");
	soap_out_PointerTowprt__JobPriorityType(soap, "wprt:Priority", -1, &a->Priority, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobProcessingType * SOAP_FMAC4 soap_get_wprt__JobProcessingType(struct soap *soap, struct wprt__JobProcessingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobProcessingType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobProcessingType * SOAP_FMAC4 soap_in_wprt__JobProcessingType(struct soap *soap, const char *tag, struct wprt__JobProcessingType *a, const char *type)
{
	short soap_flag_Copies = 1, soap_flag_JobFinishings = 1, soap_flag_Priority = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobProcessingType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobProcessingType, sizeof(struct wprt__JobProcessingType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobProcessingType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Copies && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobCopiesType(soap, "Copies", &a->Copies, "wprt:JobCopiesType"))
				{	soap_flag_Copies--;
					continue;
				}
			if (soap_flag_JobFinishings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobFinishingsType(soap, "JobFinishings", &a->JobFinishings, "wprt:JobFinishingsType"))
				{	soap_flag_JobFinishings--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobPriorityType(soap, "Priority", &a->Priority, "wprt:JobPriorityType"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobProcessingType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobProcessingType, 0, sizeof(struct wprt__JobProcessingType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobDescriptionType(struct soap *soap, const struct wprt__JobDescriptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobNameType(soap, &a->JobName);
	soap_serialize_PointerTowprt__JobOriginatingUserNameType(soap, &a->JobOriginatingUserName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobDescriptionType(struct soap *soap, struct wprt__JobDescriptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobName = NULL;
	a->JobOriginatingUserName = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobDescriptionType(struct soap *soap, const struct wprt__JobDescriptionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobDescriptionType);
	if (soap_out_wprt__JobDescriptionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobDescriptionType(struct soap *soap, const char *tag, int id, const struct wprt__JobDescriptionType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobDescriptionType), type);
	soap_out_PointerTowprt__JobNameType(soap, "wprt:JobName", -1, &a->JobName, "");
	soap_out_PointerTowprt__JobOriginatingUserNameType(soap, "wprt:JobOriginatingUserName", -1, &a->JobOriginatingUserName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobDescriptionType * SOAP_FMAC4 soap_get_wprt__JobDescriptionType(struct soap *soap, struct wprt__JobDescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobDescriptionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobDescriptionType * SOAP_FMAC4 soap_in_wprt__JobDescriptionType(struct soap *soap, const char *tag, struct wprt__JobDescriptionType *a, const char *type)
{
	short soap_flag_JobName = 1, soap_flag_JobOriginatingUserName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobDescriptionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobDescriptionType, sizeof(struct wprt__JobDescriptionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobDescriptionType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobNameType(soap, "JobName", &a->JobName, "wprt:JobNameType"))
				{	soap_flag_JobName--;
					continue;
				}
			if (soap_flag_JobOriginatingUserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobOriginatingUserNameType(soap, "JobOriginatingUserName", &a->JobOriginatingUserName, "wprt:JobOriginatingUserNameType"))
				{	soap_flag_JobOriginatingUserName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobName > 0 || soap_flag_JobOriginatingUserName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobDescriptionType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobDescriptionType, 0, sizeof(struct wprt__JobDescriptionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobStateReasonType(struct soap *soap, const struct wprt__JobStateReasonType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__JobStateReasonExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobStateReasonType(struct soap *soap, struct wprt__JobStateReasonType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__JobStateReasonExtType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobStateReasonType(struct soap *soap, const struct wprt__JobStateReasonType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobStateReasonType);
	if (soap_out_wprt__JobStateReasonType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobStateReasonType(struct soap *soap, const char *tag, int id, const struct wprt__JobStateReasonType *a, const char *type)
{
	return soap_out_wprt__JobStateReasonExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__JobStateReasonType * SOAP_FMAC4 soap_get_wprt__JobStateReasonType(struct soap *soap, struct wprt__JobStateReasonType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobStateReasonType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStateReasonType * SOAP_FMAC4 soap_in_wprt__JobStateReasonType(struct soap *soap, const char *tag, struct wprt__JobStateReasonType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__JobStateReasonType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobStateReasonType, sizeof(struct wprt__JobStateReasonType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__JobStateReasonType(soap, a);
	if (!soap_in_wprt__JobStateReasonExtType(soap, tag, &a->__item, "wprt:JobStateReasonType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobSummaryType(struct soap *soap, const struct wprt__JobSummaryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobIdType(soap, &a->JobId);
	soap_serialize_PointerTowprt__JobStateType(soap, &a->JobState);
	soap_serialize_PointerTowprt__JobStateReasonsType(soap, &a->JobStateReasons);
	soap_serialize_PointerTowprt__JobNameType(soap, &a->JobName);
	soap_serialize_PointerTowprt__JobOriginatingUserNameType(soap, &a->JobOriginatingUserName);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->KOctetsProcessed);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->MediaSheetsCompleted);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->NumberOfDocuments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobSummaryType(struct soap *soap, struct wprt__JobSummaryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobId = NULL;
	a->JobState = NULL;
	a->JobStateReasons = NULL;
	a->JobName = NULL;
	a->JobOriginatingUserName = NULL;
	a->KOctetsProcessed = NULL;
	a->MediaSheetsCompleted = NULL;
	a->NumberOfDocuments = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobSummaryType(struct soap *soap, const struct wprt__JobSummaryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobSummaryType);
	if (soap_out_wprt__JobSummaryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobSummaryType(struct soap *soap, const char *tag, int id, const struct wprt__JobSummaryType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobSummaryType), type);
	soap_out_PointerTowprt__JobIdType(soap, "wprt:JobId", -1, &a->JobId, "");
	soap_out_PointerTowprt__JobStateType(soap, "wprt:JobState", -1, &a->JobState, "");
	soap_out_PointerTowprt__JobStateReasonsType(soap, "wprt:JobStateReasons", -1, &a->JobStateReasons, "");
	soap_out_PointerTowprt__JobNameType(soap, "wprt:JobName", -1, &a->JobName, "");
	soap_out_PointerTowprt__JobOriginatingUserNameType(soap, "wprt:JobOriginatingUserName", -1, &a->JobOriginatingUserName, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:KOctetsProcessed", -1, &a->KOctetsProcessed, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:MediaSheetsCompleted", -1, &a->MediaSheetsCompleted, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:NumberOfDocuments", -1, &a->NumberOfDocuments, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobSummaryType * SOAP_FMAC4 soap_get_wprt__JobSummaryType(struct soap *soap, struct wprt__JobSummaryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobSummaryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobSummaryType * SOAP_FMAC4 soap_in_wprt__JobSummaryType(struct soap *soap, const char *tag, struct wprt__JobSummaryType *a, const char *type)
{
	short soap_flag_JobId = 1, soap_flag_JobState = 1, soap_flag_JobStateReasons = 1, soap_flag_JobName = 1, soap_flag_JobOriginatingUserName = 1, soap_flag_KOctetsProcessed = 1, soap_flag_MediaSheetsCompleted = 1, soap_flag_NumberOfDocuments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobSummaryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobSummaryType, sizeof(struct wprt__JobSummaryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobSummaryType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobIdType(soap, "JobId", &a->JobId, "wprt:JobIdType"))
				{	soap_flag_JobId--;
					continue;
				}
			if (soap_flag_JobState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobStateType(soap, "JobState", &a->JobState, "wprt:JobStateType"))
				{	soap_flag_JobState--;
					continue;
				}
			if (soap_flag_JobStateReasons && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobStateReasonsType(soap, "JobStateReasons", &a->JobStateReasons, "wprt:JobStateReasonsType"))
				{	soap_flag_JobStateReasons--;
					continue;
				}
			if (soap_flag_JobName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobNameType(soap, "JobName", &a->JobName, "wprt:JobNameType"))
				{	soap_flag_JobName--;
					continue;
				}
			if (soap_flag_JobOriginatingUserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobOriginatingUserNameType(soap, "JobOriginatingUserName", &a->JobOriginatingUserName, "wprt:JobOriginatingUserNameType"))
				{	soap_flag_JobOriginatingUserName--;
					continue;
				}
			if (soap_flag_KOctetsProcessed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "KOctetsProcessed", &a->KOctetsProcessed, "wprt:IntZeroExtType"))
				{	soap_flag_KOctetsProcessed--;
					continue;
				}
			if (soap_flag_MediaSheetsCompleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "MediaSheetsCompleted", &a->MediaSheetsCompleted, "wprt:IntZeroExtType"))
				{	soap_flag_MediaSheetsCompleted--;
					continue;
				}
			if (soap_flag_NumberOfDocuments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "NumberOfDocuments", &a->NumberOfDocuments, "wprt:IntZeroExtType"))
				{	soap_flag_NumberOfDocuments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobId > 0 || soap_flag_JobState > 0 || soap_flag_JobName > 0 || soap_flag_JobOriginatingUserName > 0 || soap_flag_KOctetsProcessed > 0 || soap_flag_MediaSheetsCompleted > 0 || soap_flag_NumberOfDocuments > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobSummaryType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobSummaryType, 0, sizeof(struct wprt__JobSummaryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobType(struct soap *soap, const struct wprt__JobType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobStatusType(soap, &a->JobStatus);
	soap_serialize_PointerTowprt__PrintTicketType(soap, &a->PrintTicket);
	soap_serialize_PointerTowprt__DocumentsType(soap, &a->Documents);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobType(struct soap *soap, struct wprt__JobType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobStatus = NULL;
	a->PrintTicket = NULL;
	a->Documents = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobType(struct soap *soap, const struct wprt__JobType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobType);
	if (soap_out_wprt__JobType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobType(struct soap *soap, const char *tag, int id, const struct wprt__JobType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobType), type);
	soap_out_PointerTowprt__JobStatusType(soap, "wprt:JobStatus", -1, &a->JobStatus, "");
	soap_out_PointerTowprt__PrintTicketType(soap, "wprt:PrintTicket", -1, &a->PrintTicket, "");
	soap_out_PointerTowprt__DocumentsType(soap, "wprt:Documents", -1, &a->Documents, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobType * SOAP_FMAC4 soap_get_wprt__JobType(struct soap *soap, struct wprt__JobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobType * SOAP_FMAC4 soap_in_wprt__JobType(struct soap *soap, const char *tag, struct wprt__JobType *a, const char *type)
{
	short soap_flag_JobStatus = 1, soap_flag_PrintTicket = 1, soap_flag_Documents = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobType, sizeof(struct wprt__JobType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobStatusType(soap, "JobStatus", &a->JobStatus, "wprt:JobStatusType"))
				{	soap_flag_JobStatus--;
					continue;
				}
			if (soap_flag_PrintTicket && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrintTicketType(soap, "PrintTicket", &a->PrintTicket, "wprt:PrintTicketType"))
				{	soap_flag_PrintTicket--;
					continue;
				}
			if (soap_flag_Documents && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentsType(soap, "Documents", &a->Documents, "wprt:DocumentsType"))
				{	soap_flag_Documents--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobStatus > 0 || soap_flag_PrintTicket > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobType, 0, sizeof(struct wprt__JobType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ListOfJobsType(struct soap *soap, const struct wprt__ListOfJobsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Job)
	{	int i;
		for (i = 0; i < a->__sizeJob; i++)
		{
			soap_embedded(soap, a->Job + i, SOAP_TYPE_wprt__JobType);
			soap_serialize_wprt__JobType(soap, a->Job + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ListOfJobsType(struct soap *soap, struct wprt__ListOfJobsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeJob = 0;
	a->Job = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ListOfJobsType(struct soap *soap, const struct wprt__ListOfJobsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ListOfJobsType);
	if (soap_out_wprt__ListOfJobsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ListOfJobsType(struct soap *soap, const char *tag, int id, const struct wprt__ListOfJobsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ListOfJobsType), type);
	if (a->Job)
	{	int i;
		for (i = 0; i < a->__sizeJob; i++)
			soap_out_wprt__JobType(soap, "wprt:Job", -1, a->Job + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ListOfJobsType * SOAP_FMAC4 soap_get_wprt__ListOfJobsType(struct soap *soap, struct wprt__ListOfJobsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ListOfJobsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ListOfJobsType * SOAP_FMAC4 soap_in_wprt__ListOfJobsType(struct soap *soap, const char *tag, struct wprt__ListOfJobsType *a, const char *type)
{
	short soap_flag_Job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ListOfJobsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ListOfJobsType, sizeof(struct wprt__ListOfJobsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ListOfJobsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Job && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__JobType *p;
				soap_new_block(soap);
				for (a->__sizeJob = 0; !soap_element_begin_in(soap, "Job", 1, NULL); a->__sizeJob++)
				{	p = (struct wprt__JobType *)soap_push_block(soap, sizeof(struct wprt__JobType));
					soap_default_wprt__JobType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__JobType(soap, "Job", p, "wprt:JobType"))
						break;
					soap_flag_Job = 0;
				}
				a->Job = (struct wprt__JobType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Job && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ListOfJobsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ListOfJobsType, 0, sizeof(struct wprt__ListOfJobsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobTableType(struct soap *soap, const struct wprt__JobTableType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ListOfJobsType(soap, &a->ActiveJobs);
	soap_serialize_PointerTowprt__ListOfJobsType(soap, &a->JobHistory);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobTableType(struct soap *soap, struct wprt__JobTableType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActiveJobs = NULL;
	a->JobHistory = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobTableType(struct soap *soap, const struct wprt__JobTableType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobTableType);
	if (soap_out_wprt__JobTableType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobTableType(struct soap *soap, const char *tag, int id, const struct wprt__JobTableType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobTableType), type);
	soap_out_PointerTowprt__ListOfJobsType(soap, "wprt:ActiveJobs", -1, &a->ActiveJobs, "");
	soap_out_PointerTowprt__ListOfJobsType(soap, "wprt:JobHistory", -1, &a->JobHistory, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobTableType * SOAP_FMAC4 soap_get_wprt__JobTableType(struct soap *soap, struct wprt__JobTableType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobTableType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobTableType * SOAP_FMAC4 soap_in_wprt__JobTableType(struct soap *soap, const char *tag, struct wprt__JobTableType *a, const char *type)
{
	short soap_flag_ActiveJobs = 1, soap_flag_JobHistory = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobTableType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobTableType, sizeof(struct wprt__JobTableType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobTableType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActiveJobs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ListOfJobsType(soap, "ActiveJobs", &a->ActiveJobs, "wprt:ListOfJobsType"))
				{	soap_flag_ActiveJobs--;
					continue;
				}
			if (soap_flag_JobHistory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ListOfJobsType(soap, "JobHistory", &a->JobHistory, "wprt:ListOfJobsType"))
				{	soap_flag_JobHistory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActiveJobs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobTableType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobTableType, 0, sizeof(struct wprt__JobTableType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__NUpDirectionType(struct soap *soap, const struct wprt__NUpDirectionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__NUpDirectionType(struct soap *soap, struct wprt__NUpDirectionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__NUpDirectionRestrictionType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__NUpDirectionType(struct soap *soap, const struct wprt__NUpDirectionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__NUpDirectionType);
	if (soap_out_wprt__NUpDirectionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__NUpDirectionType(struct soap *soap, const char *tag, int id, const struct wprt__NUpDirectionType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__NUpDirectionRestrictionType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__NUpDirectionType * SOAP_FMAC4 soap_get_wprt__NUpDirectionType(struct soap *soap, struct wprt__NUpDirectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__NUpDirectionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__NUpDirectionType * SOAP_FMAC4 soap_in_wprt__NUpDirectionType(struct soap *soap, const char *tag, struct wprt__NUpDirectionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__NUpDirectionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__NUpDirectionType, sizeof(struct wprt__NUpDirectionType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__NUpDirectionType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__NUpDirectionRestrictionType(soap, tag, &a->__item, "wprt:NUpDirectionType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__NUpPagesPerSheetType(struct soap *soap, const struct wprt__NUpPagesPerSheetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__NUpPagesPerSheetType(struct soap *soap, struct wprt__NUpPagesPerSheetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__NUpPagesPerSheetRestrictionType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__NUpPagesPerSheetType(struct soap *soap, const struct wprt__NUpPagesPerSheetType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__NUpPagesPerSheetType);
	if (soap_out_wprt__NUpPagesPerSheetType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__NUpPagesPerSheetType(struct soap *soap, const char *tag, int id, const struct wprt__NUpPagesPerSheetType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__NUpPagesPerSheetRestrictionType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__NUpPagesPerSheetType * SOAP_FMAC4 soap_get_wprt__NUpPagesPerSheetType(struct soap *soap, struct wprt__NUpPagesPerSheetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__NUpPagesPerSheetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__NUpPagesPerSheetType * SOAP_FMAC4 soap_in_wprt__NUpPagesPerSheetType(struct soap *soap, const char *tag, struct wprt__NUpPagesPerSheetType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__NUpPagesPerSheetType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__NUpPagesPerSheetType, sizeof(struct wprt__NUpPagesPerSheetType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__NUpPagesPerSheetType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__NUpPagesPerSheetRestrictionType(soap, tag, &a->__item, "wprt:NUpPagesPerSheetType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__SidesType(struct soap *soap, const struct wprt__SidesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__SidesBaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__SidesType(struct soap *soap, struct wprt__SidesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__SidesBaseType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__SidesType(struct soap *soap, const struct wprt__SidesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__SidesType);
	if (soap_out_wprt__SidesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__SidesType(struct soap *soap, const char *tag, int id, const struct wprt__SidesType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__SidesBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__SidesType * SOAP_FMAC4 soap_get_wprt__SidesType(struct soap *soap, struct wprt__SidesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__SidesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SidesType * SOAP_FMAC4 soap_in_wprt__SidesType(struct soap *soap, const char *tag, struct wprt__SidesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__SidesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__SidesType, sizeof(struct wprt__SidesType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__SidesType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__SidesBaseType(soap, tag, &a->__item, "wprt:SidesType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrintQualityType(struct soap *soap, const struct wprt__PrintQualityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__PrintQualityBaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrintQualityType(struct soap *soap, struct wprt__PrintQualityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__PrintQualityBaseType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrintQualityType(struct soap *soap, const struct wprt__PrintQualityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrintQualityType);
	if (soap_out_wprt__PrintQualityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrintQualityType(struct soap *soap, const char *tag, int id, const struct wprt__PrintQualityType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__PrintQualityBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__PrintQualityType * SOAP_FMAC4 soap_get_wprt__PrintQualityType(struct soap *soap, struct wprt__PrintQualityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrintQualityType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrintQualityType * SOAP_FMAC4 soap_in_wprt__PrintQualityType(struct soap *soap, const char *tag, struct wprt__PrintQualityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__PrintQualityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrintQualityType, sizeof(struct wprt__PrintQualityType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__PrintQualityType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__PrintQualityBaseType(soap, tag, &a->__item, "wprt:PrintQualityType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ResolutionType(struct soap *soap, const struct wprt__ResolutionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__IntExtType(soap, &a->Width);
	soap_serialize_PointerTowprt__IntExtType(soap, &a->Height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ResolutionType(struct soap *soap, struct wprt__ResolutionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Width = NULL;
	a->Height = NULL;
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ResolutionType(struct soap *soap, const struct wprt__ResolutionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ResolutionType);
	if (soap_out_wprt__ResolutionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ResolutionType(struct soap *soap, const char *tag, int id, const struct wprt__ResolutionType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ResolutionType), type);
	soap_out_PointerTowprt__IntExtType(soap, "wprt:Width", -1, &a->Width, "");
	soap_out_PointerTowprt__IntExtType(soap, "wprt:Height", -1, &a->Height, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ResolutionType * SOAP_FMAC4 soap_get_wprt__ResolutionType(struct soap *soap, struct wprt__ResolutionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ResolutionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ResolutionType * SOAP_FMAC4 soap_in_wprt__ResolutionType(struct soap *soap, const char *tag, struct wprt__ResolutionType *a, const char *type)
{
	short soap_flag_Width = 1, soap_flag_Height = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ResolutionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ResolutionType, sizeof(struct wprt__ResolutionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ResolutionType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntExtType(soap, "Width", &a->Width, "wprt:IntExtType"))
				{	soap_flag_Width--;
					continue;
				}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntExtType(soap, "Height", &a->Height, "wprt:IntExtType"))
				{	soap_flag_Height--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ResolutionType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ResolutionType, 0, sizeof(struct wprt__ResolutionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__OrientationType(struct soap *soap, const struct wprt__OrientationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__OrientationBaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__OrientationType(struct soap *soap, struct wprt__OrientationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__OrientationBaseType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__OrientationType(struct soap *soap, const struct wprt__OrientationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__OrientationType);
	if (soap_out_wprt__OrientationType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__OrientationType(struct soap *soap, const char *tag, int id, const struct wprt__OrientationType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__OrientationBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__OrientationType * SOAP_FMAC4 soap_get_wprt__OrientationType(struct soap *soap, struct wprt__OrientationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__OrientationType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__OrientationType * SOAP_FMAC4 soap_in_wprt__OrientationType(struct soap *soap, const char *tag, struct wprt__OrientationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__OrientationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__OrientationType, sizeof(struct wprt__OrientationType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__OrientationType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__OrientationBaseType(soap, tag, &a->__item, "wprt:OrientationType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__NumberUpType(struct soap *soap, const struct wprt__NumberUpType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__NUpPagesPerSheetType(soap, &a->PagesPerSheet);
	soap_serialize_PointerTowprt__NUpDirectionType(soap, &a->Direction);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__NumberUpType(struct soap *soap, struct wprt__NumberUpType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PagesPerSheet = NULL;
	a->Direction = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__NumberUpType(struct soap *soap, const struct wprt__NumberUpType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__NumberUpType);
	if (soap_out_wprt__NumberUpType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__NumberUpType(struct soap *soap, const char *tag, int id, const struct wprt__NumberUpType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__NumberUpType), type);
	soap_out_PointerTowprt__NUpPagesPerSheetType(soap, "wprt:PagesPerSheet", -1, &a->PagesPerSheet, "");
	soap_out_PointerTowprt__NUpDirectionType(soap, "wprt:Direction", -1, &a->Direction, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__NumberUpType * SOAP_FMAC4 soap_get_wprt__NumberUpType(struct soap *soap, struct wprt__NumberUpType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__NumberUpType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__NumberUpType * SOAP_FMAC4 soap_in_wprt__NumberUpType(struct soap *soap, const char *tag, struct wprt__NumberUpType *a, const char *type)
{
	short soap_flag_PagesPerSheet = 1, soap_flag_Direction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__NumberUpType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__NumberUpType, sizeof(struct wprt__NumberUpType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__NumberUpType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PagesPerSheet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__NUpPagesPerSheetType(soap, "PagesPerSheet", &a->PagesPerSheet, "wprt:NUpPagesPerSheetType"))
				{	soap_flag_PagesPerSheet--;
					continue;
				}
			if (soap_flag_Direction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__NUpDirectionType(soap, "Direction", &a->Direction, "wprt:NUpDirectionType"))
				{	soap_flag_Direction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PagesPerSheet > 0 || soap_flag_Direction > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__NumberUpType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__NumberUpType, 0, sizeof(struct wprt__NumberUpType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaColorType(struct soap *soap, const struct wprt__MediaColorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__MediaColorExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaColorType(struct soap *soap, struct wprt__MediaColorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__MediaColorExtType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaColorType(struct soap *soap, const struct wprt__MediaColorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaColorType);
	if (soap_out_wprt__MediaColorType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaColorType(struct soap *soap, const char *tag, int id, const struct wprt__MediaColorType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__MediaColorExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__MediaColorType * SOAP_FMAC4 soap_get_wprt__MediaColorType(struct soap *soap, struct wprt__MediaColorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaColorType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__MediaColorType * SOAP_FMAC4 soap_in_wprt__MediaColorType(struct soap *soap, const char *tag, struct wprt__MediaColorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__MediaColorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__MediaColorType, sizeof(struct wprt__MediaColorType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__MediaColorType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__MediaColorExtType(soap, tag, &a->__item, "wprt:MediaColorType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaTypeBaseType(struct soap *soap, const struct wprt__MediaTypeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__MediaTypeExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaTypeBaseType(struct soap *soap, struct wprt__MediaTypeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__MediaTypeExtType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaTypeBaseType(struct soap *soap, const struct wprt__MediaTypeBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaTypeBaseType);
	if (soap_out_wprt__MediaTypeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaTypeBaseType(struct soap *soap, const char *tag, int id, const struct wprt__MediaTypeBaseType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__MediaTypeExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__MediaTypeBaseType * SOAP_FMAC4 soap_get_wprt__MediaTypeBaseType(struct soap *soap, struct wprt__MediaTypeBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaTypeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__MediaTypeBaseType * SOAP_FMAC4 soap_in_wprt__MediaTypeBaseType(struct soap *soap, const char *tag, struct wprt__MediaTypeBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__MediaTypeBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__MediaTypeBaseType, sizeof(struct wprt__MediaTypeBaseType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__MediaTypeBaseType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__MediaTypeExtType(soap, tag, &a->__item, "wprt:MediaTypeBaseType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaSizeNameType(struct soap *soap, const struct wprt__MediaSizeNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__MediaSizeNameExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaSizeNameType(struct soap *soap, struct wprt__MediaSizeNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__MediaSizeNameExtType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaSizeNameType(struct soap *soap, const struct wprt__MediaSizeNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaSizeNameType);
	if (soap_out_wprt__MediaSizeNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaSizeNameType(struct soap *soap, const char *tag, int id, const struct wprt__MediaSizeNameType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__MediaSizeNameExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__MediaSizeNameType * SOAP_FMAC4 soap_get_wprt__MediaSizeNameType(struct soap *soap, struct wprt__MediaSizeNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaSizeNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__MediaSizeNameType * SOAP_FMAC4 soap_in_wprt__MediaSizeNameType(struct soap *soap, const char *tag, struct wprt__MediaSizeNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__MediaSizeNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__MediaSizeNameType, sizeof(struct wprt__MediaSizeNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__MediaSizeNameType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__MediaSizeNameExtType(soap, tag, &a->__item, "wprt:MediaSizeNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DocumentFormatType(struct soap *soap, const struct wprt__DocumentFormatType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__DocumentFormatExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DocumentFormatType(struct soap *soap, struct wprt__DocumentFormatType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__DocumentFormatExtType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DocumentFormatType(struct soap *soap, const struct wprt__DocumentFormatType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DocumentFormatType);
	if (soap_out_wprt__DocumentFormatType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DocumentFormatType(struct soap *soap, const char *tag, int id, const struct wprt__DocumentFormatType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__DocumentFormatExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__DocumentFormatType * SOAP_FMAC4 soap_get_wprt__DocumentFormatType(struct soap *soap, struct wprt__DocumentFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DocumentFormatType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentFormatType * SOAP_FMAC4 soap_in_wprt__DocumentFormatType(struct soap *soap, const char *tag, struct wprt__DocumentFormatType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__DocumentFormatType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DocumentFormatType, sizeof(struct wprt__DocumentFormatType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__DocumentFormatType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__DocumentFormatExtType(soap, tag, &a->__item, "wprt:DocumentFormatType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__CompressionType(struct soap *soap, const struct wprt__CompressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__CompressionExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__CompressionType(struct soap *soap, struct wprt__CompressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__CompressionExtType(soap, &a->__item);
	a->MustHonor = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__CompressionType(struct soap *soap, const struct wprt__CompressionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__CompressionType);
	if (soap_out_wprt__CompressionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__CompressionType(struct soap *soap, const char *tag, int id, const struct wprt__CompressionType *a, const char *type)
{
	if (a->MustHonor)
		soap_set_attr(soap, "MustHonor", soap_xsd__boolean2s(soap, *a->MustHonor));
	return soap_out_wprt__CompressionExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__CompressionType * SOAP_FMAC4 soap_get_wprt__CompressionType(struct soap *soap, struct wprt__CompressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__CompressionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CompressionType * SOAP_FMAC4 soap_in_wprt__CompressionType(struct soap *soap, const char *tag, struct wprt__CompressionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__CompressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__CompressionType, sizeof(struct wprt__CompressionType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__CompressionType(soap, a);
	{	const char *t = soap_attr_value(soap, "MustHonor", 0);
		if (t)
		{	if (!(a->MustHonor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->MustHonor))
		return NULL;
		}
	}
	if (!soap_in_wprt__CompressionExtType(soap, tag, &a->__item, "wprt:CompressionType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DocumentsType(struct soap *soap, const struct wprt__DocumentsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Document)
	{	int i;
		for (i = 0; i < a->__sizeDocument; i++)
		{
			soap_embedded(soap, a->Document + i, SOAP_TYPE_wprt__DocumentType);
			soap_serialize_wprt__DocumentType(soap, a->Document + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DocumentsType(struct soap *soap, struct wprt__DocumentsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDocument = 0;
	a->Document = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DocumentsType(struct soap *soap, const struct wprt__DocumentsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DocumentsType);
	if (soap_out_wprt__DocumentsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DocumentsType(struct soap *soap, const char *tag, int id, const struct wprt__DocumentsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__DocumentsType), type);
	if (a->Document)
	{	int i;
		for (i = 0; i < a->__sizeDocument; i++)
			soap_out_wprt__DocumentType(soap, "wprt:Document", -1, a->Document + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__DocumentsType * SOAP_FMAC4 soap_get_wprt__DocumentsType(struct soap *soap, struct wprt__DocumentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DocumentsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentsType * SOAP_FMAC4 soap_in_wprt__DocumentsType(struct soap *soap, const char *tag, struct wprt__DocumentsType *a, const char *type)
{
	short soap_flag_Document = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__DocumentsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DocumentsType, sizeof(struct wprt__DocumentsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__DocumentsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Document && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__DocumentType *p;
				soap_new_block(soap);
				for (a->__sizeDocument = 0; !soap_element_begin_in(soap, "Document", 1, NULL); a->__sizeDocument++)
				{	p = (struct wprt__DocumentType *)soap_push_block(soap, sizeof(struct wprt__DocumentType));
					soap_default_wprt__DocumentType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__DocumentType(soap, "Document", p, "wprt:DocumentType"))
						break;
					soap_flag_Document = 0;
				}
				a->Document = (struct wprt__DocumentType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Document && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__DocumentsType, 0, sizeof(struct wprt__DocumentsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DocumentType(struct soap *soap, const struct wprt__DocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__DocumentDescriptionType(soap, &a->DocumentDescription);
	soap_serialize_PointerTowprt__DocumentProcessingType(soap, &a->DocumentProcessing);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DocumentType(struct soap *soap, struct wprt__DocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DocumentDescription = NULL;
	a->DocumentProcessing = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DocumentType(struct soap *soap, const struct wprt__DocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DocumentType);
	if (soap_out_wprt__DocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DocumentType(struct soap *soap, const char *tag, int id, const struct wprt__DocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__DocumentType), type);
	soap_out_PointerTowprt__DocumentDescriptionType(soap, "wprt:DocumentDescription", -1, &a->DocumentDescription, "");
	soap_out_PointerTowprt__DocumentProcessingType(soap, "wprt:DocumentProcessing", -1, &a->DocumentProcessing, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__DocumentType * SOAP_FMAC4 soap_get_wprt__DocumentType(struct soap *soap, struct wprt__DocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DocumentType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentType * SOAP_FMAC4 soap_in_wprt__DocumentType(struct soap *soap, const char *tag, struct wprt__DocumentType *a, const char *type)
{
	short soap_flag_DocumentDescription = 1, soap_flag_DocumentProcessing = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__DocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DocumentType, sizeof(struct wprt__DocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__DocumentType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocumentDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentDescriptionType(soap, "DocumentDescription", &a->DocumentDescription, "wprt:DocumentDescriptionType"))
				{	soap_flag_DocumentDescription--;
					continue;
				}
			if (soap_flag_DocumentProcessing && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentProcessingType(soap, "DocumentProcessing", &a->DocumentProcessing, "wprt:DocumentProcessingType"))
				{	soap_flag_DocumentProcessing--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DocumentDescription > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__DocumentType, 0, sizeof(struct wprt__DocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__OutputBinEntryType(struct soap *soap, const struct wprt__OutputBinEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__CapacityBaseType(soap, &a->Capacity);
	soap_serialize_PointerTowprt__LevelFreeBaseType(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__OutputBinEntryType(struct soap *soap, struct wprt__OutputBinEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capacity = NULL;
	a->Level = NULL;
	soap_default_wprt__OutputBinNameType(soap, &a->Name);
	a->Removed = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__OutputBinEntryType(struct soap *soap, const struct wprt__OutputBinEntryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__OutputBinEntryType);
	if (soap_out_wprt__OutputBinEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__OutputBinEntryType(struct soap *soap, const char *tag, int id, const struct wprt__OutputBinEntryType *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name);
	if (a->Removed)
		soap_set_attr(soap, "Removed", soap_xsd__boolean2s(soap, *a->Removed));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__OutputBinEntryType), type);
	soap_out_PointerTowprt__CapacityBaseType(soap, "wprt:Capacity", -1, &a->Capacity, "");
	soap_out_PointerTowprt__LevelFreeBaseType(soap, "wprt:Level", -1, &a->Level, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__OutputBinEntryType * SOAP_FMAC4 soap_get_wprt__OutputBinEntryType(struct soap *soap, struct wprt__OutputBinEntryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__OutputBinEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__OutputBinEntryType * SOAP_FMAC4 soap_in_wprt__OutputBinEntryType(struct soap *soap, const char *tag, struct wprt__OutputBinEntryType *a, const char *type)
{
	short soap_flag_Capacity = 1, soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__OutputBinEntryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__OutputBinEntryType, sizeof(struct wprt__OutputBinEntryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__OutputBinEntryType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Removed", 0);
		if (t)
		{	if (!(a->Removed = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->Removed))
		return NULL;
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capacity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__CapacityBaseType(soap, "Capacity", &a->Capacity, "wprt:CapacityBaseType"))
				{	soap_flag_Capacity--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__LevelFreeBaseType(soap, "Level", &a->Level, "wprt:LevelFreeBaseType"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capacity > 0 || soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__OutputBinEntryType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__OutputBinEntryType, 0, sizeof(struct wprt__OutputBinEntryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__FinishingsType(struct soap *soap, const struct wprt__FinishingsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__BoolExtType(soap, &a->CollationSupported);
	soap_serialize_PointerTowprt__BoolExtType(soap, &a->JogOffsetSupported);
	soap_serialize_PointerTowprt__BoolExtType(soap, &a->DuplexerInstalled);
	soap_serialize_PointerTowprt__BoolExtType(soap, &a->StaplerInstalled);
	soap_serialize_PointerTowprt__BoolExtType(soap, &a->HolePunchInstalled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__FinishingsType(struct soap *soap, struct wprt__FinishingsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CollationSupported = NULL;
	a->JogOffsetSupported = NULL;
	a->DuplexerInstalled = NULL;
	a->StaplerInstalled = NULL;
	a->HolePunchInstalled = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__FinishingsType(struct soap *soap, const struct wprt__FinishingsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__FinishingsType);
	if (soap_out_wprt__FinishingsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__FinishingsType(struct soap *soap, const char *tag, int id, const struct wprt__FinishingsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__FinishingsType), type);
	soap_out_PointerTowprt__BoolExtType(soap, "wprt:CollationSupported", -1, &a->CollationSupported, "");
	soap_out_PointerTowprt__BoolExtType(soap, "wprt:JogOffsetSupported", -1, &a->JogOffsetSupported, "");
	soap_out_PointerTowprt__BoolExtType(soap, "wprt:DuplexerInstalled", -1, &a->DuplexerInstalled, "");
	soap_out_PointerTowprt__BoolExtType(soap, "wprt:StaplerInstalled", -1, &a->StaplerInstalled, "");
	soap_out_PointerTowprt__BoolExtType(soap, "wprt:HolePunchInstalled", -1, &a->HolePunchInstalled, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__FinishingsType * SOAP_FMAC4 soap_get_wprt__FinishingsType(struct soap *soap, struct wprt__FinishingsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__FinishingsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__FinishingsType * SOAP_FMAC4 soap_in_wprt__FinishingsType(struct soap *soap, const char *tag, struct wprt__FinishingsType *a, const char *type)
{
	short soap_flag_CollationSupported = 1, soap_flag_JogOffsetSupported = 1, soap_flag_DuplexerInstalled = 1, soap_flag_StaplerInstalled = 1, soap_flag_HolePunchInstalled = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__FinishingsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__FinishingsType, sizeof(struct wprt__FinishingsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__FinishingsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CollationSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BoolExtType(soap, "CollationSupported", &a->CollationSupported, "wprt:BoolExtType"))
				{	soap_flag_CollationSupported--;
					continue;
				}
			if (soap_flag_JogOffsetSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BoolExtType(soap, "JogOffsetSupported", &a->JogOffsetSupported, "wprt:BoolExtType"))
				{	soap_flag_JogOffsetSupported--;
					continue;
				}
			if (soap_flag_DuplexerInstalled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BoolExtType(soap, "DuplexerInstalled", &a->DuplexerInstalled, "wprt:BoolExtType"))
				{	soap_flag_DuplexerInstalled--;
					continue;
				}
			if (soap_flag_StaplerInstalled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BoolExtType(soap, "StaplerInstalled", &a->StaplerInstalled, "wprt:BoolExtType"))
				{	soap_flag_StaplerInstalled--;
					continue;
				}
			if (soap_flag_HolePunchInstalled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BoolExtType(soap, "HolePunchInstalled", &a->HolePunchInstalled, "wprt:BoolExtType"))
				{	soap_flag_HolePunchInstalled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CollationSupported > 0 || soap_flag_JogOffsetSupported > 0 || soap_flag_DuplexerInstalled > 0 || soap_flag_StaplerInstalled > 0 || soap_flag_HolePunchInstalled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__FinishingsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__FinishingsType, 0, sizeof(struct wprt__FinishingsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__CapacityBaseType(struct soap *soap, const struct wprt__CapacityBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__CapacityBaseType(struct soap *soap, struct wprt__CapacityBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__CapacityRestrictType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__CapacityBaseType(struct soap *soap, const struct wprt__CapacityBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__CapacityBaseType);
	if (soap_out_wprt__CapacityBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__CapacityBaseType(struct soap *soap, const char *tag, int id, const struct wprt__CapacityBaseType *a, const char *type)
{
	return soap_out_wprt__CapacityRestrictType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__CapacityBaseType * SOAP_FMAC4 soap_get_wprt__CapacityBaseType(struct soap *soap, struct wprt__CapacityBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__CapacityBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CapacityBaseType * SOAP_FMAC4 soap_in_wprt__CapacityBaseType(struct soap *soap, const char *tag, struct wprt__CapacityBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__CapacityBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__CapacityBaseType, sizeof(struct wprt__CapacityBaseType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__CapacityBaseType(soap, a);
	if (!soap_in_wprt__CapacityRestrictType(soap, tag, &a->__item, "wprt:CapacityBaseType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinMediaColorType(struct soap *soap, const struct wprt__InputBinMediaColorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__InputBinMediaColorBaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinMediaColorType(struct soap *soap, struct wprt__InputBinMediaColorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__InputBinMediaColorBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinMediaColorType(struct soap *soap, const struct wprt__InputBinMediaColorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinMediaColorType);
	if (soap_out_wprt__InputBinMediaColorType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinMediaColorType(struct soap *soap, const char *tag, int id, const struct wprt__InputBinMediaColorType *a, const char *type)
{
	return soap_out_wprt__InputBinMediaColorBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__InputBinMediaColorType * SOAP_FMAC4 soap_get_wprt__InputBinMediaColorType(struct soap *soap, struct wprt__InputBinMediaColorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinMediaColorType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinMediaColorType * SOAP_FMAC4 soap_in_wprt__InputBinMediaColorType(struct soap *soap, const char *tag, struct wprt__InputBinMediaColorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__InputBinMediaColorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__InputBinMediaColorType, sizeof(struct wprt__InputBinMediaColorType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__InputBinMediaColorType(soap, a);
	if (!soap_in_wprt__InputBinMediaColorBaseType(soap, tag, &a->__item, "wprt:InputBinMediaColorType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinMediaTypeBaseType(struct soap *soap, const struct wprt__InputBinMediaTypeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__MediaTypeExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinMediaTypeBaseType(struct soap *soap, struct wprt__InputBinMediaTypeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__MediaTypeExtType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinMediaTypeBaseType(struct soap *soap, const struct wprt__InputBinMediaTypeBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinMediaTypeBaseType);
	if (soap_out_wprt__InputBinMediaTypeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinMediaTypeBaseType(struct soap *soap, const char *tag, int id, const struct wprt__InputBinMediaTypeBaseType *a, const char *type)
{
	return soap_out_wprt__MediaTypeExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__InputBinMediaTypeBaseType * SOAP_FMAC4 soap_get_wprt__InputBinMediaTypeBaseType(struct soap *soap, struct wprt__InputBinMediaTypeBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinMediaTypeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinMediaTypeBaseType * SOAP_FMAC4 soap_in_wprt__InputBinMediaTypeBaseType(struct soap *soap, const char *tag, struct wprt__InputBinMediaTypeBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__InputBinMediaTypeBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__InputBinMediaTypeBaseType, sizeof(struct wprt__InputBinMediaTypeBaseType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__InputBinMediaTypeBaseType(soap, a);
	if (!soap_in_wprt__MediaTypeExtType(soap, tag, &a->__item, "wprt:InputBinMediaTypeBaseType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinMediaSizeType(struct soap *soap, const struct wprt__InputBinMediaSizeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__InputBinMediaSizeBaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinMediaSizeType(struct soap *soap, struct wprt__InputBinMediaSizeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__InputBinMediaSizeBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinMediaSizeType(struct soap *soap, const struct wprt__InputBinMediaSizeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinMediaSizeType);
	if (soap_out_wprt__InputBinMediaSizeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinMediaSizeType(struct soap *soap, const char *tag, int id, const struct wprt__InputBinMediaSizeType *a, const char *type)
{
	return soap_out_wprt__InputBinMediaSizeBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__InputBinMediaSizeType * SOAP_FMAC4 soap_get_wprt__InputBinMediaSizeType(struct soap *soap, struct wprt__InputBinMediaSizeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinMediaSizeType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinMediaSizeType * SOAP_FMAC4 soap_in_wprt__InputBinMediaSizeType(struct soap *soap, const char *tag, struct wprt__InputBinMediaSizeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__InputBinMediaSizeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__InputBinMediaSizeType, sizeof(struct wprt__InputBinMediaSizeType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__InputBinMediaSizeType(soap, a);
	if (!soap_in_wprt__InputBinMediaSizeBaseType(soap, tag, &a->__item, "wprt:InputBinMediaSizeType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinFeedDirectionType(struct soap *soap, const struct wprt__InputBinFeedDirectionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinFeedDirectionType(struct soap *soap, struct wprt__InputBinFeedDirectionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__InputBinFeedDirectionBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinFeedDirectionType(struct soap *soap, const struct wprt__InputBinFeedDirectionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinFeedDirectionType);
	if (soap_out_wprt__InputBinFeedDirectionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinFeedDirectionType(struct soap *soap, const char *tag, int id, const struct wprt__InputBinFeedDirectionType *a, const char *type)
{
	return soap_out_wprt__InputBinFeedDirectionBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__InputBinFeedDirectionType * SOAP_FMAC4 soap_get_wprt__InputBinFeedDirectionType(struct soap *soap, struct wprt__InputBinFeedDirectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinFeedDirectionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinFeedDirectionType * SOAP_FMAC4 soap_in_wprt__InputBinFeedDirectionType(struct soap *soap, const char *tag, struct wprt__InputBinFeedDirectionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__InputBinFeedDirectionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__InputBinFeedDirectionType, sizeof(struct wprt__InputBinFeedDirectionType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__InputBinFeedDirectionType(soap, a);
	if (!soap_in_wprt__InputBinFeedDirectionBaseType(soap, tag, &a->__item, "wprt:InputBinFeedDirectionType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinEntryType(struct soap *soap, const struct wprt__InputBinEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__InputBinFeedDirectionType(soap, &a->FeedDirection);
	soap_serialize_PointerTowprt__InputBinMediaSizeType(soap, &a->MediaSize);
	soap_serialize_PointerTowprt__InputBinMediaTypeBaseType(soap, &a->MediaType);
	soap_serialize_PointerTowprt__InputBinMediaColorType(soap, &a->MediaColor);
	soap_serialize_PointerTowprt__CapacityBaseType(soap, &a->Capacity);
	soap_serialize_PointerTowprt__LevelFreeBaseType(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinEntryType(struct soap *soap, struct wprt__InputBinEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FeedDirection = NULL;
	a->MediaSize = NULL;
	a->MediaType = NULL;
	a->MediaColor = NULL;
	a->Capacity = NULL;
	a->Level = NULL;
	soap_default_wprt__InputBinNameType(soap, &a->Name);
	a->Removed = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinEntryType(struct soap *soap, const struct wprt__InputBinEntryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinEntryType);
	if (soap_out_wprt__InputBinEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinEntryType(struct soap *soap, const char *tag, int id, const struct wprt__InputBinEntryType *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name);
	if (a->Removed)
		soap_set_attr(soap, "Removed", soap_xsd__boolean2s(soap, *a->Removed));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__InputBinEntryType), type);
	soap_out_PointerTowprt__InputBinFeedDirectionType(soap, "wprt:FeedDirection", -1, &a->FeedDirection, "");
	soap_out_PointerTowprt__InputBinMediaSizeType(soap, "wprt:MediaSize", -1, &a->MediaSize, "");
	soap_out_PointerTowprt__InputBinMediaTypeBaseType(soap, "wprt:MediaType", -1, &a->MediaType, "");
	soap_out_PointerTowprt__InputBinMediaColorType(soap, "wprt:MediaColor", -1, &a->MediaColor, "");
	soap_out_PointerTowprt__CapacityBaseType(soap, "wprt:Capacity", -1, &a->Capacity, "");
	soap_out_PointerTowprt__LevelFreeBaseType(soap, "wprt:Level", -1, &a->Level, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__InputBinEntryType * SOAP_FMAC4 soap_get_wprt__InputBinEntryType(struct soap *soap, struct wprt__InputBinEntryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinEntryType * SOAP_FMAC4 soap_in_wprt__InputBinEntryType(struct soap *soap, const char *tag, struct wprt__InputBinEntryType *a, const char *type)
{
	short soap_flag_FeedDirection = 1, soap_flag_MediaSize = 1, soap_flag_MediaType = 1, soap_flag_MediaColor = 1, soap_flag_Capacity = 1, soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__InputBinEntryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__InputBinEntryType, sizeof(struct wprt__InputBinEntryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__InputBinEntryType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Removed", 0);
		if (t)
		{	if (!(a->Removed = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->Removed))
		return NULL;
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeedDirection && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__InputBinFeedDirectionType(soap, "FeedDirection", &a->FeedDirection, "wprt:InputBinFeedDirectionType"))
				{	soap_flag_FeedDirection--;
					continue;
				}
			if (soap_flag_MediaSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__InputBinMediaSizeType(soap, "MediaSize", &a->MediaSize, "wprt:InputBinMediaSizeType"))
				{	soap_flag_MediaSize--;
					continue;
				}
			if (soap_flag_MediaType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__InputBinMediaTypeBaseType(soap, "MediaType", &a->MediaType, "wprt:InputBinMediaTypeBaseType"))
				{	soap_flag_MediaType--;
					continue;
				}
			if (soap_flag_MediaColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__InputBinMediaColorType(soap, "MediaColor", &a->MediaColor, "wprt:InputBinMediaColorType"))
				{	soap_flag_MediaColor--;
					continue;
				}
			if (soap_flag_Capacity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__CapacityBaseType(soap, "Capacity", &a->Capacity, "wprt:CapacityBaseType"))
				{	soap_flag_Capacity--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__LevelFreeBaseType(soap, "Level", &a->Level, "wprt:LevelFreeBaseType"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FeedDirection > 0 || soap_flag_MediaSize > 0 || soap_flag_Capacity > 0 || soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__InputBinEntryType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__InputBinEntryType, 0, sizeof(struct wprt__InputBinEntryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__String255ExtType(struct soap *soap, const struct wprt__String255ExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__String255BaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__String255ExtType(struct soap *soap, struct wprt__String255ExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__String255BaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__String255ExtType(struct soap *soap, const struct wprt__String255ExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__String255ExtType);
	if (soap_out_wprt__String255ExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__String255ExtType(struct soap *soap, const char *tag, int id, const struct wprt__String255ExtType *a, const char *type)
{
	return soap_out_wprt__String255BaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__String255ExtType * SOAP_FMAC4 soap_get_wprt__String255ExtType(struct soap *soap, struct wprt__String255ExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__String255ExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__String255ExtType * SOAP_FMAC4 soap_in_wprt__String255ExtType(struct soap *soap, const char *tag, struct wprt__String255ExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__String255ExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__String255ExtType, sizeof(struct wprt__String255ExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__String255ExtType(soap, a);
	if (!soap_in_wprt__String255BaseType(soap, tag, &a->__item, "wprt:String255ExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConsumableColorType(struct soap *soap, const struct wprt__ConsumableColorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__ConsumableColorExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConsumableColorType(struct soap *soap, struct wprt__ConsumableColorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__ConsumableColorExtType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConsumableColorType(struct soap *soap, const struct wprt__ConsumableColorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConsumableColorType);
	if (soap_out_wprt__ConsumableColorType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConsumableColorType(struct soap *soap, const char *tag, int id, const struct wprt__ConsumableColorType *a, const char *type)
{
	return soap_out_wprt__ConsumableColorExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__ConsumableColorType * SOAP_FMAC4 soap_get_wprt__ConsumableColorType(struct soap *soap, struct wprt__ConsumableColorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConsumableColorType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConsumableColorType * SOAP_FMAC4 soap_in_wprt__ConsumableColorType(struct soap *soap, const char *tag, struct wprt__ConsumableColorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__ConsumableColorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConsumableColorType, sizeof(struct wprt__ConsumableColorType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__ConsumableColorType(soap, a);
	if (!soap_in_wprt__ConsumableColorExtType(soap, tag, &a->__item, "wprt:ConsumableColorType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConsumableTypeBaseType(struct soap *soap, const struct wprt__ConsumableTypeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__ConsumableTypeExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConsumableTypeBaseType(struct soap *soap, struct wprt__ConsumableTypeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__ConsumableTypeExtType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConsumableTypeBaseType(struct soap *soap, const struct wprt__ConsumableTypeBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConsumableTypeBaseType);
	if (soap_out_wprt__ConsumableTypeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConsumableTypeBaseType(struct soap *soap, const char *tag, int id, const struct wprt__ConsumableTypeBaseType *a, const char *type)
{
	return soap_out_wprt__ConsumableTypeExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__ConsumableTypeBaseType * SOAP_FMAC4 soap_get_wprt__ConsumableTypeBaseType(struct soap *soap, struct wprt__ConsumableTypeBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConsumableTypeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConsumableTypeBaseType * SOAP_FMAC4 soap_in_wprt__ConsumableTypeBaseType(struct soap *soap, const char *tag, struct wprt__ConsumableTypeBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__ConsumableTypeBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConsumableTypeBaseType, sizeof(struct wprt__ConsumableTypeBaseType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__ConsumableTypeBaseType(soap, a);
	if (!soap_in_wprt__ConsumableTypeExtType(soap, tag, &a->__item, "wprt:ConsumableTypeBaseType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConsumableEntryType(struct soap *soap, const struct wprt__ConsumableEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ConsumableTypeBaseType(soap, &a->Type);
	soap_serialize_PointerTowprt__ConsumableColorType(soap, &a->Color);
	soap_serialize_PointerTowprt__LevelFreeBaseType(soap, &a->Level);
	soap_serialize_PointerTowprt__String255ExtType(soap, &a->Model);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConsumableEntryType(struct soap *soap, struct wprt__ConsumableEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Type = NULL;
	a->Color = NULL;
	a->Level = NULL;
	a->Model = NULL;
	soap_default_wprt__String255BaseType(soap, &a->Name);
	a->Removed = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConsumableEntryType(struct soap *soap, const struct wprt__ConsumableEntryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConsumableEntryType);
	if (soap_out_wprt__ConsumableEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConsumableEntryType(struct soap *soap, const char *tag, int id, const struct wprt__ConsumableEntryType *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name);
	if (a->Removed)
		soap_set_attr(soap, "Removed", soap_xsd__boolean2s(soap, *a->Removed));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ConsumableEntryType), type);
	soap_out_PointerTowprt__ConsumableTypeBaseType(soap, "wprt:Type", -1, &a->Type, "");
	soap_out_PointerTowprt__ConsumableColorType(soap, "wprt:Color", -1, &a->Color, "");
	soap_out_PointerTowprt__LevelFreeBaseType(soap, "wprt:Level", -1, &a->Level, "");
	soap_out_PointerTowprt__String255ExtType(soap, "wprt:Model", -1, &a->Model, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ConsumableEntryType * SOAP_FMAC4 soap_get_wprt__ConsumableEntryType(struct soap *soap, struct wprt__ConsumableEntryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConsumableEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConsumableEntryType * SOAP_FMAC4 soap_in_wprt__ConsumableEntryType(struct soap *soap, const char *tag, struct wprt__ConsumableEntryType *a, const char *type)
{
	short soap_flag_Type = 1, soap_flag_Color = 1, soap_flag_Level = 1, soap_flag_Model = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ConsumableEntryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ConsumableEntryType, sizeof(struct wprt__ConsumableEntryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ConsumableEntryType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Removed", 0);
		if (t)
		{	if (!(a->Removed = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->Removed))
		return NULL;
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConsumableTypeBaseType(soap, "Type", &a->Type, "wprt:ConsumableTypeBaseType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConsumableColorType(soap, "Color", &a->Color, "wprt:ConsumableColorType"))
				{	soap_flag_Color--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__LevelFreeBaseType(soap, "Level", &a->Level, "wprt:LevelFreeBaseType"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap_flag_Model && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__String255ExtType(soap, "Model", &a->Model, "wprt:String255ExtType"))
				{	soap_flag_Model--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ConsumableEntryType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ConsumableEntryType, 0, sizeof(struct wprt__ConsumableEntryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__LevelFreeBaseType(struct soap *soap, const struct wprt__LevelFreeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__LevelFreeBaseType(struct soap *soap, struct wprt__LevelFreeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__LevelFreeRestrictType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__LevelFreeBaseType(struct soap *soap, const struct wprt__LevelFreeBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__LevelFreeBaseType);
	if (soap_out_wprt__LevelFreeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__LevelFreeBaseType(struct soap *soap, const char *tag, int id, const struct wprt__LevelFreeBaseType *a, const char *type)
{
	return soap_out_wprt__LevelFreeRestrictType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__LevelFreeBaseType * SOAP_FMAC4 soap_get_wprt__LevelFreeBaseType(struct soap *soap, struct wprt__LevelFreeBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__LevelFreeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__LevelFreeBaseType * SOAP_FMAC4 soap_in_wprt__LevelFreeBaseType(struct soap *soap, const char *tag, struct wprt__LevelFreeBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__LevelFreeBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__LevelFreeBaseType, sizeof(struct wprt__LevelFreeBaseType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__LevelFreeBaseType(soap, a);
	if (!soap_in_wprt__LevelFreeRestrictType(soap, tag, &a->__item, "wprt:LevelFreeBaseType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__IntOneExtType(struct soap *soap, const struct wprt__IntOneExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__IntOneExtType(struct soap *soap, struct wprt__IntOneExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__IntOneBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__IntOneExtType(struct soap *soap, const struct wprt__IntOneExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__IntOneExtType);
	if (soap_out_wprt__IntOneExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__IntOneExtType(struct soap *soap, const char *tag, int id, const struct wprt__IntOneExtType *a, const char *type)
{
	return soap_out_wprt__IntOneBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__IntOneExtType * SOAP_FMAC4 soap_get_wprt__IntOneExtType(struct soap *soap, struct wprt__IntOneExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__IntOneExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__IntOneExtType * SOAP_FMAC4 soap_in_wprt__IntOneExtType(struct soap *soap, const char *tag, struct wprt__IntOneExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__IntOneExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__IntOneExtType, sizeof(struct wprt__IntOneExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__IntOneExtType(soap, a);
	if (!soap_in_wprt__IntOneBaseType(soap, tag, &a->__item, "wprt:IntOneExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StorageTypeBaseType(struct soap *soap, const struct wprt__StorageTypeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__StorageTypeExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StorageTypeBaseType(struct soap *soap, struct wprt__StorageTypeBaseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__StorageTypeExtType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StorageTypeBaseType(struct soap *soap, const struct wprt__StorageTypeBaseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StorageTypeBaseType);
	if (soap_out_wprt__StorageTypeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StorageTypeBaseType(struct soap *soap, const char *tag, int id, const struct wprt__StorageTypeBaseType *a, const char *type)
{
	return soap_out_wprt__StorageTypeExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__StorageTypeBaseType * SOAP_FMAC4 soap_get_wprt__StorageTypeBaseType(struct soap *soap, struct wprt__StorageTypeBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StorageTypeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StorageTypeBaseType * SOAP_FMAC4 soap_in_wprt__StorageTypeBaseType(struct soap *soap, const char *tag, struct wprt__StorageTypeBaseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__StorageTypeBaseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StorageTypeBaseType, sizeof(struct wprt__StorageTypeBaseType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__StorageTypeBaseType(soap, a);
	if (!soap_in_wprt__StorageTypeExtType(soap, tag, &a->__item, "wprt:StorageTypeBaseType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StorageEntryType(struct soap *soap, const struct wprt__StorageEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__StorageTypeBaseType(soap, &a->Type);
	soap_serialize_PointerTowprt__IntOneExtType(soap, &a->Size);
	soap_serialize_PointerTowprt__LevelFreeBaseType(soap, &a->Free);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StorageEntryType(struct soap *soap, struct wprt__StorageEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Type = NULL;
	a->Size = NULL;
	a->Free = NULL;
	soap_default_wprt__String255BaseType(soap, &a->Name);
	a->Removed = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StorageEntryType(struct soap *soap, const struct wprt__StorageEntryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StorageEntryType);
	if (soap_out_wprt__StorageEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StorageEntryType(struct soap *soap, const char *tag, int id, const struct wprt__StorageEntryType *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name);
	if (a->Removed)
		soap_set_attr(soap, "Removed", soap_xsd__boolean2s(soap, *a->Removed));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__StorageEntryType), type);
	soap_out_PointerTowprt__StorageTypeBaseType(soap, "wprt:Type", -1, &a->Type, "");
	soap_out_PointerTowprt__IntOneExtType(soap, "wprt:Size", -1, &a->Size, "");
	soap_out_PointerTowprt__LevelFreeBaseType(soap, "wprt:Free", -1, &a->Free, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__StorageEntryType * SOAP_FMAC4 soap_get_wprt__StorageEntryType(struct soap *soap, struct wprt__StorageEntryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StorageEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StorageEntryType * SOAP_FMAC4 soap_in_wprt__StorageEntryType(struct soap *soap, const char *tag, struct wprt__StorageEntryType *a, const char *type)
{
	short soap_flag_Type = 1, soap_flag_Size = 1, soap_flag_Free = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__StorageEntryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StorageEntryType, sizeof(struct wprt__StorageEntryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__StorageEntryType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Removed", 0);
		if (t)
		{	if (!(a->Removed = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2xsd__boolean(soap, t, a->Removed))
		return NULL;
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__StorageTypeBaseType(soap, "Type", &a->Type, "wprt:StorageTypeBaseType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Size && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntOneExtType(soap, "Size", &a->Size, "wprt:IntOneExtType"))
				{	soap_flag_Size--;
					continue;
				}
			if (soap_flag_Free && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__LevelFreeBaseType(soap, "Free", &a->Free, "wprt:LevelFreeBaseType"))
				{	soap_flag_Free--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Size > 0 || soap_flag_Free > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__StorageEntryType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__StorageEntryType, 0, sizeof(struct wprt__StorageEntryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ResolutionEntryType(struct soap *soap, const struct wprt__ResolutionEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__IntExtType(soap, &a->Width);
	soap_serialize_PointerTowprt__IntExtType(soap, &a->Height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ResolutionEntryType(struct soap *soap, struct wprt__ResolutionEntryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Width = NULL;
	a->Height = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ResolutionEntryType(struct soap *soap, const struct wprt__ResolutionEntryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ResolutionEntryType);
	if (soap_out_wprt__ResolutionEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ResolutionEntryType(struct soap *soap, const char *tag, int id, const struct wprt__ResolutionEntryType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ResolutionEntryType), type);
	soap_out_PointerTowprt__IntExtType(soap, "wprt:Width", -1, &a->Width, "");
	soap_out_PointerTowprt__IntExtType(soap, "wprt:Height", -1, &a->Height, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ResolutionEntryType * SOAP_FMAC4 soap_get_wprt__ResolutionEntryType(struct soap *soap, struct wprt__ResolutionEntryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ResolutionEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ResolutionEntryType * SOAP_FMAC4 soap_in_wprt__ResolutionEntryType(struct soap *soap, const char *tag, struct wprt__ResolutionEntryType *a, const char *type)
{
	short soap_flag_Width = 1, soap_flag_Height = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ResolutionEntryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ResolutionEntryType, sizeof(struct wprt__ResolutionEntryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ResolutionEntryType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntExtType(soap, "Width", &a->Width, "wprt:IntExtType"))
				{	soap_flag_Width--;
					continue;
				}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntExtType(soap, "Height", &a->Height, "wprt:IntExtType"))
				{	soap_flag_Height--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ResolutionEntryType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ResolutionEntryType, 0, sizeof(struct wprt__ResolutionEntryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ValueIntRangeType(struct soap *soap, const struct wprt__ValueIntRangeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__IntExtType(soap, &a->MinValue);
	soap_serialize_PointerTowprt__IntExtType(soap, &a->MaxValue);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ValueIntRangeType(struct soap *soap, struct wprt__ValueIntRangeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MinValue = NULL;
	a->MaxValue = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ValueIntRangeType(struct soap *soap, const struct wprt__ValueIntRangeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ValueIntRangeType);
	if (soap_out_wprt__ValueIntRangeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ValueIntRangeType(struct soap *soap, const char *tag, int id, const struct wprt__ValueIntRangeType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ValueIntRangeType), type);
	soap_out_PointerTowprt__IntExtType(soap, "wprt:MinValue", -1, &a->MinValue, "");
	soap_out_PointerTowprt__IntExtType(soap, "wprt:MaxValue", -1, &a->MaxValue, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ValueIntRangeType * SOAP_FMAC4 soap_get_wprt__ValueIntRangeType(struct soap *soap, struct wprt__ValueIntRangeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ValueIntRangeType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ValueIntRangeType * SOAP_FMAC4 soap_in_wprt__ValueIntRangeType(struct soap *soap, const char *tag, struct wprt__ValueIntRangeType *a, const char *type)
{
	short soap_flag_MinValue = 1, soap_flag_MaxValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ValueIntRangeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ValueIntRangeType, sizeof(struct wprt__ValueIntRangeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ValueIntRangeType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntExtType(soap, "MinValue", &a->MinValue, "wprt:IntExtType"))
				{	soap_flag_MinValue--;
					continue;
				}
			if (soap_flag_MaxValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntExtType(soap, "MaxValue", &a->MaxValue, "wprt:IntExtType"))
				{	soap_flag_MaxValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxValue > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ValueIntRangeType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ValueIntRangeType, 0, sizeof(struct wprt__ValueIntRangeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__IntExtType(struct soap *soap, const struct wprt__IntExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__IntExtType(struct soap *soap, struct wprt__IntExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__IntExtType(struct soap *soap, const struct wprt__IntExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__IntExtType);
	if (soap_out_wprt__IntExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__IntExtType(struct soap *soap, const char *tag, int id, const struct wprt__IntExtType *a, const char *type)
{
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__IntExtType * SOAP_FMAC4 soap_get_wprt__IntExtType(struct soap *soap, struct wprt__IntExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__IntExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__IntExtType * SOAP_FMAC4 soap_in_wprt__IntExtType(struct soap *soap, const char *tag, struct wprt__IntExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__IntExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__IntExtType, sizeof(struct wprt__IntExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__IntExtType(soap, a);
	if (!soap_in_int(soap, tag, &a->__item, "wprt:IntExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ValueIntListType(struct soap *soap, const struct wprt__ValueIntListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AllowedValue)
	{	int i;
		for (i = 0; i < a->__sizeAllowedValue; i++)
		{
			soap_embedded(soap, a->AllowedValue + i, SOAP_TYPE_wprt__IntExtType);
			soap_serialize_wprt__IntExtType(soap, a->AllowedValue + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ValueIntListType(struct soap *soap, struct wprt__ValueIntListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAllowedValue = 0;
	a->AllowedValue = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ValueIntListType(struct soap *soap, const struct wprt__ValueIntListType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ValueIntListType);
	if (soap_out_wprt__ValueIntListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ValueIntListType(struct soap *soap, const char *tag, int id, const struct wprt__ValueIntListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ValueIntListType), type);
	if (a->AllowedValue)
	{	int i;
		for (i = 0; i < a->__sizeAllowedValue; i++)
			soap_out_wprt__IntExtType(soap, "wprt:AllowedValue", -1, a->AllowedValue + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ValueIntListType * SOAP_FMAC4 soap_get_wprt__ValueIntListType(struct soap *soap, struct wprt__ValueIntListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ValueIntListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ValueIntListType * SOAP_FMAC4 soap_in_wprt__ValueIntListType(struct soap *soap, const char *tag, struct wprt__ValueIntListType *a, const char *type)
{
	short soap_flag_AllowedValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ValueIntListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ValueIntListType, sizeof(struct wprt__ValueIntListType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ValueIntListType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AllowedValue && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__IntExtType *p;
				soap_new_block(soap);
				for (a->__sizeAllowedValue = 0; !soap_element_begin_in(soap, "AllowedValue", 1, NULL); a->__sizeAllowedValue++)
				{	p = (struct wprt__IntExtType *)soap_push_block(soap, sizeof(struct wprt__IntExtType));
					soap_default_wprt__IntExtType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__IntExtType(soap, "AllowedValue", p, "wprt:IntExtType"))
						break;
					soap_flag_AllowedValue = 0;
				}
				a->AllowedValue = (struct wprt__IntExtType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_AllowedValue && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ValueIntListType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ValueIntListType, 0, sizeof(struct wprt__ValueIntListType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ValueStringListType(struct soap *soap, const struct wprt__ValueStringListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AllowedValue)
	{	int i;
		for (i = 0; i < a->__sizeAllowedValue; i++)
		{
			soap_embedded(soap, a->AllowedValue + i, SOAP_TYPE_wprt__AnyURIExtType);
			soap_serialize_wprt__AnyURIExtType(soap, a->AllowedValue + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ValueStringListType(struct soap *soap, struct wprt__ValueStringListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAllowedValue = 0;
	a->AllowedValue = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ValueStringListType(struct soap *soap, const struct wprt__ValueStringListType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ValueStringListType);
	if (soap_out_wprt__ValueStringListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ValueStringListType(struct soap *soap, const char *tag, int id, const struct wprt__ValueStringListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ValueStringListType), type);
	if (a->AllowedValue)
	{	int i;
		for (i = 0; i < a->__sizeAllowedValue; i++)
			soap_out_wprt__AnyURIExtType(soap, "wprt:AllowedValue", -1, a->AllowedValue + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ValueStringListType * SOAP_FMAC4 soap_get_wprt__ValueStringListType(struct soap *soap, struct wprt__ValueStringListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ValueStringListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ValueStringListType * SOAP_FMAC4 soap_in_wprt__ValueStringListType(struct soap *soap, const char *tag, struct wprt__ValueStringListType *a, const char *type)
{
	short soap_flag_AllowedValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ValueStringListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ValueStringListType, sizeof(struct wprt__ValueStringListType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ValueStringListType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AllowedValue && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__AnyURIExtType *p;
				soap_new_block(soap);
				for (a->__sizeAllowedValue = 0; !soap_element_begin_in(soap, "AllowedValue", 1, NULL); a->__sizeAllowedValue++)
				{	p = (struct wprt__AnyURIExtType *)soap_push_block(soap, sizeof(struct wprt__AnyURIExtType));
					soap_default_wprt__AnyURIExtType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__AnyURIExtType(soap, "AllowedValue", p, "wprt:AnyURIExtType"))
						break;
					soap_flag_AllowedValue = 0;
				}
				a->AllowedValue = (struct wprt__AnyURIExtType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_AllowedValue && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ValueStringListType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ValueStringListType, 0, sizeof(struct wprt__ValueStringListType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__NMTOKENSExtType(struct soap *soap, const struct wprt__NMTOKENSExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__NMTOKENS(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__NMTOKENSExtType(struct soap *soap, struct wprt__NMTOKENSExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKENS(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__NMTOKENSExtType(struct soap *soap, const struct wprt__NMTOKENSExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__NMTOKENSExtType);
	if (soap_out_wprt__NMTOKENSExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__NMTOKENSExtType(struct soap *soap, const char *tag, int id, const struct wprt__NMTOKENSExtType *a, const char *type)
{
	return soap_out_xsd__NMTOKENS(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__NMTOKENSExtType * SOAP_FMAC4 soap_get_wprt__NMTOKENSExtType(struct soap *soap, struct wprt__NMTOKENSExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__NMTOKENSExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__NMTOKENSExtType * SOAP_FMAC4 soap_in_wprt__NMTOKENSExtType(struct soap *soap, const char *tag, struct wprt__NMTOKENSExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__NMTOKENSExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__NMTOKENSExtType, sizeof(struct wprt__NMTOKENSExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__NMTOKENSExtType(soap, a);
	if (!soap_in_xsd__NMTOKENS(soap, tag, &a->__item, "wprt:NMTOKENSExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ValueTokenListType(struct soap *soap, const struct wprt__ValueTokenListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AllowedValue)
	{	int i;
		for (i = 0; i < a->__sizeAllowedValue; i++)
		{
			soap_embedded(soap, a->AllowedValue + i, SOAP_TYPE_wprt__NMTOKENSExtType);
			soap_serialize_wprt__NMTOKENSExtType(soap, a->AllowedValue + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ValueTokenListType(struct soap *soap, struct wprt__ValueTokenListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAllowedValue = 0;
	a->AllowedValue = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ValueTokenListType(struct soap *soap, const struct wprt__ValueTokenListType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ValueTokenListType);
	if (soap_out_wprt__ValueTokenListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ValueTokenListType(struct soap *soap, const char *tag, int id, const struct wprt__ValueTokenListType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ValueTokenListType), type);
	if (a->AllowedValue)
	{	int i;
		for (i = 0; i < a->__sizeAllowedValue; i++)
			soap_out_wprt__NMTOKENSExtType(soap, "wprt:AllowedValue", -1, a->AllowedValue + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ValueTokenListType * SOAP_FMAC4 soap_get_wprt__ValueTokenListType(struct soap *soap, struct wprt__ValueTokenListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ValueTokenListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ValueTokenListType * SOAP_FMAC4 soap_in_wprt__ValueTokenListType(struct soap *soap, const char *tag, struct wprt__ValueTokenListType *a, const char *type)
{
	short soap_flag_AllowedValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ValueTokenListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ValueTokenListType, sizeof(struct wprt__ValueTokenListType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ValueTokenListType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AllowedValue && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__NMTOKENSExtType *p;
				soap_new_block(soap);
				for (a->__sizeAllowedValue = 0; !soap_element_begin_in(soap, "AllowedValue", 1, NULL); a->__sizeAllowedValue++)
				{	p = (struct wprt__NMTOKENSExtType *)soap_push_block(soap, sizeof(struct wprt__NMTOKENSExtType));
					soap_default_wprt__NMTOKENSExtType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__NMTOKENSExtType(soap, "AllowedValue", p, "wprt:NMTOKENSExtType"))
						break;
					soap_flag_AllowedValue = 0;
				}
				a->AllowedValue = (struct wprt__NMTOKENSExtType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_AllowedValue && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ValueTokenListType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ValueTokenListType, 0, sizeof(struct wprt__ValueTokenListType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobEndStateEventType(struct soap *soap, const struct wprt__JobEndStateEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobEndStateType(soap, &a->JobEndState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobEndStateEventType(struct soap *soap, struct wprt__JobEndStateEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobEndState = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobEndStateEventType(struct soap *soap, const struct wprt__JobEndStateEventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobEndStateEventType);
	if (soap_out_wprt__JobEndStateEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobEndStateEventType(struct soap *soap, const char *tag, int id, const struct wprt__JobEndStateEventType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobEndStateEventType), type);
	soap_out_PointerTowprt__JobEndStateType(soap, "wprt:JobEndState", -1, &a->JobEndState, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobEndStateEventType * SOAP_FMAC4 soap_get_wprt__JobEndStateEventType(struct soap *soap, struct wprt__JobEndStateEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobEndStateEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobEndStateEventType * SOAP_FMAC4 soap_in_wprt__JobEndStateEventType(struct soap *soap, const char *tag, struct wprt__JobEndStateEventType *a, const char *type)
{
	short soap_flag_JobEndState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobEndStateEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobEndStateEventType, sizeof(struct wprt__JobEndStateEventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobEndStateEventType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobEndState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobEndStateType(soap, "JobEndState", &a->JobEndState, "wprt:JobEndStateType"))
				{	soap_flag_JobEndState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobEndState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobEndStateEventType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobEndStateEventType, 0, sizeof(struct wprt__JobEndStateEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__IntZeroExtType(struct soap *soap, const struct wprt__IntZeroExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__IntZeroExtType(struct soap *soap, struct wprt__IntZeroExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__IntZeroBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__IntZeroExtType(struct soap *soap, const struct wprt__IntZeroExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__IntZeroExtType);
	if (soap_out_wprt__IntZeroExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__IntZeroExtType(struct soap *soap, const char *tag, int id, const struct wprt__IntZeroExtType *a, const char *type)
{
	return soap_out_wprt__IntZeroBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__IntZeroExtType * SOAP_FMAC4 soap_get_wprt__IntZeroExtType(struct soap *soap, struct wprt__IntZeroExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__IntZeroExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__IntZeroExtType * SOAP_FMAC4 soap_in_wprt__IntZeroExtType(struct soap *soap, const char *tag, struct wprt__IntZeroExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__IntZeroExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__IntZeroExtType, sizeof(struct wprt__IntZeroExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__IntZeroExtType(soap, a);
	if (!soap_in_wprt__IntZeroBaseType(soap, tag, &a->__item, "wprt:IntZeroExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobOriginatingUserNameType(struct soap *soap, const struct wprt__JobOriginatingUserNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__JobOriginatingUserNameRestrictionType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobOriginatingUserNameType(struct soap *soap, struct wprt__JobOriginatingUserNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__JobOriginatingUserNameRestrictionType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobOriginatingUserNameType(struct soap *soap, const struct wprt__JobOriginatingUserNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobOriginatingUserNameType);
	if (soap_out_wprt__JobOriginatingUserNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobOriginatingUserNameType(struct soap *soap, const char *tag, int id, const struct wprt__JobOriginatingUserNameType *a, const char *type)
{
	return soap_out_wprt__JobOriginatingUserNameRestrictionType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__JobOriginatingUserNameType * SOAP_FMAC4 soap_get_wprt__JobOriginatingUserNameType(struct soap *soap, struct wprt__JobOriginatingUserNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobOriginatingUserNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobOriginatingUserNameType * SOAP_FMAC4 soap_in_wprt__JobOriginatingUserNameType(struct soap *soap, const char *tag, struct wprt__JobOriginatingUserNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__JobOriginatingUserNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobOriginatingUserNameType, sizeof(struct wprt__JobOriginatingUserNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__JobOriginatingUserNameType(soap, a);
	if (!soap_in_wprt__JobOriginatingUserNameRestrictionType(soap, tag, &a->__item, "wprt:JobOriginatingUserNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobNameType(struct soap *soap, const struct wprt__JobNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__JobNameRestrictionType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobNameType(struct soap *soap, struct wprt__JobNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__JobNameRestrictionType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobNameType(struct soap *soap, const struct wprt__JobNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobNameType);
	if (soap_out_wprt__JobNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobNameType(struct soap *soap, const char *tag, int id, const struct wprt__JobNameType *a, const char *type)
{
	return soap_out_wprt__JobNameRestrictionType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__JobNameType * SOAP_FMAC4 soap_get_wprt__JobNameType(struct soap *soap, struct wprt__JobNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobNameType * SOAP_FMAC4 soap_in_wprt__JobNameType(struct soap *soap, const char *tag, struct wprt__JobNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__JobNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobNameType, sizeof(struct wprt__JobNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__JobNameType(soap, a);
	if (!soap_in_wprt__JobNameRestrictionType(soap, tag, &a->__item, "wprt:JobNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobStateReasonsType(struct soap *soap, const struct wprt__JobStateReasonsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->JobStateReason)
	{	int i;
		for (i = 0; i < a->__sizeJobStateReason; i++)
		{
			soap_embedded(soap, a->JobStateReason + i, SOAP_TYPE_wprt__JobStateReasonType);
			soap_serialize_wprt__JobStateReasonType(soap, a->JobStateReason + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobStateReasonsType(struct soap *soap, struct wprt__JobStateReasonsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeJobStateReason = 0;
	a->JobStateReason = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobStateReasonsType(struct soap *soap, const struct wprt__JobStateReasonsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobStateReasonsType);
	if (soap_out_wprt__JobStateReasonsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobStateReasonsType(struct soap *soap, const char *tag, int id, const struct wprt__JobStateReasonsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobStateReasonsType), type);
	if (a->JobStateReason)
	{	int i;
		for (i = 0; i < a->__sizeJobStateReason; i++)
			soap_out_wprt__JobStateReasonType(soap, "wprt:JobStateReason", -1, a->JobStateReason + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobStateReasonsType * SOAP_FMAC4 soap_get_wprt__JobStateReasonsType(struct soap *soap, struct wprt__JobStateReasonsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobStateReasonsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStateReasonsType * SOAP_FMAC4 soap_in_wprt__JobStateReasonsType(struct soap *soap, const char *tag, struct wprt__JobStateReasonsType *a, const char *type)
{
	short soap_flag_JobStateReason = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobStateReasonsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobStateReasonsType, sizeof(struct wprt__JobStateReasonsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobStateReasonsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobStateReason && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__JobStateReasonType *p;
				soap_new_block(soap);
				for (a->__sizeJobStateReason = 0; !soap_element_begin_in(soap, "JobStateReason", 1, NULL); a->__sizeJobStateReason++)
				{	p = (struct wprt__JobStateReasonType *)soap_push_block(soap, sizeof(struct wprt__JobStateReasonType));
					soap_default_wprt__JobStateReasonType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__JobStateReasonType(soap, "JobStateReason", p, "wprt:JobStateReasonType"))
						break;
					soap_flag_JobStateReason = 0;
				}
				a->JobStateReason = (struct wprt__JobStateReasonType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_JobStateReason && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobStateReasonsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobStateReasonsType, 0, sizeof(struct wprt__JobStateReasonsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobStateType(struct soap *soap, const struct wprt__JobStateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__JobStateExtType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobStateType(struct soap *soap, struct wprt__JobStateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__JobStateExtType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobStateType(struct soap *soap, const struct wprt__JobStateType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobStateType);
	if (soap_out_wprt__JobStateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobStateType(struct soap *soap, const char *tag, int id, const struct wprt__JobStateType *a, const char *type)
{
	return soap_out_wprt__JobStateExtType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__JobStateType * SOAP_FMAC4 soap_get_wprt__JobStateType(struct soap *soap, struct wprt__JobStateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobStateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStateType * SOAP_FMAC4 soap_in_wprt__JobStateType(struct soap *soap, const char *tag, struct wprt__JobStateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__JobStateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobStateType, sizeof(struct wprt__JobStateType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__JobStateType(soap, a);
	if (!soap_in_wprt__JobStateExtType(soap, tag, &a->__item, "wprt:JobStateType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobEndStateType(struct soap *soap, const struct wprt__JobEndStateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobIdType(soap, &a->JobId);
	soap_serialize_PointerTowprt__JobStateType(soap, &a->JobCompletedState);
	soap_serialize_PointerTowprt__JobStateReasonsType(soap, &a->JobCompletedStateReasons);
	soap_serialize_PointerTowprt__JobNameType(soap, &a->JobName);
	soap_serialize_PointerTowprt__JobOriginatingUserNameType(soap, &a->JobOriginatingUserName);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->KOctetsProcessed);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->MediaSheetsCompleted);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->NumberOfDocuments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobEndStateType(struct soap *soap, struct wprt__JobEndStateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobId = NULL;
	a->JobCompletedState = NULL;
	a->JobCompletedStateReasons = NULL;
	a->JobName = NULL;
	a->JobOriginatingUserName = NULL;
	a->KOctetsProcessed = NULL;
	a->MediaSheetsCompleted = NULL;
	a->NumberOfDocuments = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobEndStateType(struct soap *soap, const struct wprt__JobEndStateType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobEndStateType);
	if (soap_out_wprt__JobEndStateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobEndStateType(struct soap *soap, const char *tag, int id, const struct wprt__JobEndStateType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobEndStateType), type);
	soap_out_PointerTowprt__JobIdType(soap, "wprt:JobId", -1, &a->JobId, "");
	soap_out_PointerTowprt__JobStateType(soap, "wprt:JobCompletedState", -1, &a->JobCompletedState, "");
	soap_out_PointerTowprt__JobStateReasonsType(soap, "wprt:JobCompletedStateReasons", -1, &a->JobCompletedStateReasons, "");
	soap_out_PointerTowprt__JobNameType(soap, "wprt:JobName", -1, &a->JobName, "");
	soap_out_PointerTowprt__JobOriginatingUserNameType(soap, "wprt:JobOriginatingUserName", -1, &a->JobOriginatingUserName, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:KOctetsProcessed", -1, &a->KOctetsProcessed, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:MediaSheetsCompleted", -1, &a->MediaSheetsCompleted, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:NumberOfDocuments", -1, &a->NumberOfDocuments, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobEndStateType * SOAP_FMAC4 soap_get_wprt__JobEndStateType(struct soap *soap, struct wprt__JobEndStateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobEndStateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobEndStateType * SOAP_FMAC4 soap_in_wprt__JobEndStateType(struct soap *soap, const char *tag, struct wprt__JobEndStateType *a, const char *type)
{
	short soap_flag_JobId = 1, soap_flag_JobCompletedState = 1, soap_flag_JobCompletedStateReasons = 1, soap_flag_JobName = 1, soap_flag_JobOriginatingUserName = 1, soap_flag_KOctetsProcessed = 1, soap_flag_MediaSheetsCompleted = 1, soap_flag_NumberOfDocuments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobEndStateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobEndStateType, sizeof(struct wprt__JobEndStateType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobEndStateType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobIdType(soap, "JobId", &a->JobId, "wprt:JobIdType"))
				{	soap_flag_JobId--;
					continue;
				}
			if (soap_flag_JobCompletedState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobStateType(soap, "JobCompletedState", &a->JobCompletedState, "wprt:JobStateType"))
				{	soap_flag_JobCompletedState--;
					continue;
				}
			if (soap_flag_JobCompletedStateReasons && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobStateReasonsType(soap, "JobCompletedStateReasons", &a->JobCompletedStateReasons, "wprt:JobStateReasonsType"))
				{	soap_flag_JobCompletedStateReasons--;
					continue;
				}
			if (soap_flag_JobName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobNameType(soap, "JobName", &a->JobName, "wprt:JobNameType"))
				{	soap_flag_JobName--;
					continue;
				}
			if (soap_flag_JobOriginatingUserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobOriginatingUserNameType(soap, "JobOriginatingUserName", &a->JobOriginatingUserName, "wprt:JobOriginatingUserNameType"))
				{	soap_flag_JobOriginatingUserName--;
					continue;
				}
			if (soap_flag_KOctetsProcessed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "KOctetsProcessed", &a->KOctetsProcessed, "wprt:IntZeroExtType"))
				{	soap_flag_KOctetsProcessed--;
					continue;
				}
			if (soap_flag_MediaSheetsCompleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "MediaSheetsCompleted", &a->MediaSheetsCompleted, "wprt:IntZeroExtType"))
				{	soap_flag_MediaSheetsCompleted--;
					continue;
				}
			if (soap_flag_NumberOfDocuments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "NumberOfDocuments", &a->NumberOfDocuments, "wprt:IntZeroExtType"))
				{	soap_flag_NumberOfDocuments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobId > 0 || soap_flag_JobCompletedState > 0 || soap_flag_JobCompletedStateReasons > 0 || soap_flag_JobName > 0 || soap_flag_JobOriginatingUserName > 0 || soap_flag_KOctetsProcessed > 0 || soap_flag_MediaSheetsCompleted > 0 || soap_flag_NumberOfDocuments > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobEndStateType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobEndStateType, 0, sizeof(struct wprt__JobEndStateType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobStatusType(struct soap *soap, const struct wprt__JobStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobIdType(soap, &a->JobId);
	soap_serialize_PointerTowprt__JobStateType(soap, &a->JobState);
	soap_serialize_PointerTowprt__JobStateReasonsType(soap, &a->JobStateReasons);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->KOctetsProcessed);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->MediaSheetsCompleted);
	soap_serialize_PointerTowprt__IntZeroExtType(soap, &a->NumberOfDocuments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobStatusType(struct soap *soap, struct wprt__JobStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobId = NULL;
	a->JobState = NULL;
	a->JobStateReasons = NULL;
	a->KOctetsProcessed = NULL;
	a->MediaSheetsCompleted = NULL;
	a->NumberOfDocuments = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobStatusType(struct soap *soap, const struct wprt__JobStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobStatusType);
	if (soap_out_wprt__JobStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobStatusType(struct soap *soap, const char *tag, int id, const struct wprt__JobStatusType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobStatusType), type);
	soap_out_PointerTowprt__JobIdType(soap, "wprt:JobId", -1, &a->JobId, "");
	soap_out_PointerTowprt__JobStateType(soap, "wprt:JobState", -1, &a->JobState, "");
	soap_out_PointerTowprt__JobStateReasonsType(soap, "wprt:JobStateReasons", -1, &a->JobStateReasons, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:KOctetsProcessed", -1, &a->KOctetsProcessed, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:MediaSheetsCompleted", -1, &a->MediaSheetsCompleted, "");
	soap_out_PointerTowprt__IntZeroExtType(soap, "wprt:NumberOfDocuments", -1, &a->NumberOfDocuments, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobStatusType * SOAP_FMAC4 soap_get_wprt__JobStatusType(struct soap *soap, struct wprt__JobStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobStatusType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStatusType * SOAP_FMAC4 soap_in_wprt__JobStatusType(struct soap *soap, const char *tag, struct wprt__JobStatusType *a, const char *type)
{
	short soap_flag_JobId = 1, soap_flag_JobState = 1, soap_flag_JobStateReasons = 1, soap_flag_KOctetsProcessed = 1, soap_flag_MediaSheetsCompleted = 1, soap_flag_NumberOfDocuments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobStatusType, sizeof(struct wprt__JobStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobStatusType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobIdType(soap, "JobId", &a->JobId, "wprt:JobIdType"))
				{	soap_flag_JobId--;
					continue;
				}
			if (soap_flag_JobState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobStateType(soap, "JobState", &a->JobState, "wprt:JobStateType"))
				{	soap_flag_JobState--;
					continue;
				}
			if (soap_flag_JobStateReasons && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobStateReasonsType(soap, "JobStateReasons", &a->JobStateReasons, "wprt:JobStateReasonsType"))
				{	soap_flag_JobStateReasons--;
					continue;
				}
			if (soap_flag_KOctetsProcessed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "KOctetsProcessed", &a->KOctetsProcessed, "wprt:IntZeroExtType"))
				{	soap_flag_KOctetsProcessed--;
					continue;
				}
			if (soap_flag_MediaSheetsCompleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "MediaSheetsCompleted", &a->MediaSheetsCompleted, "wprt:IntZeroExtType"))
				{	soap_flag_MediaSheetsCompleted--;
					continue;
				}
			if (soap_flag_NumberOfDocuments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntZeroExtType(soap, "NumberOfDocuments", &a->NumberOfDocuments, "wprt:IntZeroExtType"))
				{	soap_flag_NumberOfDocuments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobId > 0 || soap_flag_JobState > 0 || soap_flag_KOctetsProcessed > 0 || soap_flag_MediaSheetsCompleted > 0 || soap_flag_NumberOfDocuments > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobStatusType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobStatusType, 0, sizeof(struct wprt__JobStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobStatusEventType(struct soap *soap, const struct wprt__JobStatusEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobStatusType(soap, &a->JobStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobStatusEventType(struct soap *soap, struct wprt__JobStatusEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobStatus = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobStatusEventType(struct soap *soap, const struct wprt__JobStatusEventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobStatusEventType);
	if (soap_out_wprt__JobStatusEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobStatusEventType(struct soap *soap, const char *tag, int id, const struct wprt__JobStatusEventType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobStatusEventType), type);
	soap_out_PointerTowprt__JobStatusType(soap, "wprt:JobStatus", -1, &a->JobStatus, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobStatusEventType * SOAP_FMAC4 soap_get_wprt__JobStatusEventType(struct soap *soap, struct wprt__JobStatusEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobStatusEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStatusEventType * SOAP_FMAC4 soap_in_wprt__JobStatusEventType(struct soap *soap, const char *tag, struct wprt__JobStatusEventType *a, const char *type)
{
	short soap_flag_JobStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobStatusEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobStatusEventType, sizeof(struct wprt__JobStatusEventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobStatusEventType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobStatusType(soap, "JobStatus", &a->JobStatus, "wprt:JobStatusType"))
				{	soap_flag_JobStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobStatusEventType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobStatusEventType, 0, sizeof(struct wprt__JobStatusEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterStatusConditionClearedEventType(struct soap *soap, const struct wprt__PrinterStatusConditionClearedEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__DeviceConditionClearedType(soap, &a->DeviceConditionCleared);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStatusConditionClearedEventType(struct soap *soap, struct wprt__PrinterStatusConditionClearedEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DeviceConditionCleared = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStatusConditionClearedEventType(struct soap *soap, const struct wprt__PrinterStatusConditionClearedEventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType);
	if (soap_out_wprt__PrinterStatusConditionClearedEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStatusConditionClearedEventType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterStatusConditionClearedEventType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType), type);
	soap_out_PointerTowprt__DeviceConditionClearedType(soap, "wprt:DeviceConditionCleared", -1, &a->DeviceConditionCleared, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterStatusConditionClearedEventType * SOAP_FMAC4 soap_get_wprt__PrinterStatusConditionClearedEventType(struct soap *soap, struct wprt__PrinterStatusConditionClearedEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStatusConditionClearedEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStatusConditionClearedEventType * SOAP_FMAC4 soap_in_wprt__PrinterStatusConditionClearedEventType(struct soap *soap, const char *tag, struct wprt__PrinterStatusConditionClearedEventType *a, const char *type)
{
	short soap_flag_DeviceConditionCleared = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterStatusConditionClearedEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType, sizeof(struct wprt__PrinterStatusConditionClearedEventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterStatusConditionClearedEventType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceConditionCleared && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DeviceConditionClearedType(soap, "DeviceConditionCleared", &a->DeviceConditionCleared, "wprt:DeviceConditionClearedType"))
				{	soap_flag_DeviceConditionCleared--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DeviceConditionCleared > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStatusConditionClearedEventType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType, 0, sizeof(struct wprt__PrinterStatusConditionClearedEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DateTimeExtType(struct soap *soap, const struct wprt__DateTimeExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DateTimeExtType(struct soap *soap, struct wprt__DateTimeExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DateTimeExtType(struct soap *soap, const struct wprt__DateTimeExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DateTimeExtType);
	if (soap_out_wprt__DateTimeExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DateTimeExtType(struct soap *soap, const char *tag, int id, const struct wprt__DateTimeExtType *a, const char *type)
{
	return soap_out_time(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__DateTimeExtType * SOAP_FMAC4 soap_get_wprt__DateTimeExtType(struct soap *soap, struct wprt__DateTimeExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DateTimeExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DateTimeExtType * SOAP_FMAC4 soap_in_wprt__DateTimeExtType(struct soap *soap, const char *tag, struct wprt__DateTimeExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__DateTimeExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DateTimeExtType, sizeof(struct wprt__DateTimeExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__DateTimeExtType(soap, a);
	if (!soap_in_time(soap, tag, &a->__item, "wprt:DateTimeExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DeviceConditionClearedType(struct soap *soap, const struct wprt__DeviceConditionClearedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__DateTimeExtType(soap, &a->ConditionClearTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DeviceConditionClearedType(struct soap *soap, struct wprt__DeviceConditionClearedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__ConditionIdType(soap, &a->ConditionId);
	a->ConditionClearTime = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DeviceConditionClearedType(struct soap *soap, const struct wprt__DeviceConditionClearedType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DeviceConditionClearedType);
	if (soap_out_wprt__DeviceConditionClearedType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DeviceConditionClearedType(struct soap *soap, const char *tag, int id, const struct wprt__DeviceConditionClearedType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__DeviceConditionClearedType), type);
	soap_out_wprt__ConditionIdType(soap, "wprt:ConditionId", -1, &a->ConditionId, "");
	soap_out_PointerTowprt__DateTimeExtType(soap, "wprt:ConditionClearTime", -1, &a->ConditionClearTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__DeviceConditionClearedType * SOAP_FMAC4 soap_get_wprt__DeviceConditionClearedType(struct soap *soap, struct wprt__DeviceConditionClearedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DeviceConditionClearedType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DeviceConditionClearedType * SOAP_FMAC4 soap_in_wprt__DeviceConditionClearedType(struct soap *soap, const char *tag, struct wprt__DeviceConditionClearedType *a, const char *type)
{
	short soap_flag_ConditionId = 1, soap_flag_ConditionClearTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__DeviceConditionClearedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DeviceConditionClearedType, sizeof(struct wprt__DeviceConditionClearedType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__DeviceConditionClearedType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConditionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wprt__ConditionIdType(soap, "ConditionId", &a->ConditionId, "wprt:ConditionIdType"))
				{	soap_flag_ConditionId--;
					continue;
				}
			if (soap_flag_ConditionClearTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DateTimeExtType(soap, "ConditionClearTime", &a->ConditionClearTime, "wprt:DateTimeExtType"))
				{	soap_flag_ConditionClearTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConditionId > 0 || soap_flag_ConditionClearTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__DeviceConditionClearedType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__DeviceConditionClearedType, 0, sizeof(struct wprt__DeviceConditionClearedType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DeviceConditionType(struct soap *soap, const struct wprt__DeviceConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__DateTimeExtType(soap, &a->Time);
	soap_serialize_PointerTowprt__ConditionNameType(soap, &a->Name);
	soap_serialize_PointerTowprt__ConditionComponentType(soap, &a->Component);
	soap_serialize_PointerTowprt__ConditionSeverityType(soap, &a->Severity);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DeviceConditionType(struct soap *soap, struct wprt__DeviceConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Time = NULL;
	a->Name = NULL;
	a->Component = NULL;
	a->Severity = NULL;
	soap_default_wprt__ConditionIdType(soap, &a->Id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DeviceConditionType(struct soap *soap, const struct wprt__DeviceConditionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DeviceConditionType);
	if (soap_out_wprt__DeviceConditionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DeviceConditionType(struct soap *soap, const char *tag, int id, const struct wprt__DeviceConditionType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_int2s(soap, a->Id));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__DeviceConditionType), type);
	soap_out_PointerTowprt__DateTimeExtType(soap, "wprt:Time", -1, &a->Time, "");
	soap_out_PointerTowprt__ConditionNameType(soap, "wprt:Name", -1, &a->Name, "");
	soap_out_PointerTowprt__ConditionComponentType(soap, "wprt:Component", -1, &a->Component, "");
	soap_out_PointerTowprt__ConditionSeverityType(soap, "wprt:Severity", -1, &a->Severity, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__DeviceConditionType * SOAP_FMAC4 soap_get_wprt__DeviceConditionType(struct soap *soap, struct wprt__DeviceConditionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DeviceConditionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DeviceConditionType * SOAP_FMAC4 soap_in_wprt__DeviceConditionType(struct soap *soap, const char *tag, struct wprt__DeviceConditionType *a, const char *type)
{
	short soap_flag_Time = 1, soap_flag_Name = 1, soap_flag_Component = 1, soap_flag_Severity = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__DeviceConditionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DeviceConditionType, sizeof(struct wprt__DeviceConditionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__DeviceConditionType(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "Id", 1), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DateTimeExtType(soap, "Time", &a->Time, "wprt:DateTimeExtType"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConditionNameType(soap, "Name", &a->Name, "wprt:ConditionNameType"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Component && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConditionComponentType(soap, "Component", &a->Component, "wprt:ConditionComponentType"))
				{	soap_flag_Component--;
					continue;
				}
			if (soap_flag_Severity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConditionSeverityType(soap, "Severity", &a->Severity, "wprt:ConditionSeverityType"))
				{	soap_flag_Severity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0 || soap_flag_Name > 0 || soap_flag_Component > 0 || soap_flag_Severity > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__DeviceConditionType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__DeviceConditionType, 0, sizeof(struct wprt__DeviceConditionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterStatusConditionEventType(struct soap *soap, const struct wprt__PrinterStatusConditionEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__DeviceConditionType(soap, &a->DeviceCondition);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStatusConditionEventType(struct soap *soap, struct wprt__PrinterStatusConditionEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DeviceCondition = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStatusConditionEventType(struct soap *soap, const struct wprt__PrinterStatusConditionEventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStatusConditionEventType);
	if (soap_out_wprt__PrinterStatusConditionEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStatusConditionEventType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterStatusConditionEventType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterStatusConditionEventType), type);
	soap_out_PointerTowprt__DeviceConditionType(soap, "wprt:DeviceCondition", -1, &a->DeviceCondition, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterStatusConditionEventType * SOAP_FMAC4 soap_get_wprt__PrinterStatusConditionEventType(struct soap *soap, struct wprt__PrinterStatusConditionEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStatusConditionEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStatusConditionEventType * SOAP_FMAC4 soap_in_wprt__PrinterStatusConditionEventType(struct soap *soap, const char *tag, struct wprt__PrinterStatusConditionEventType *a, const char *type)
{
	short soap_flag_DeviceCondition = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterStatusConditionEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterStatusConditionEventType, sizeof(struct wprt__PrinterStatusConditionEventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterStatusConditionEventType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DeviceConditionType(soap, "DeviceCondition", &a->DeviceCondition, "wprt:DeviceConditionType"))
				{	soap_flag_DeviceCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DeviceCondition > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStatusConditionEventType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterStatusConditionEventType, 0, sizeof(struct wprt__PrinterStatusConditionEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterStatusSummaryEventType(struct soap *soap, const struct wprt__PrinterStatusSummaryEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__StatusSummaryType(soap, &a->StatusSummary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStatusSummaryEventType(struct soap *soap, struct wprt__PrinterStatusSummaryEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StatusSummary = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStatusSummaryEventType(struct soap *soap, const struct wprt__PrinterStatusSummaryEventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStatusSummaryEventType);
	if (soap_out_wprt__PrinterStatusSummaryEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStatusSummaryEventType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterStatusSummaryEventType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterStatusSummaryEventType), type);
	soap_out_PointerTowprt__StatusSummaryType(soap, "wprt:StatusSummary", -1, &a->StatusSummary, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterStatusSummaryEventType * SOAP_FMAC4 soap_get_wprt__PrinterStatusSummaryEventType(struct soap *soap, struct wprt__PrinterStatusSummaryEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStatusSummaryEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStatusSummaryEventType * SOAP_FMAC4 soap_in_wprt__PrinterStatusSummaryEventType(struct soap *soap, const char *tag, struct wprt__PrinterStatusSummaryEventType *a, const char *type)
{
	short soap_flag_StatusSummary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterStatusSummaryEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterStatusSummaryEventType, sizeof(struct wprt__PrinterStatusSummaryEventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterStatusSummaryEventType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StatusSummary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__StatusSummaryType(soap, "StatusSummary", &a->StatusSummary, "wprt:StatusSummaryType"))
				{	soap_flag_StatusSummary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StatusSummary > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStatusSummaryEventType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterStatusSummaryEventType, 0, sizeof(struct wprt__PrinterStatusSummaryEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterStateReasonsType(struct soap *soap, const struct wprt__PrinterStateReasonsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PrinterStateReason)
	{	int i;
		for (i = 0; i < a->__sizePrinterStateReason; i++)
		{
			soap_embedded(soap, a->PrinterStateReason + i, SOAP_TYPE_wprt__PrinterStateReasonType);
			soap_serialize_wprt__PrinterStateReasonType(soap, a->PrinterStateReason + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStateReasonsType(struct soap *soap, struct wprt__PrinterStateReasonsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePrinterStateReason = 0;
	a->PrinterStateReason = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStateReasonsType(struct soap *soap, const struct wprt__PrinterStateReasonsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStateReasonsType);
	if (soap_out_wprt__PrinterStateReasonsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStateReasonsType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterStateReasonsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterStateReasonsType), type);
	if (a->PrinterStateReason)
	{	int i;
		for (i = 0; i < a->__sizePrinterStateReason; i++)
			soap_out_wprt__PrinterStateReasonType(soap, "wprt:PrinterStateReason", -1, a->PrinterStateReason + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterStateReasonsType * SOAP_FMAC4 soap_get_wprt__PrinterStateReasonsType(struct soap *soap, struct wprt__PrinterStateReasonsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStateReasonsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStateReasonsType * SOAP_FMAC4 soap_in_wprt__PrinterStateReasonsType(struct soap *soap, const char *tag, struct wprt__PrinterStateReasonsType *a, const char *type)
{
	short soap_flag_PrinterStateReason = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterStateReasonsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterStateReasonsType, sizeof(struct wprt__PrinterStateReasonsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterStateReasonsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrinterStateReason && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__PrinterStateReasonType *p;
				soap_new_block(soap);
				for (a->__sizePrinterStateReason = 0; !soap_element_begin_in(soap, "PrinterStateReason", 1, NULL); a->__sizePrinterStateReason++)
				{	p = (struct wprt__PrinterStateReasonType *)soap_push_block(soap, sizeof(struct wprt__PrinterStateReasonType));
					soap_default_wprt__PrinterStateReasonType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__PrinterStateReasonType(soap, "PrinterStateReason", p, "wprt:PrinterStateReasonType"))
						break;
					soap_flag_PrinterStateReason = 0;
				}
				a->PrinterStateReason = (struct wprt__PrinterStateReasonType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_PrinterStateReason && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStateReasonsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterStateReasonsType, 0, sizeof(struct wprt__PrinterStateReasonsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterStateReasonType(struct soap *soap, const struct wprt__PrinterStateReasonType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__PrinterStateReasonBaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStateReasonType(struct soap *soap, struct wprt__PrinterStateReasonType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__PrinterStateReasonBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStateReasonType(struct soap *soap, const struct wprt__PrinterStateReasonType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStateReasonType);
	if (soap_out_wprt__PrinterStateReasonType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStateReasonType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterStateReasonType *a, const char *type)
{
	return soap_out_wprt__PrinterStateReasonBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__PrinterStateReasonType * SOAP_FMAC4 soap_get_wprt__PrinterStateReasonType(struct soap *soap, struct wprt__PrinterStateReasonType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStateReasonType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStateReasonType * SOAP_FMAC4 soap_in_wprt__PrinterStateReasonType(struct soap *soap, const char *tag, struct wprt__PrinterStateReasonType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__PrinterStateReasonType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterStateReasonType, sizeof(struct wprt__PrinterStateReasonType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__PrinterStateReasonType(soap, a);
	if (!soap_in_wprt__PrinterStateReasonBaseType(soap, tag, &a->__item, "wprt:PrinterStateReasonType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterStateType(struct soap *soap, const struct wprt__PrinterStateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wprt__PrinterStateBaseType(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStateType(struct soap *soap, struct wprt__PrinterStateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__PrinterStateBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStateType(struct soap *soap, const struct wprt__PrinterStateType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStateType);
	if (soap_out_wprt__PrinterStateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStateType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterStateType *a, const char *type)
{
	return soap_out_wprt__PrinterStateBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__PrinterStateType * SOAP_FMAC4 soap_get_wprt__PrinterStateType(struct soap *soap, struct wprt__PrinterStateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStateType * SOAP_FMAC4 soap_in_wprt__PrinterStateType(struct soap *soap, const char *tag, struct wprt__PrinterStateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__PrinterStateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterStateType, sizeof(struct wprt__PrinterStateType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__PrinterStateType(soap, a);
	if (!soap_in_wprt__PrinterStateBaseType(soap, tag, &a->__item, "wprt:PrinterStateType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StatusSummaryType(struct soap *soap, const struct wprt__StatusSummaryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrinterStateType(soap, &a->PrinterState);
	soap_serialize_PointerTowprt__PrinterStateReasonType(soap, &a->PrinterPrimaryStateReason);
	soap_serialize_PointerTowprt__PrinterStateReasonsType(soap, &a->PrinterStateReasons);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StatusSummaryType(struct soap *soap, struct wprt__StatusSummaryType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PrinterState = NULL;
	a->PrinterPrimaryStateReason = NULL;
	a->PrinterStateReasons = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StatusSummaryType(struct soap *soap, const struct wprt__StatusSummaryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StatusSummaryType);
	if (soap_out_wprt__StatusSummaryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StatusSummaryType(struct soap *soap, const char *tag, int id, const struct wprt__StatusSummaryType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__StatusSummaryType), type);
	soap_out_PointerTowprt__PrinterStateType(soap, "wprt:PrinterState", -1, &a->PrinterState, "");
	soap_out_PointerTowprt__PrinterStateReasonType(soap, "wprt:PrinterPrimaryStateReason", -1, &a->PrinterPrimaryStateReason, "");
	soap_out_PointerTowprt__PrinterStateReasonsType(soap, "wprt:PrinterStateReasons", -1, &a->PrinterStateReasons, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__StatusSummaryType * SOAP_FMAC4 soap_get_wprt__StatusSummaryType(struct soap *soap, struct wprt__StatusSummaryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StatusSummaryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StatusSummaryType * SOAP_FMAC4 soap_in_wprt__StatusSummaryType(struct soap *soap, const char *tag, struct wprt__StatusSummaryType *a, const char *type)
{
	short soap_flag_PrinterState = 1, soap_flag_PrinterPrimaryStateReason = 1, soap_flag_PrinterStateReasons = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__StatusSummaryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__StatusSummaryType, sizeof(struct wprt__StatusSummaryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__StatusSummaryType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrinterState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStateType(soap, "PrinterState", &a->PrinterState, "wprt:PrinterStateType"))
				{	soap_flag_PrinterState--;
					continue;
				}
			if (soap_flag_PrinterPrimaryStateReason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStateReasonType(soap, "PrinterPrimaryStateReason", &a->PrinterPrimaryStateReason, "wprt:PrinterStateReasonType"))
				{	soap_flag_PrinterPrimaryStateReason--;
					continue;
				}
			if (soap_flag_PrinterStateReasons && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterStateReasonsType(soap, "PrinterStateReasons", &a->PrinterStateReasons, "wprt:PrinterStateReasonsType"))
				{	soap_flag_PrinterStateReasons--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PrinterState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__StatusSummaryType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__StatusSummaryType, 0, sizeof(struct wprt__StatusSummaryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterElementsChangeEventType(struct soap *soap, const struct wprt__PrinterElementsChangeEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ElementChangesType(soap, &a->ElementChanges);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterElementsChangeEventType(struct soap *soap, struct wprt__PrinterElementsChangeEventType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ElementChanges = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterElementsChangeEventType(struct soap *soap, const struct wprt__PrinterElementsChangeEventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterElementsChangeEventType);
	if (soap_out_wprt__PrinterElementsChangeEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterElementsChangeEventType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterElementsChangeEventType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterElementsChangeEventType), type);
	soap_out_PointerTowprt__ElementChangesType(soap, "wprt:ElementChanges", -1, &a->ElementChanges, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterElementsChangeEventType * SOAP_FMAC4 soap_get_wprt__PrinterElementsChangeEventType(struct soap *soap, struct wprt__PrinterElementsChangeEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterElementsChangeEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterElementsChangeEventType * SOAP_FMAC4 soap_in_wprt__PrinterElementsChangeEventType(struct soap *soap, const char *tag, struct wprt__PrinterElementsChangeEventType *a, const char *type)
{
	short soap_flag_ElementChanges = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterElementsChangeEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterElementsChangeEventType, sizeof(struct wprt__PrinterElementsChangeEventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterElementsChangeEventType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ElementChanges && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ElementChangesType(soap, "ElementChanges", &a->ElementChanges, "wprt:ElementChangesType"))
				{	soap_flag_ElementChanges--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ElementChanges > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterElementsChangeEventType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterElementsChangeEventType, 0, sizeof(struct wprt__PrinterElementsChangeEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterCapabilitiesType(struct soap *soap, const struct wprt__PrinterCapabilitiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobValuesType(soap, &a->JobValues);
	soap_serialize_PointerTowprt__DocumentValuesType(soap, &a->DocumentValues);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterCapabilitiesType(struct soap *soap, struct wprt__PrinterCapabilitiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobValues = NULL;
	a->DocumentValues = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterCapabilitiesType(struct soap *soap, const struct wprt__PrinterCapabilitiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterCapabilitiesType);
	if (soap_out_wprt__PrinterCapabilitiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterCapabilitiesType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterCapabilitiesType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterCapabilitiesType), type);
	soap_out_PointerTowprt__JobValuesType(soap, "wprt:JobValues", -1, &a->JobValues, "");
	soap_out_PointerTowprt__DocumentValuesType(soap, "wprt:DocumentValues", -1, &a->DocumentValues, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterCapabilitiesType * SOAP_FMAC4 soap_get_wprt__PrinterCapabilitiesType(struct soap *soap, struct wprt__PrinterCapabilitiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterCapabilitiesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterCapabilitiesType * SOAP_FMAC4 soap_in_wprt__PrinterCapabilitiesType(struct soap *soap, const char *tag, struct wprt__PrinterCapabilitiesType *a, const char *type)
{
	short soap_flag_JobValues = 1, soap_flag_DocumentValues = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterCapabilitiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterCapabilitiesType, sizeof(struct wprt__PrinterCapabilitiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterCapabilitiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobValuesType(soap, "JobValues", &a->JobValues, "wprt:JobValuesType"))
				{	soap_flag_JobValues--;
					continue;
				}
			if (soap_flag_DocumentValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentValuesType(soap, "DocumentValues", &a->DocumentValues, "wprt:DocumentValuesType"))
				{	soap_flag_DocumentValues--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterCapabilitiesType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterCapabilitiesType, 0, sizeof(struct wprt__PrinterCapabilitiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterConfigurationType(struct soap *soap, const struct wprt__PrinterConfigurationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__EventRateType(soap, &a->PrinterEventRate);
	soap_serialize_PointerTowprt__StorageBaseType(soap, &a->Storage);
	soap_serialize_PointerTowprt__ConsumablesType(soap, &a->Consumables);
	soap_serialize_PointerTowprt__InputBinsType(soap, &a->InputBins);
	soap_serialize_PointerTowprt__FinishingsType(soap, &a->Finishings);
	soap_serialize_PointerTowprt__OutputBinsType(soap, &a->OutputBins);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterConfigurationType(struct soap *soap, struct wprt__PrinterConfigurationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PrinterEventRate = NULL;
	a->Storage = NULL;
	a->Consumables = NULL;
	a->InputBins = NULL;
	a->Finishings = NULL;
	a->OutputBins = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterConfigurationType(struct soap *soap, const struct wprt__PrinterConfigurationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterConfigurationType);
	if (soap_out_wprt__PrinterConfigurationType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterConfigurationType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterConfigurationType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterConfigurationType), type);
	soap_out_PointerTowprt__EventRateType(soap, "wprt:PrinterEventRate", -1, &a->PrinterEventRate, "");
	soap_out_PointerTowprt__StorageBaseType(soap, "wprt:Storage", -1, &a->Storage, "");
	soap_out_PointerTowprt__ConsumablesType(soap, "wprt:Consumables", -1, &a->Consumables, "");
	soap_out_PointerTowprt__InputBinsType(soap, "wprt:InputBins", -1, &a->InputBins, "");
	soap_out_PointerTowprt__FinishingsType(soap, "wprt:Finishings", -1, &a->Finishings, "");
	soap_out_PointerTowprt__OutputBinsType(soap, "wprt:OutputBins", -1, &a->OutputBins, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterConfigurationType * SOAP_FMAC4 soap_get_wprt__PrinterConfigurationType(struct soap *soap, struct wprt__PrinterConfigurationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterConfigurationType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterConfigurationType * SOAP_FMAC4 soap_in_wprt__PrinterConfigurationType(struct soap *soap, const char *tag, struct wprt__PrinterConfigurationType *a, const char *type)
{
	short soap_flag_PrinterEventRate = 1, soap_flag_Storage = 1, soap_flag_Consumables = 1, soap_flag_InputBins = 1, soap_flag_Finishings = 1, soap_flag_OutputBins = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterConfigurationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterConfigurationType, sizeof(struct wprt__PrinterConfigurationType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterConfigurationType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrinterEventRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__EventRateType(soap, "PrinterEventRate", &a->PrinterEventRate, "wprt:EventRateType"))
				{	soap_flag_PrinterEventRate--;
					continue;
				}
			if (soap_flag_Storage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__StorageBaseType(soap, "Storage", &a->Storage, "wprt:StorageBaseType"))
				{	soap_flag_Storage--;
					continue;
				}
			if (soap_flag_Consumables && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ConsumablesType(soap, "Consumables", &a->Consumables, "wprt:ConsumablesType"))
				{	soap_flag_Consumables--;
					continue;
				}
			if (soap_flag_InputBins && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__InputBinsType(soap, "InputBins", &a->InputBins, "wprt:InputBinsType"))
				{	soap_flag_InputBins--;
					continue;
				}
			if (soap_flag_Finishings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__FinishingsType(soap, "Finishings", &a->Finishings, "wprt:FinishingsType"))
				{	soap_flag_Finishings--;
					continue;
				}
			if (soap_flag_OutputBins && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__OutputBinsType(soap, "OutputBins", &a->OutputBins, "wprt:OutputBinsType"))
				{	soap_flag_OutputBins--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterConfigurationType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterConfigurationType, 0, sizeof(struct wprt__PrinterConfigurationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterDescriptionType(struct soap *soap, const struct wprt__PrinterDescriptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__BoolExtType(soap, &a->ColorSupported);
	soap_serialize_PointerTowprt__DeviceIdType(soap, &a->DeviceId);
	soap_serialize_PointerTowprt__BoolExtType(soap, &a->MultipleDocumentJobsSupported);
	soap_serialize_PointerTowprt__IntOneExtType(soap, &a->PagesPerMinute);
	soap_serialize_PointerTowprt__IntOneExtType(soap, &a->PagesPerMinuteColor);
	if (a->PrinterName)
	{	int i;
		for (i = 0; i < a->__sizePrinterName; i++)
		{
			soap_embedded(soap, a->PrinterName + i, SOAP_TYPE_wprt__LocalizedStringType);
			soap_serialize_wprt__LocalizedStringType(soap, a->PrinterName + i);
		}
	}
	if (a->PrinterInfo)
	{	int i;
		for (i = 0; i < a->__sizePrinterInfo; i++)
		{
			soap_embedded(soap, a->PrinterInfo + i, SOAP_TYPE_wprt__LocalizedStringType);
			soap_serialize_wprt__LocalizedStringType(soap, a->PrinterInfo + i);
		}
	}
	if (a->PrinterLocation)
	{	int i;
		for (i = 0; i < a->__sizePrinterLocation; i++)
		{
			soap_embedded(soap, a->PrinterLocation + i, SOAP_TYPE_wprt__LocalizedStringType);
			soap_serialize_wprt__LocalizedStringType(soap, a->PrinterLocation + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterDescriptionType(struct soap *soap, struct wprt__PrinterDescriptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ColorSupported = NULL;
	a->DeviceId = NULL;
	a->MultipleDocumentJobsSupported = NULL;
	a->PagesPerMinute = NULL;
	a->PagesPerMinuteColor = NULL;
	a->__sizePrinterName = 0;
	a->PrinterName = NULL;
	a->__sizePrinterInfo = 0;
	a->PrinterInfo = NULL;
	a->__sizePrinterLocation = 0;
	a->PrinterLocation = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterDescriptionType(struct soap *soap, const struct wprt__PrinterDescriptionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterDescriptionType);
	if (soap_out_wprt__PrinterDescriptionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterDescriptionType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterDescriptionType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterDescriptionType), type);
	soap_out_PointerTowprt__BoolExtType(soap, "wprt:ColorSupported", -1, &a->ColorSupported, "");
	soap_out_PointerTowprt__DeviceIdType(soap, "wprt:DeviceId", -1, &a->DeviceId, "");
	soap_out_PointerTowprt__BoolExtType(soap, "wprt:MultipleDocumentJobsSupported", -1, &a->MultipleDocumentJobsSupported, "");
	soap_out_PointerTowprt__IntOneExtType(soap, "wprt:PagesPerMinute", -1, &a->PagesPerMinute, "");
	soap_out_PointerTowprt__IntOneExtType(soap, "wprt:PagesPerMinuteColor", -1, &a->PagesPerMinuteColor, "");
	if (a->PrinterName)
	{	int i;
		for (i = 0; i < a->__sizePrinterName; i++)
			soap_out_wprt__LocalizedStringType(soap, "wprt:PrinterName", -1, a->PrinterName + i, "");
	}
	if (a->PrinterInfo)
	{	int i;
		for (i = 0; i < a->__sizePrinterInfo; i++)
			soap_out_wprt__LocalizedStringType(soap, "wprt:PrinterInfo", -1, a->PrinterInfo + i, "");
	}
	if (a->PrinterLocation)
	{	int i;
		for (i = 0; i < a->__sizePrinterLocation; i++)
			soap_out_wprt__LocalizedStringType(soap, "wprt:PrinterLocation", -1, a->PrinterLocation + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterDescriptionType * SOAP_FMAC4 soap_get_wprt__PrinterDescriptionType(struct soap *soap, struct wprt__PrinterDescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterDescriptionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterDescriptionType * SOAP_FMAC4 soap_in_wprt__PrinterDescriptionType(struct soap *soap, const char *tag, struct wprt__PrinterDescriptionType *a, const char *type)
{
	short soap_flag_ColorSupported = 1, soap_flag_DeviceId = 1, soap_flag_MultipleDocumentJobsSupported = 1, soap_flag_PagesPerMinute = 1, soap_flag_PagesPerMinuteColor = 1, soap_flag_PrinterName = 1, soap_flag_PrinterInfo = 1, soap_flag_PrinterLocation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterDescriptionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterDescriptionType, sizeof(struct wprt__PrinterDescriptionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterDescriptionType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ColorSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BoolExtType(soap, "ColorSupported", &a->ColorSupported, "wprt:BoolExtType"))
				{	soap_flag_ColorSupported--;
					continue;
				}
			if (soap_flag_DeviceId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DeviceIdType(soap, "DeviceId", &a->DeviceId, "wprt:DeviceIdType"))
				{	soap_flag_DeviceId--;
					continue;
				}
			if (soap_flag_MultipleDocumentJobsSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BoolExtType(soap, "MultipleDocumentJobsSupported", &a->MultipleDocumentJobsSupported, "wprt:BoolExtType"))
				{	soap_flag_MultipleDocumentJobsSupported--;
					continue;
				}
			if (soap_flag_PagesPerMinute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntOneExtType(soap, "PagesPerMinute", &a->PagesPerMinute, "wprt:IntOneExtType"))
				{	soap_flag_PagesPerMinute--;
					continue;
				}
			if (soap_flag_PagesPerMinuteColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__IntOneExtType(soap, "PagesPerMinuteColor", &a->PagesPerMinuteColor, "wprt:IntOneExtType"))
				{	soap_flag_PagesPerMinuteColor--;
					continue;
				}
			if (soap_flag_PrinterName && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__LocalizedStringType *p;
				soap_new_block(soap);
				for (a->__sizePrinterName = 0; !soap_element_begin_in(soap, "PrinterName", 1, NULL); a->__sizePrinterName++)
				{	p = (struct wprt__LocalizedStringType *)soap_push_block(soap, sizeof(struct wprt__LocalizedStringType));
					soap_default_wprt__LocalizedStringType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__LocalizedStringType(soap, "PrinterName", p, "wprt:LocalizedStringType"))
						break;
					soap_flag_PrinterName = 0;
				}
				a->PrinterName = (struct wprt__LocalizedStringType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_PrinterName && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_PrinterInfo && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__LocalizedStringType *p;
				soap_new_block(soap);
				for (a->__sizePrinterInfo = 0; !soap_element_begin_in(soap, "PrinterInfo", 1, NULL); a->__sizePrinterInfo++)
				{	p = (struct wprt__LocalizedStringType *)soap_push_block(soap, sizeof(struct wprt__LocalizedStringType));
					soap_default_wprt__LocalizedStringType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__LocalizedStringType(soap, "PrinterInfo", p, "wprt:LocalizedStringType"))
						break;
					soap_flag_PrinterInfo = 0;
				}
				a->PrinterInfo = (struct wprt__LocalizedStringType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_PrinterInfo && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_PrinterLocation && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__LocalizedStringType *p;
				soap_new_block(soap);
				for (a->__sizePrinterLocation = 0; !soap_element_begin_in(soap, "PrinterLocation", 1, NULL); a->__sizePrinterLocation++)
				{	p = (struct wprt__LocalizedStringType *)soap_push_block(soap, sizeof(struct wprt__LocalizedStringType));
					soap_default_wprt__LocalizedStringType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__LocalizedStringType(soap, "PrinterLocation", p, "wprt:LocalizedStringType"))
						break;
					soap_flag_PrinterLocation = 0;
				}
				a->PrinterLocation = (struct wprt__LocalizedStringType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_PrinterLocation && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ColorSupported > 0 || soap_flag_DeviceId > 0 || soap_flag_PagesPerMinute > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterDescriptionType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterDescriptionType, 0, sizeof(struct wprt__PrinterDescriptionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ElementChangesType(struct soap *soap, const struct wprt__ElementChangesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrinterDescriptionType(soap, &a->PrinterDescription);
	soap_serialize_PointerTowprt__PrinterConfigurationType(soap, &a->PrinterConfiguration);
	soap_serialize_PointerTowprt__PrintTicketType(soap, &a->DefaultPrintTicket);
	soap_serialize_PointerTowprt__PrinterCapabilitiesType(soap, &a->PrinterCapabilities);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ElementChangesType(struct soap *soap, struct wprt__ElementChangesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PrinterDescription = NULL;
	a->PrinterConfiguration = NULL;
	a->DefaultPrintTicket = NULL;
	a->PrinterCapabilities = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ElementChangesType(struct soap *soap, const struct wprt__ElementChangesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ElementChangesType);
	if (soap_out_wprt__ElementChangesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ElementChangesType(struct soap *soap, const char *tag, int id, const struct wprt__ElementChangesType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ElementChangesType), type);
	soap_out_PointerTowprt__PrinterDescriptionType(soap, "wprt:PrinterDescription", -1, &a->PrinterDescription, "");
	soap_out_PointerTowprt__PrinterConfigurationType(soap, "wprt:PrinterConfiguration", -1, &a->PrinterConfiguration, "");
	soap_out_PointerTowprt__PrintTicketType(soap, "wprt:DefaultPrintTicket", -1, &a->DefaultPrintTicket, "");
	soap_out_PointerTowprt__PrinterCapabilitiesType(soap, "wprt:PrinterCapabilities", -1, &a->PrinterCapabilities, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ElementChangesType * SOAP_FMAC4 soap_get_wprt__ElementChangesType(struct soap *soap, struct wprt__ElementChangesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ElementChangesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ElementChangesType * SOAP_FMAC4 soap_in_wprt__ElementChangesType(struct soap *soap, const char *tag, struct wprt__ElementChangesType *a, const char *type)
{
	short soap_flag_PrinterDescription = 1, soap_flag_PrinterConfiguration = 1, soap_flag_DefaultPrintTicket = 1, soap_flag_PrinterCapabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ElementChangesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ElementChangesType, sizeof(struct wprt__ElementChangesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ElementChangesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrinterDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterDescriptionType(soap, "PrinterDescription", &a->PrinterDescription, "wprt:PrinterDescriptionType"))
				{	soap_flag_PrinterDescription--;
					continue;
				}
			if (soap_flag_PrinterConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterConfigurationType(soap, "PrinterConfiguration", &a->PrinterConfiguration, "wprt:PrinterConfigurationType"))
				{	soap_flag_PrinterConfiguration--;
					continue;
				}
			if (soap_flag_DefaultPrintTicket && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrintTicketType(soap, "DefaultPrintTicket", &a->DefaultPrintTicket, "wprt:PrintTicketType"))
				{	soap_flag_DefaultPrintTicket--;
					continue;
				}
			if (soap_flag_PrinterCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterCapabilitiesType(soap, "PrinterCapabilities", &a->PrinterCapabilities, "wprt:PrinterCapabilitiesType"))
				{	soap_flag_PrinterCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ElementChangesType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ElementChangesType, 0, sizeof(struct wprt__ElementChangesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__SetEventRateResponseType(struct soap *soap, const struct wprt__SetEventRateResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__SetEventRateResponseType(struct soap *soap, struct wprt__SetEventRateResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__SetEventRateResponseType(struct soap *soap, const struct wprt__SetEventRateResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__SetEventRateResponseType);
	if (soap_out_wprt__SetEventRateResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__SetEventRateResponseType(struct soap *soap, const char *tag, int id, const struct wprt__SetEventRateResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__SetEventRateResponseType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__SetEventRateResponseType * SOAP_FMAC4 soap_get_wprt__SetEventRateResponseType(struct soap *soap, struct wprt__SetEventRateResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__SetEventRateResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SetEventRateResponseType * SOAP_FMAC4 soap_in_wprt__SetEventRateResponseType(struct soap *soap, const char *tag, struct wprt__SetEventRateResponseType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__SetEventRateResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__SetEventRateResponseType, sizeof(struct wprt__SetEventRateResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__SetEventRateResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__SetEventRateResponseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__SetEventRateResponseType, 0, sizeof(struct wprt__SetEventRateResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__EventRateType(struct soap *soap, const struct wprt__EventRateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__EventRateType(struct soap *soap, struct wprt__EventRateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__EventRateBaseType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__EventRateType(struct soap *soap, const struct wprt__EventRateType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__EventRateType);
	if (soap_out_wprt__EventRateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__EventRateType(struct soap *soap, const char *tag, int id, const struct wprt__EventRateType *a, const char *type)
{
	return soap_out_wprt__EventRateBaseType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__EventRateType * SOAP_FMAC4 soap_get_wprt__EventRateType(struct soap *soap, struct wprt__EventRateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__EventRateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__EventRateType * SOAP_FMAC4 soap_in_wprt__EventRateType(struct soap *soap, const char *tag, struct wprt__EventRateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__EventRateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__EventRateType, sizeof(struct wprt__EventRateType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__EventRateType(soap, a);
	if (!soap_in_wprt__EventRateBaseType(soap, tag, &a->__item, "wprt:EventRateType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__SetEventRateRequestType(struct soap *soap, const struct wprt__SetEventRateRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__EventRateType(soap, &a->EventRate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__SetEventRateRequestType(struct soap *soap, struct wprt__SetEventRateRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EventRate = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__SetEventRateRequestType(struct soap *soap, const struct wprt__SetEventRateRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__SetEventRateRequestType);
	if (soap_out_wprt__SetEventRateRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__SetEventRateRequestType(struct soap *soap, const char *tag, int id, const struct wprt__SetEventRateRequestType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__SetEventRateRequestType), type);
	soap_out_PointerTowprt__EventRateType(soap, "wprt:EventRate", -1, &a->EventRate, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__SetEventRateRequestType * SOAP_FMAC4 soap_get_wprt__SetEventRateRequestType(struct soap *soap, struct wprt__SetEventRateRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__SetEventRateRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SetEventRateRequestType * SOAP_FMAC4 soap_in_wprt__SetEventRateRequestType(struct soap *soap, const char *tag, struct wprt__SetEventRateRequestType *a, const char *type)
{
	short soap_flag_EventRate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__SetEventRateRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__SetEventRateRequestType, sizeof(struct wprt__SetEventRateRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__SetEventRateRequestType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__EventRateType(soap, "EventRate", &a->EventRate, "wprt:EventRateType"))
				{	soap_flag_EventRate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EventRate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__SetEventRateRequestType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__SetEventRateRequestType, 0, sizeof(struct wprt__SetEventRateRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__GetJobHistoryResponseType(struct soap *soap, const struct wprt__GetJobHistoryResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ListOfSummarysType(soap, &a->JobHistory);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__GetJobHistoryResponseType(struct soap *soap, struct wprt__GetJobHistoryResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobHistory = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__GetJobHistoryResponseType(struct soap *soap, const struct wprt__GetJobHistoryResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__GetJobHistoryResponseType);
	if (soap_out_wprt__GetJobHistoryResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__GetJobHistoryResponseType(struct soap *soap, const char *tag, int id, const struct wprt__GetJobHistoryResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__GetJobHistoryResponseType), type);
	if (a->JobHistory)
		soap_element_result(soap, "JobHistory");
	soap_out_PointerTowprt__ListOfSummarysType(soap, "wprt:JobHistory", -1, &a->JobHistory, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__GetJobHistoryResponseType * SOAP_FMAC4 soap_get_wprt__GetJobHistoryResponseType(struct soap *soap, struct wprt__GetJobHistoryResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__GetJobHistoryResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetJobHistoryResponseType * SOAP_FMAC4 soap_in_wprt__GetJobHistoryResponseType(struct soap *soap, const char *tag, struct wprt__GetJobHistoryResponseType *a, const char *type)
{
	short soap_flag_JobHistory = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__GetJobHistoryResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__GetJobHistoryResponseType, sizeof(struct wprt__GetJobHistoryResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__GetJobHistoryResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobHistory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ListOfSummarysType(soap, "JobHistory", &a->JobHistory, "wprt:ListOfSummarysType"))
				{	soap_flag_JobHistory--;
					continue;
				}
			soap_check_result(soap, "JobHistory");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobHistory > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__GetJobHistoryResponseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__GetJobHistoryResponseType, 0, sizeof(struct wprt__GetJobHistoryResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__GetJobHistoryRequestType(struct soap *soap, const struct wprt__GetJobHistoryRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__GetJobHistoryRequestType(struct soap *soap, struct wprt__GetJobHistoryRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__GetJobHistoryRequestType(struct soap *soap, const struct wprt__GetJobHistoryRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__GetJobHistoryRequestType);
	if (soap_out_wprt__GetJobHistoryRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__GetJobHistoryRequestType(struct soap *soap, const char *tag, int id, const struct wprt__GetJobHistoryRequestType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__GetJobHistoryRequestType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__GetJobHistoryRequestType * SOAP_FMAC4 soap_get_wprt__GetJobHistoryRequestType(struct soap *soap, struct wprt__GetJobHistoryRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__GetJobHistoryRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetJobHistoryRequestType * SOAP_FMAC4 soap_in_wprt__GetJobHistoryRequestType(struct soap *soap, const char *tag, struct wprt__GetJobHistoryRequestType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__GetJobHistoryRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__GetJobHistoryRequestType, sizeof(struct wprt__GetJobHistoryRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__GetJobHistoryRequestType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__GetJobHistoryRequestType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__GetJobHistoryRequestType, 0, sizeof(struct wprt__GetJobHistoryRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ListOfSummarysType(struct soap *soap, const struct wprt__ListOfSummarysType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->JobSummary)
	{	int i;
		for (i = 0; i < a->__sizeJobSummary; i++)
		{
			soap_embedded(soap, a->JobSummary + i, SOAP_TYPE_wprt__JobSummaryType);
			soap_serialize_wprt__JobSummaryType(soap, a->JobSummary + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ListOfSummarysType(struct soap *soap, struct wprt__ListOfSummarysType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeJobSummary = 0;
	a->JobSummary = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ListOfSummarysType(struct soap *soap, const struct wprt__ListOfSummarysType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ListOfSummarysType);
	if (soap_out_wprt__ListOfSummarysType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ListOfSummarysType(struct soap *soap, const char *tag, int id, const struct wprt__ListOfSummarysType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__ListOfSummarysType), type);
	if (a->JobSummary)
	{	int i;
		for (i = 0; i < a->__sizeJobSummary; i++)
			soap_out_wprt__JobSummaryType(soap, "wprt:JobSummary", -1, a->JobSummary + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__ListOfSummarysType * SOAP_FMAC4 soap_get_wprt__ListOfSummarysType(struct soap *soap, struct wprt__ListOfSummarysType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ListOfSummarysType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ListOfSummarysType * SOAP_FMAC4 soap_in_wprt__ListOfSummarysType(struct soap *soap, const char *tag, struct wprt__ListOfSummarysType *a, const char *type)
{
	short soap_flag_JobSummary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__ListOfSummarysType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__ListOfSummarysType, sizeof(struct wprt__ListOfSummarysType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__ListOfSummarysType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobSummary && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__JobSummaryType *p;
				soap_new_block(soap);
				for (a->__sizeJobSummary = 0; !soap_element_begin_in(soap, "JobSummary", 1, NULL); a->__sizeJobSummary++)
				{	p = (struct wprt__JobSummaryType *)soap_push_block(soap, sizeof(struct wprt__JobSummaryType));
					soap_default_wprt__JobSummaryType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__JobSummaryType(soap, "JobSummary", p, "wprt:JobSummaryType"))
						break;
					soap_flag_JobSummary = 0;
				}
				a->JobSummary = (struct wprt__JobSummaryType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_JobSummary && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__ListOfSummarysType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__ListOfSummarysType, 0, sizeof(struct wprt__ListOfSummarysType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__GetActiveJobsResponseType(struct soap *soap, const struct wprt__GetActiveJobsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__ListOfSummarysType(soap, &a->ActiveJobs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__GetActiveJobsResponseType(struct soap *soap, struct wprt__GetActiveJobsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActiveJobs = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__GetActiveJobsResponseType(struct soap *soap, const struct wprt__GetActiveJobsResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__GetActiveJobsResponseType);
	if (soap_out_wprt__GetActiveJobsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__GetActiveJobsResponseType(struct soap *soap, const char *tag, int id, const struct wprt__GetActiveJobsResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__GetActiveJobsResponseType), type);
	if (a->ActiveJobs)
		soap_element_result(soap, "ActiveJobs");
	soap_out_PointerTowprt__ListOfSummarysType(soap, "wprt:ActiveJobs", -1, &a->ActiveJobs, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__GetActiveJobsResponseType * SOAP_FMAC4 soap_get_wprt__GetActiveJobsResponseType(struct soap *soap, struct wprt__GetActiveJobsResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__GetActiveJobsResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetActiveJobsResponseType * SOAP_FMAC4 soap_in_wprt__GetActiveJobsResponseType(struct soap *soap, const char *tag, struct wprt__GetActiveJobsResponseType *a, const char *type)
{
	short soap_flag_ActiveJobs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__GetActiveJobsResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__GetActiveJobsResponseType, sizeof(struct wprt__GetActiveJobsResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__GetActiveJobsResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActiveJobs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ListOfSummarysType(soap, "ActiveJobs", &a->ActiveJobs, "wprt:ListOfSummarysType"))
				{	soap_flag_ActiveJobs--;
					continue;
				}
			soap_check_result(soap, "ActiveJobs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActiveJobs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__GetActiveJobsResponseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__GetActiveJobsResponseType, 0, sizeof(struct wprt__GetActiveJobsResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__GetActiveJobsRequestType(struct soap *soap, const struct wprt__GetActiveJobsRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__GetActiveJobsRequestType(struct soap *soap, struct wprt__GetActiveJobsRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__GetActiveJobsRequestType(struct soap *soap, const struct wprt__GetActiveJobsRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__GetActiveJobsRequestType);
	if (soap_out_wprt__GetActiveJobsRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__GetActiveJobsRequestType(struct soap *soap, const char *tag, int id, const struct wprt__GetActiveJobsRequestType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__GetActiveJobsRequestType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__GetActiveJobsRequestType * SOAP_FMAC4 soap_get_wprt__GetActiveJobsRequestType(struct soap *soap, struct wprt__GetActiveJobsRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__GetActiveJobsRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetActiveJobsRequestType * SOAP_FMAC4 soap_in_wprt__GetActiveJobsRequestType(struct soap *soap, const char *tag, struct wprt__GetActiveJobsRequestType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__GetActiveJobsRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__GetActiveJobsRequestType, sizeof(struct wprt__GetActiveJobsRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__GetActiveJobsRequestType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__GetActiveJobsRequestType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__GetActiveJobsRequestType, 0, sizeof(struct wprt__GetActiveJobsRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobElementsType(struct soap *soap, const struct wprt__JobElementsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ElementData)
	{	int i;
		for (i = 0; i < a->__sizeElementData; i++)
		{
			soap_embedded(soap, a->ElementData + i, SOAP_TYPE_wprt__JobElementDataType);
			soap_serialize_wprt__JobElementDataType(soap, a->ElementData + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobElementsType(struct soap *soap, struct wprt__JobElementsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeElementData = 0;
	a->ElementData = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobElementsType(struct soap *soap, const struct wprt__JobElementsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobElementsType);
	if (soap_out_wprt__JobElementsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobElementsType(struct soap *soap, const char *tag, int id, const struct wprt__JobElementsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__JobElementsType), type);
	if (a->ElementData)
	{	int i;
		for (i = 0; i < a->__sizeElementData; i++)
			soap_out_wprt__JobElementDataType(soap, "wprt:ElementData", -1, a->ElementData + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__JobElementsType * SOAP_FMAC4 soap_get_wprt__JobElementsType(struct soap *soap, struct wprt__JobElementsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobElementsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobElementsType * SOAP_FMAC4 soap_in_wprt__JobElementsType(struct soap *soap, const char *tag, struct wprt__JobElementsType *a, const char *type)
{
	short soap_flag_ElementData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__JobElementsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobElementsType, sizeof(struct wprt__JobElementsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__JobElementsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ElementData && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__JobElementDataType *p;
				soap_new_block(soap);
				for (a->__sizeElementData = 0; !soap_element_begin_in(soap, "ElementData", 1, NULL); a->__sizeElementData++)
				{	p = (struct wprt__JobElementDataType *)soap_push_block(soap, sizeof(struct wprt__JobElementDataType));
					soap_default_wprt__JobElementDataType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__JobElementDataType(soap, "ElementData", p, "wprt:JobElementDataType"))
						break;
					soap_flag_ElementData = 0;
				}
				a->ElementData = (struct wprt__JobElementDataType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ElementData && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__JobElementsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__JobElementsType, 0, sizeof(struct wprt__JobElementsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__GetJobElementsResponseType(struct soap *soap, const struct wprt__GetJobElementsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobElementsType(soap, &a->JobElements);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__GetJobElementsResponseType(struct soap *soap, struct wprt__GetJobElementsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobElements = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__GetJobElementsResponseType(struct soap *soap, const struct wprt__GetJobElementsResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__GetJobElementsResponseType);
	if (soap_out_wprt__GetJobElementsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__GetJobElementsResponseType(struct soap *soap, const char *tag, int id, const struct wprt__GetJobElementsResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__GetJobElementsResponseType), type);
	if (a->JobElements)
		soap_element_result(soap, "JobElements");
	soap_out_PointerTowprt__JobElementsType(soap, "wprt:JobElements", -1, &a->JobElements, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__GetJobElementsResponseType * SOAP_FMAC4 soap_get_wprt__GetJobElementsResponseType(struct soap *soap, struct wprt__GetJobElementsResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__GetJobElementsResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetJobElementsResponseType * SOAP_FMAC4 soap_in_wprt__GetJobElementsResponseType(struct soap *soap, const char *tag, struct wprt__GetJobElementsResponseType *a, const char *type)
{
	short soap_flag_JobElements = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__GetJobElementsResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__GetJobElementsResponseType, sizeof(struct wprt__GetJobElementsResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__GetJobElementsResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobElements && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobElementsType(soap, "JobElements", &a->JobElements, "wprt:JobElementsType"))
				{	soap_flag_JobElements--;
					continue;
				}
			soap_check_result(soap, "JobElements");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobElements > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__GetJobElementsResponseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__GetJobElementsResponseType, 0, sizeof(struct wprt__GetJobElementsResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__RequestedJobElementsType(struct soap *soap, const struct wprt__RequestedJobElementsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Name)
	{	int i;
		for (i = 0; i < a->__sizeName; i++)
		{
			soap_embedded(soap, a->Name + i, SOAP_TYPE_wprt__QNameExtType);
			soap_serialize_wprt__QNameExtType(soap, a->Name + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__RequestedJobElementsType(struct soap *soap, struct wprt__RequestedJobElementsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeName = 0;
	a->Name = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__RequestedJobElementsType(struct soap *soap, const struct wprt__RequestedJobElementsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__RequestedJobElementsType);
	if (soap_out_wprt__RequestedJobElementsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__RequestedJobElementsType(struct soap *soap, const char *tag, int id, const struct wprt__RequestedJobElementsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__RequestedJobElementsType), type);
	if (a->Name)
	{	int i;
		for (i = 0; i < a->__sizeName; i++)
			soap_out_wprt__QNameExtType(soap, "wprt:Name", -1, a->Name + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__RequestedJobElementsType * SOAP_FMAC4 soap_get_wprt__RequestedJobElementsType(struct soap *soap, struct wprt__RequestedJobElementsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__RequestedJobElementsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__RequestedJobElementsType * SOAP_FMAC4 soap_in_wprt__RequestedJobElementsType(struct soap *soap, const char *tag, struct wprt__RequestedJobElementsType *a, const char *type)
{
	short soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__RequestedJobElementsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__RequestedJobElementsType, sizeof(struct wprt__RequestedJobElementsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__RequestedJobElementsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__QNameExtType *p;
				soap_new_block(soap);
				for (a->__sizeName = 0; !soap_element_begin_in(soap, "Name", 1, NULL); a->__sizeName++)
				{	p = (struct wprt__QNameExtType *)soap_push_block(soap, sizeof(struct wprt__QNameExtType));
					soap_default_wprt__QNameExtType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__QNameExtType(soap, "Name", p, "wprt:QNameExtType"))
						break;
					soap_flag_Name = 0;
				}
				a->Name = (struct wprt__QNameExtType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__RequestedJobElementsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__RequestedJobElementsType, 0, sizeof(struct wprt__RequestedJobElementsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__GetJobElementsRequestType(struct soap *soap, const struct wprt__GetJobElementsRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobIdType(soap, &a->JobId);
	soap_serialize_PointerTowprt__RequestedJobElementsType(soap, &a->RequestedElements);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__GetJobElementsRequestType(struct soap *soap, struct wprt__GetJobElementsRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobId = NULL;
	a->RequestedElements = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__GetJobElementsRequestType(struct soap *soap, const struct wprt__GetJobElementsRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__GetJobElementsRequestType);
	if (soap_out_wprt__GetJobElementsRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__GetJobElementsRequestType(struct soap *soap, const char *tag, int id, const struct wprt__GetJobElementsRequestType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__GetJobElementsRequestType), type);
	soap_out_PointerTowprt__JobIdType(soap, "wprt:JobId", -1, &a->JobId, "");
	soap_out_PointerTowprt__RequestedJobElementsType(soap, "wprt:RequestedElements", -1, &a->RequestedElements, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__GetJobElementsRequestType * SOAP_FMAC4 soap_get_wprt__GetJobElementsRequestType(struct soap *soap, struct wprt__GetJobElementsRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__GetJobElementsRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetJobElementsRequestType * SOAP_FMAC4 soap_in_wprt__GetJobElementsRequestType(struct soap *soap, const char *tag, struct wprt__GetJobElementsRequestType *a, const char *type)
{
	short soap_flag_JobId = 1, soap_flag_RequestedElements = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__GetJobElementsRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__GetJobElementsRequestType, sizeof(struct wprt__GetJobElementsRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__GetJobElementsRequestType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobIdType(soap, "JobId", &a->JobId, "wprt:JobIdType"))
				{	soap_flag_JobId--;
					continue;
				}
			if (soap_flag_RequestedElements && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__RequestedJobElementsType(soap, "RequestedElements", &a->RequestedElements, "wprt:RequestedJobElementsType"))
				{	soap_flag_RequestedElements--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobId > 0 || soap_flag_RequestedElements > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__GetJobElementsRequestType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__GetJobElementsRequestType, 0, sizeof(struct wprt__GetJobElementsRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterElementsType(struct soap *soap, const struct wprt__PrinterElementsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ElementData)
	{	int i;
		for (i = 0; i < a->__sizeElementData; i++)
		{
			soap_embedded(soap, a->ElementData + i, SOAP_TYPE_wprt__PrinterElementDataType);
			soap_serialize_wprt__PrinterElementDataType(soap, a->ElementData + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterElementsType(struct soap *soap, struct wprt__PrinterElementsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeElementData = 0;
	a->ElementData = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterElementsType(struct soap *soap, const struct wprt__PrinterElementsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterElementsType);
	if (soap_out_wprt__PrinterElementsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterElementsType(struct soap *soap, const char *tag, int id, const struct wprt__PrinterElementsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrinterElementsType), type);
	if (a->ElementData)
	{	int i;
		for (i = 0; i < a->__sizeElementData; i++)
			soap_out_wprt__PrinterElementDataType(soap, "wprt:ElementData", -1, a->ElementData + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrinterElementsType * SOAP_FMAC4 soap_get_wprt__PrinterElementsType(struct soap *soap, struct wprt__PrinterElementsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterElementsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterElementsType * SOAP_FMAC4 soap_in_wprt__PrinterElementsType(struct soap *soap, const char *tag, struct wprt__PrinterElementsType *a, const char *type)
{
	short soap_flag_ElementData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrinterElementsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrinterElementsType, sizeof(struct wprt__PrinterElementsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrinterElementsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ElementData && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__PrinterElementDataType *p;
				soap_new_block(soap);
				for (a->__sizeElementData = 0; !soap_element_begin_in(soap, "ElementData", 1, NULL); a->__sizeElementData++)
				{	p = (struct wprt__PrinterElementDataType *)soap_push_block(soap, sizeof(struct wprt__PrinterElementDataType));
					soap_default_wprt__PrinterElementDataType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__PrinterElementDataType(soap, "ElementData", p, "wprt:PrinterElementDataType"))
						break;
					soap_flag_ElementData = 0;
				}
				a->ElementData = (struct wprt__PrinterElementDataType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ElementData && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterElementsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrinterElementsType, 0, sizeof(struct wprt__PrinterElementsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__GetPrinterElementsResponseType(struct soap *soap, const struct wprt__GetPrinterElementsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrinterElementsType(soap, &a->PrinterElements);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__GetPrinterElementsResponseType(struct soap *soap, struct wprt__GetPrinterElementsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PrinterElements = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__GetPrinterElementsResponseType(struct soap *soap, const struct wprt__GetPrinterElementsResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__GetPrinterElementsResponseType);
	if (soap_out_wprt__GetPrinterElementsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__GetPrinterElementsResponseType(struct soap *soap, const char *tag, int id, const struct wprt__GetPrinterElementsResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__GetPrinterElementsResponseType), type);
	if (a->PrinterElements)
		soap_element_result(soap, "PrinterElements");
	soap_out_PointerTowprt__PrinterElementsType(soap, "wprt:PrinterElements", -1, &a->PrinterElements, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__GetPrinterElementsResponseType * SOAP_FMAC4 soap_get_wprt__GetPrinterElementsResponseType(struct soap *soap, struct wprt__GetPrinterElementsResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__GetPrinterElementsResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetPrinterElementsResponseType * SOAP_FMAC4 soap_in_wprt__GetPrinterElementsResponseType(struct soap *soap, const char *tag, struct wprt__GetPrinterElementsResponseType *a, const char *type)
{
	short soap_flag_PrinterElements = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__GetPrinterElementsResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__GetPrinterElementsResponseType, sizeof(struct wprt__GetPrinterElementsResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__GetPrinterElementsResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrinterElements && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrinterElementsType(soap, "PrinterElements", &a->PrinterElements, "wprt:PrinterElementsType"))
				{	soap_flag_PrinterElements--;
					continue;
				}
			soap_check_result(soap, "PrinterElements");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PrinterElements > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__GetPrinterElementsResponseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__GetPrinterElementsResponseType, 0, sizeof(struct wprt__GetPrinterElementsResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__RequestedPrinterElementsType(struct soap *soap, const struct wprt__RequestedPrinterElementsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Name)
	{	int i;
		for (i = 0; i < a->__sizeName; i++)
		{
			soap_embedded(soap, a->Name + i, SOAP_TYPE_wprt__QNameExtType);
			soap_serialize_wprt__QNameExtType(soap, a->Name + i);
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__RequestedPrinterElementsType(struct soap *soap, struct wprt__RequestedPrinterElementsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeName = 0;
	a->Name = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__RequestedPrinterElementsType(struct soap *soap, const struct wprt__RequestedPrinterElementsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__RequestedPrinterElementsType);
	if (soap_out_wprt__RequestedPrinterElementsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__RequestedPrinterElementsType(struct soap *soap, const char *tag, int id, const struct wprt__RequestedPrinterElementsType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__RequestedPrinterElementsType), type);
	if (a->Name)
	{	int i;
		for (i = 0; i < a->__sizeName; i++)
			soap_out_wprt__QNameExtType(soap, "wprt:Name", -1, a->Name + i, "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__RequestedPrinterElementsType * SOAP_FMAC4 soap_get_wprt__RequestedPrinterElementsType(struct soap *soap, struct wprt__RequestedPrinterElementsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__RequestedPrinterElementsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__RequestedPrinterElementsType * SOAP_FMAC4 soap_in_wprt__RequestedPrinterElementsType(struct soap *soap, const char *tag, struct wprt__RequestedPrinterElementsType *a, const char *type)
{
	short soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__RequestedPrinterElementsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__RequestedPrinterElementsType, sizeof(struct wprt__RequestedPrinterElementsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__RequestedPrinterElementsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
			{	struct wprt__QNameExtType *p;
				soap_new_block(soap);
				for (a->__sizeName = 0; !soap_element_begin_in(soap, "Name", 1, NULL); a->__sizeName++)
				{	p = (struct wprt__QNameExtType *)soap_push_block(soap, sizeof(struct wprt__QNameExtType));
					soap_default_wprt__QNameExtType(soap, p);
					soap_revert(soap);
					if (!soap_in_wprt__QNameExtType(soap, "Name", p, "wprt:QNameExtType"))
						break;
					soap_flag_Name = 0;
				}
				a->Name = (struct wprt__QNameExtType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__RequestedPrinterElementsType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__RequestedPrinterElementsType, 0, sizeof(struct wprt__RequestedPrinterElementsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__GetPrinterElementsRequestType(struct soap *soap, const struct wprt__GetPrinterElementsRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__RequestedPrinterElementsType(soap, &a->RequestedElements);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__GetPrinterElementsRequestType(struct soap *soap, struct wprt__GetPrinterElementsRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RequestedElements = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__GetPrinterElementsRequestType(struct soap *soap, const struct wprt__GetPrinterElementsRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__GetPrinterElementsRequestType);
	if (soap_out_wprt__GetPrinterElementsRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__GetPrinterElementsRequestType(struct soap *soap, const char *tag, int id, const struct wprt__GetPrinterElementsRequestType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__GetPrinterElementsRequestType), type);
	soap_out_PointerTowprt__RequestedPrinterElementsType(soap, "wprt:RequestedElements", -1, &a->RequestedElements, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__GetPrinterElementsRequestType * SOAP_FMAC4 soap_get_wprt__GetPrinterElementsRequestType(struct soap *soap, struct wprt__GetPrinterElementsRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__GetPrinterElementsRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetPrinterElementsRequestType * SOAP_FMAC4 soap_in_wprt__GetPrinterElementsRequestType(struct soap *soap, const char *tag, struct wprt__GetPrinterElementsRequestType *a, const char *type)
{
	short soap_flag_RequestedElements = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__GetPrinterElementsRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__GetPrinterElementsRequestType, sizeof(struct wprt__GetPrinterElementsRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__GetPrinterElementsRequestType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequestedElements && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__RequestedPrinterElementsType(soap, "RequestedElements", &a->RequestedElements, "wprt:RequestedPrinterElementsType"))
				{	soap_flag_RequestedElements--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RequestedElements > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__GetPrinterElementsRequestType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__GetPrinterElementsRequestType, 0, sizeof(struct wprt__GetPrinterElementsRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__CancelJobResponseType(struct soap *soap, const struct wprt__CancelJobResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__CancelJobResponseType(struct soap *soap, struct wprt__CancelJobResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__CancelJobResponseType(struct soap *soap, const struct wprt__CancelJobResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__CancelJobResponseType);
	if (soap_out_wprt__CancelJobResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__CancelJobResponseType(struct soap *soap, const char *tag, int id, const struct wprt__CancelJobResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__CancelJobResponseType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__CancelJobResponseType * SOAP_FMAC4 soap_get_wprt__CancelJobResponseType(struct soap *soap, struct wprt__CancelJobResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__CancelJobResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CancelJobResponseType * SOAP_FMAC4 soap_in_wprt__CancelJobResponseType(struct soap *soap, const char *tag, struct wprt__CancelJobResponseType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__CancelJobResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__CancelJobResponseType, sizeof(struct wprt__CancelJobResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__CancelJobResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__CancelJobResponseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__CancelJobResponseType, 0, sizeof(struct wprt__CancelJobResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__CancelJobRequestType(struct soap *soap, const struct wprt__CancelJobRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobIdType(soap, &a->JobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__CancelJobRequestType(struct soap *soap, struct wprt__CancelJobRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobId = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__CancelJobRequestType(struct soap *soap, const struct wprt__CancelJobRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__CancelJobRequestType);
	if (soap_out_wprt__CancelJobRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__CancelJobRequestType(struct soap *soap, const char *tag, int id, const struct wprt__CancelJobRequestType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__CancelJobRequestType), type);
	soap_out_PointerTowprt__JobIdType(soap, "wprt:JobId", -1, &a->JobId, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__CancelJobRequestType * SOAP_FMAC4 soap_get_wprt__CancelJobRequestType(struct soap *soap, struct wprt__CancelJobRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__CancelJobRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CancelJobRequestType * SOAP_FMAC4 soap_in_wprt__CancelJobRequestType(struct soap *soap, const char *tag, struct wprt__CancelJobRequestType *a, const char *type)
{
	short soap_flag_JobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__CancelJobRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__CancelJobRequestType, sizeof(struct wprt__CancelJobRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__CancelJobRequestType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobIdType(soap, "JobId", &a->JobId, "wprt:JobIdType"))
				{	soap_flag_JobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobId > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__CancelJobRequestType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__CancelJobRequestType, 0, sizeof(struct wprt__CancelJobRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__AddDocumentResponseType(struct soap *soap, const struct wprt__AddDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__AddDocumentResponseType(struct soap *soap, struct wprt__AddDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__AddDocumentResponseType(struct soap *soap, const struct wprt__AddDocumentResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__AddDocumentResponseType);
	if (soap_out_wprt__AddDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__AddDocumentResponseType(struct soap *soap, const char *tag, int id, const struct wprt__AddDocumentResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__AddDocumentResponseType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__AddDocumentResponseType * SOAP_FMAC4 soap_get_wprt__AddDocumentResponseType(struct soap *soap, struct wprt__AddDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__AddDocumentResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__AddDocumentResponseType * SOAP_FMAC4 soap_in_wprt__AddDocumentResponseType(struct soap *soap, const char *tag, struct wprt__AddDocumentResponseType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__AddDocumentResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__AddDocumentResponseType, sizeof(struct wprt__AddDocumentResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__AddDocumentResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__AddDocumentResponseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__AddDocumentResponseType, 0, sizeof(struct wprt__AddDocumentResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__AnyURIExtType(struct soap *soap, const struct wprt__AnyURIExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__AnyURIExtType(struct soap *soap, struct wprt__AnyURIExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__AnyURIExtType(struct soap *soap, const struct wprt__AnyURIExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__AnyURIExtType);
	if (soap_out_wprt__AnyURIExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__AnyURIExtType(struct soap *soap, const char *tag, int id, const struct wprt__AnyURIExtType *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__AnyURIExtType * SOAP_FMAC4 soap_get_wprt__AnyURIExtType(struct soap *soap, struct wprt__AnyURIExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__AnyURIExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__AnyURIExtType * SOAP_FMAC4 soap_in_wprt__AnyURIExtType(struct soap *soap, const char *tag, struct wprt__AnyURIExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__AnyURIExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__AnyURIExtType, sizeof(struct wprt__AnyURIExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__AnyURIExtType(soap, a);
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, "wprt:AnyURIExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__AddDocumentRequestType(struct soap *soap, const struct wprt__AddDocumentRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobIdType(soap, &a->JobId);
	soap_serialize_PointerTowprt__DocumentDescriptionType(soap, &a->DocumentDescription);
	soap_serialize_PointerTowprt__DocumentProcessingType(soap, &a->DocumentProcessing);
	soap_serialize_PointerTowprt__BoolExtType(soap, &a->LastDocument);
	soap_serialize_PointerTowprt__AnyURIExtType(soap, &a->DocumentUrl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__AddDocumentRequestType(struct soap *soap, struct wprt__AddDocumentRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobId = NULL;
	a->DocumentDescription = NULL;
	a->DocumentProcessing = NULL;
	a->LastDocument = NULL;
	a->DocumentUrl = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__AddDocumentRequestType(struct soap *soap, const struct wprt__AddDocumentRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__AddDocumentRequestType);
	if (soap_out_wprt__AddDocumentRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__AddDocumentRequestType(struct soap *soap, const char *tag, int id, const struct wprt__AddDocumentRequestType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__AddDocumentRequestType), type);
	soap_out_PointerTowprt__JobIdType(soap, "wprt:JobId", -1, &a->JobId, "");
	soap_out_PointerTowprt__DocumentDescriptionType(soap, "wprt:DocumentDescription", -1, &a->DocumentDescription, "");
	soap_out_PointerTowprt__DocumentProcessingType(soap, "wprt:DocumentProcessing", -1, &a->DocumentProcessing, "");
	soap_out_PointerTowprt__BoolExtType(soap, "wprt:LastDocument", -1, &a->LastDocument, "");
	soap_out_PointerTowprt__AnyURIExtType(soap, "wprt:DocumentUrl", -1, &a->DocumentUrl, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__AddDocumentRequestType * SOAP_FMAC4 soap_get_wprt__AddDocumentRequestType(struct soap *soap, struct wprt__AddDocumentRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__AddDocumentRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__AddDocumentRequestType * SOAP_FMAC4 soap_in_wprt__AddDocumentRequestType(struct soap *soap, const char *tag, struct wprt__AddDocumentRequestType *a, const char *type)
{
	short soap_flag_JobId = 1, soap_flag_DocumentDescription = 1, soap_flag_DocumentProcessing = 1, soap_flag_LastDocument = 1, soap_flag_DocumentUrl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__AddDocumentRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__AddDocumentRequestType, sizeof(struct wprt__AddDocumentRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__AddDocumentRequestType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobIdType(soap, "JobId", &a->JobId, "wprt:JobIdType"))
				{	soap_flag_JobId--;
					continue;
				}
			if (soap_flag_DocumentDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentDescriptionType(soap, "DocumentDescription", &a->DocumentDescription, "wprt:DocumentDescriptionType"))
				{	soap_flag_DocumentDescription--;
					continue;
				}
			if (soap_flag_DocumentProcessing && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentProcessingType(soap, "DocumentProcessing", &a->DocumentProcessing, "wprt:DocumentProcessingType"))
				{	soap_flag_DocumentProcessing--;
					continue;
				}
			if (soap_flag_LastDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BoolExtType(soap, "LastDocument", &a->LastDocument, "wprt:BoolExtType"))
				{	soap_flag_LastDocument--;
					continue;
				}
			if (soap_flag_DocumentUrl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__AnyURIExtType(soap, "DocumentUrl", &a->DocumentUrl, "wprt:AnyURIExtType"))
				{	soap_flag_DocumentUrl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobId > 0 || soap_flag_DocumentDescription > 0 || soap_flag_LastDocument > 0 || soap_flag_DocumentUrl > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__AddDocumentRequestType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__AddDocumentRequestType, 0, sizeof(struct wprt__AddDocumentRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__SendDocumentResponseType(struct soap *soap, const struct wprt__SendDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__SendDocumentResponseType(struct soap *soap, struct wprt__SendDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__SendDocumentResponseType(struct soap *soap, const struct wprt__SendDocumentResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__SendDocumentResponseType);
	if (soap_out_wprt__SendDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__SendDocumentResponseType(struct soap *soap, const char *tag, int id, const struct wprt__SendDocumentResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__SendDocumentResponseType), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__SendDocumentResponseType * SOAP_FMAC4 soap_get_wprt__SendDocumentResponseType(struct soap *soap, struct wprt__SendDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__SendDocumentResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SendDocumentResponseType * SOAP_FMAC4 soap_in_wprt__SendDocumentResponseType(struct soap *soap, const char *tag, struct wprt__SendDocumentResponseType *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__SendDocumentResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__SendDocumentResponseType, sizeof(struct wprt__SendDocumentResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__SendDocumentResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__SendDocumentResponseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__SendDocumentResponseType, 0, sizeof(struct wprt__SendDocumentResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__BoolExtType(struct soap *soap, const struct wprt__BoolExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->__item, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__BoolExtType(struct soap *soap, struct wprt__BoolExtType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__BoolExtType(struct soap *soap, const struct wprt__BoolExtType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__BoolExtType);
	if (soap_out_wprt__BoolExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__BoolExtType(struct soap *soap, const char *tag, int id, const struct wprt__BoolExtType *a, const char *type)
{
	return soap_out_xsd__boolean(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__BoolExtType * SOAP_FMAC4 soap_get_wprt__BoolExtType(struct soap *soap, struct wprt__BoolExtType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__BoolExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__BoolExtType * SOAP_FMAC4 soap_in_wprt__BoolExtType(struct soap *soap, const char *tag, struct wprt__BoolExtType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__BoolExtType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__BoolExtType, sizeof(struct wprt__BoolExtType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__BoolExtType(soap, a);
	if (!soap_in_xsd__boolean(soap, tag, &a->__item, "wprt:BoolExtType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DocumentProcessingType(struct soap *soap, const struct wprt__DocumentProcessingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__MediaSizeNameType(soap, &a->MediaSizeName);
	soap_serialize_PointerTowprt__MediaTypeBaseType(soap, &a->MediaType);
	soap_serialize_PointerTowprt__MediaColorType(soap, &a->MediaColor);
	soap_serialize_PointerTowprt__NumberUpType(soap, &a->NumberUp);
	soap_serialize_PointerTowprt__OrientationType(soap, &a->Orientation);
	soap_serialize_PointerTowprt__ResolutionType(soap, &a->Resolution);
	soap_serialize_PointerTowprt__PrintQualityType(soap, &a->PrintQuality);
	soap_serialize_PointerTowprt__SidesType(soap, &a->Sides);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DocumentProcessingType(struct soap *soap, struct wprt__DocumentProcessingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaSizeName = NULL;
	a->MediaType = NULL;
	a->MediaColor = NULL;
	a->NumberUp = NULL;
	a->Orientation = NULL;
	a->Resolution = NULL;
	a->PrintQuality = NULL;
	a->Sides = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DocumentProcessingType(struct soap *soap, const struct wprt__DocumentProcessingType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DocumentProcessingType);
	if (soap_out_wprt__DocumentProcessingType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DocumentProcessingType(struct soap *soap, const char *tag, int id, const struct wprt__DocumentProcessingType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__DocumentProcessingType), type);
	soap_out_PointerTowprt__MediaSizeNameType(soap, "wprt:MediaSizeName", -1, &a->MediaSizeName, "");
	soap_out_PointerTowprt__MediaTypeBaseType(soap, "wprt:MediaType", -1, &a->MediaType, "");
	soap_out_PointerTowprt__MediaColorType(soap, "wprt:MediaColor", -1, &a->MediaColor, "");
	soap_out_PointerTowprt__NumberUpType(soap, "wprt:NumberUp", -1, &a->NumberUp, "");
	soap_out_PointerTowprt__OrientationType(soap, "wprt:Orientation", -1, &a->Orientation, "");
	soap_out_PointerTowprt__ResolutionType(soap, "wprt:Resolution", -1, &a->Resolution, "");
	soap_out_PointerTowprt__PrintQualityType(soap, "wprt:PrintQuality", -1, &a->PrintQuality, "");
	soap_out_PointerTowprt__SidesType(soap, "wprt:Sides", -1, &a->Sides, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__DocumentProcessingType * SOAP_FMAC4 soap_get_wprt__DocumentProcessingType(struct soap *soap, struct wprt__DocumentProcessingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DocumentProcessingType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentProcessingType * SOAP_FMAC4 soap_in_wprt__DocumentProcessingType(struct soap *soap, const char *tag, struct wprt__DocumentProcessingType *a, const char *type)
{
	short soap_flag_MediaSizeName = 1, soap_flag_MediaType = 1, soap_flag_MediaColor = 1, soap_flag_NumberUp = 1, soap_flag_Orientation = 1, soap_flag_Resolution = 1, soap_flag_PrintQuality = 1, soap_flag_Sides = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__DocumentProcessingType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DocumentProcessingType, sizeof(struct wprt__DocumentProcessingType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__DocumentProcessingType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaSizeName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__MediaSizeNameType(soap, "MediaSizeName", &a->MediaSizeName, "wprt:MediaSizeNameType"))
				{	soap_flag_MediaSizeName--;
					continue;
				}
			if (soap_flag_MediaType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__MediaTypeBaseType(soap, "MediaType", &a->MediaType, "wprt:MediaTypeBaseType"))
				{	soap_flag_MediaType--;
					continue;
				}
			if (soap_flag_MediaColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__MediaColorType(soap, "MediaColor", &a->MediaColor, "wprt:MediaColorType"))
				{	soap_flag_MediaColor--;
					continue;
				}
			if (soap_flag_NumberUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__NumberUpType(soap, "NumberUp", &a->NumberUp, "wprt:NumberUpType"))
				{	soap_flag_NumberUp--;
					continue;
				}
			if (soap_flag_Orientation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__OrientationType(soap, "Orientation", &a->Orientation, "wprt:OrientationType"))
				{	soap_flag_Orientation--;
					continue;
				}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__ResolutionType(soap, "Resolution", &a->Resolution, "wprt:ResolutionType"))
				{	soap_flag_Resolution--;
					continue;
				}
			if (soap_flag_PrintQuality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrintQualityType(soap, "PrintQuality", &a->PrintQuality, "wprt:PrintQualityType"))
				{	soap_flag_PrintQuality--;
					continue;
				}
			if (soap_flag_Sides && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__SidesType(soap, "Sides", &a->Sides, "wprt:SidesType"))
				{	soap_flag_Sides--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentProcessingType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__DocumentProcessingType, 0, sizeof(struct wprt__DocumentProcessingType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DocumentDescriptionType(struct soap *soap, const struct wprt__DocumentDescriptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__CompressionType(soap, &a->Compression);
	soap_serialize_PointerTowprt__DocumentFormatType(soap, &a->Format);
	soap_serialize_PointerTowprt__String255ExtType(soap, &a->DocumentName);
	soap_serialize_PointerTowprt__AnyURIExtType(soap, &a->DocumentUrl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DocumentDescriptionType(struct soap *soap, struct wprt__DocumentDescriptionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__DocumentIdType(soap, &a->DocumentId);
	a->Compression = NULL;
	a->Format = NULL;
	a->DocumentName = NULL;
	a->DocumentUrl = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DocumentDescriptionType(struct soap *soap, const struct wprt__DocumentDescriptionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DocumentDescriptionType);
	if (soap_out_wprt__DocumentDescriptionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DocumentDescriptionType(struct soap *soap, const char *tag, int id, const struct wprt__DocumentDescriptionType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__DocumentDescriptionType), type);
	soap_out_wprt__DocumentIdType(soap, "wprt:DocumentId", -1, &a->DocumentId, "");
	soap_out_PointerTowprt__CompressionType(soap, "wprt:Compression", -1, &a->Compression, "");
	soap_out_PointerTowprt__DocumentFormatType(soap, "wprt:Format", -1, &a->Format, "");
	soap_out_PointerTowprt__String255ExtType(soap, "wprt:DocumentName", -1, &a->DocumentName, "");
	soap_out_PointerTowprt__AnyURIExtType(soap, "wprt:DocumentUrl", -1, &a->DocumentUrl, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__DocumentDescriptionType * SOAP_FMAC4 soap_get_wprt__DocumentDescriptionType(struct soap *soap, struct wprt__DocumentDescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DocumentDescriptionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentDescriptionType * SOAP_FMAC4 soap_in_wprt__DocumentDescriptionType(struct soap *soap, const char *tag, struct wprt__DocumentDescriptionType *a, const char *type)
{
	short soap_flag_DocumentId = 1, soap_flag_Compression = 1, soap_flag_Format = 1, soap_flag_DocumentName = 1, soap_flag_DocumentUrl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__DocumentDescriptionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__DocumentDescriptionType, sizeof(struct wprt__DocumentDescriptionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__DocumentDescriptionType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocumentId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wprt__DocumentIdType(soap, "DocumentId", &a->DocumentId, "wprt:DocumentIdType"))
				{	soap_flag_DocumentId--;
					continue;
				}
			if (soap_flag_Compression && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__CompressionType(soap, "Compression", &a->Compression, "wprt:CompressionType"))
				{	soap_flag_Compression--;
					continue;
				}
			if (soap_flag_Format && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentFormatType(soap, "Format", &a->Format, "wprt:DocumentFormatType"))
				{	soap_flag_Format--;
					continue;
				}
			if (soap_flag_DocumentName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__String255ExtType(soap, "DocumentName", &a->DocumentName, "wprt:String255ExtType"))
				{	soap_flag_DocumentName--;
					continue;
				}
			if (soap_flag_DocumentUrl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__AnyURIExtType(soap, "DocumentUrl", &a->DocumentUrl, "wprt:AnyURIExtType"))
				{	soap_flag_DocumentUrl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DocumentId > 0 || soap_flag_Compression > 0 || soap_flag_Format > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentDescriptionType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__DocumentDescriptionType, 0, sizeof(struct wprt__DocumentDescriptionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__SendDocumentRequestType(struct soap *soap, const struct wprt__SendDocumentRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobIdType(soap, &a->JobId);
	soap_serialize_PointerTowprt__DocumentDescriptionType(soap, &a->DocumentDescription);
	soap_serialize_PointerTowprt__DocumentProcessingType(soap, &a->DocumentProcessing);
	soap_serialize_PointerTowprt__BoolExtType(soap, &a->LastDocument);
	soap_serialize__xop__Include(soap, &a->DocumentData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__SendDocumentRequestType(struct soap *soap, struct wprt__SendDocumentRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobId = NULL;
	a->DocumentDescription = NULL;
	a->DocumentProcessing = NULL;
	a->LastDocument = NULL;
	soap_default__xop__Include(soap, &a->DocumentData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__SendDocumentRequestType(struct soap *soap, const struct wprt__SendDocumentRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__SendDocumentRequestType);
	if (soap_out_wprt__SendDocumentRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__SendDocumentRequestType(struct soap *soap, const char *tag, int id, const struct wprt__SendDocumentRequestType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__SendDocumentRequestType), type);
	soap_out_PointerTowprt__JobIdType(soap, "wprt:JobId", -1, &a->JobId, "");
	soap_out_PointerTowprt__DocumentDescriptionType(soap, "wprt:DocumentDescription", -1, &a->DocumentDescription, "");
	soap_out_PointerTowprt__DocumentProcessingType(soap, "wprt:DocumentProcessing", -1, &a->DocumentProcessing, "");
	soap_out_PointerTowprt__BoolExtType(soap, "wprt:LastDocument", -1, &a->LastDocument, "");
	soap_out__xop__Include(soap, "wprt:DocumentData", -1, &a->DocumentData, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__SendDocumentRequestType * SOAP_FMAC4 soap_get_wprt__SendDocumentRequestType(struct soap *soap, struct wprt__SendDocumentRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__SendDocumentRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SendDocumentRequestType * SOAP_FMAC4 soap_in_wprt__SendDocumentRequestType(struct soap *soap, const char *tag, struct wprt__SendDocumentRequestType *a, const char *type)
{
	short soap_flag_JobId = 1, soap_flag_DocumentDescription = 1, soap_flag_DocumentProcessing = 1, soap_flag_LastDocument = 1, soap_flag_DocumentData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__SendDocumentRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__SendDocumentRequestType, sizeof(struct wprt__SendDocumentRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__SendDocumentRequestType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobIdType(soap, "JobId", &a->JobId, "wprt:JobIdType"))
				{	soap_flag_JobId--;
					continue;
				}
			if (soap_flag_DocumentDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentDescriptionType(soap, "DocumentDescription", &a->DocumentDescription, "wprt:DocumentDescriptionType"))
				{	soap_flag_DocumentDescription--;
					continue;
				}
			if (soap_flag_DocumentProcessing && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentProcessingType(soap, "DocumentProcessing", &a->DocumentProcessing, "wprt:DocumentProcessingType"))
				{	soap_flag_DocumentProcessing--;
					continue;
				}
			if (soap_flag_LastDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__BoolExtType(soap, "LastDocument", &a->LastDocument, "wprt:BoolExtType"))
				{	soap_flag_LastDocument--;
					continue;
				}
			if (soap_flag_DocumentData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__xop__Include(soap, "DocumentData", &a->DocumentData, ""))
				{	soap_flag_DocumentData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobId > 0 || soap_flag_DocumentDescription > 0 || soap_flag_LastDocument > 0 || soap_flag_DocumentData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__SendDocumentRequestType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__SendDocumentRequestType, 0, sizeof(struct wprt__SendDocumentRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobIdType(struct soap *soap, const struct wprt__JobIdType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobIdType(struct soap *soap, struct wprt__JobIdType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wprt__JobIdRestrictionType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobIdType(struct soap *soap, const struct wprt__JobIdType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobIdType);
	if (soap_out_wprt__JobIdType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobIdType(struct soap *soap, const char *tag, int id, const struct wprt__JobIdType *a, const char *type)
{
	return soap_out_wprt__JobIdRestrictionType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wprt__JobIdType * SOAP_FMAC4 soap_get_wprt__JobIdType(struct soap *soap, struct wprt__JobIdType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobIdType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobIdType * SOAP_FMAC4 soap_in_wprt__JobIdType(struct soap *soap, const char *tag, struct wprt__JobIdType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wprt__JobIdType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__JobIdType, sizeof(struct wprt__JobIdType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wprt__JobIdType(soap, a);
	if (!soap_in_wprt__JobIdRestrictionType(soap, tag, &a->__item, "wprt:JobIdType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__CreatePrintJobResponseType(struct soap *soap, const struct wprt__CreatePrintJobResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobIdType(soap, &a->JobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__CreatePrintJobResponseType(struct soap *soap, struct wprt__CreatePrintJobResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobId = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__CreatePrintJobResponseType(struct soap *soap, const struct wprt__CreatePrintJobResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__CreatePrintJobResponseType);
	if (soap_out_wprt__CreatePrintJobResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__CreatePrintJobResponseType(struct soap *soap, const char *tag, int id, const struct wprt__CreatePrintJobResponseType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__CreatePrintJobResponseType), type);
	if (a->JobId)
		soap_element_result(soap, "JobId");
	soap_out_PointerTowprt__JobIdType(soap, "wprt:JobId", -1, &a->JobId, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__CreatePrintJobResponseType * SOAP_FMAC4 soap_get_wprt__CreatePrintJobResponseType(struct soap *soap, struct wprt__CreatePrintJobResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__CreatePrintJobResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CreatePrintJobResponseType * SOAP_FMAC4 soap_in_wprt__CreatePrintJobResponseType(struct soap *soap, const char *tag, struct wprt__CreatePrintJobResponseType *a, const char *type)
{
	short soap_flag_JobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__CreatePrintJobResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__CreatePrintJobResponseType, sizeof(struct wprt__CreatePrintJobResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__CreatePrintJobResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobIdType(soap, "JobId", &a->JobId, "wprt:JobIdType"))
				{	soap_flag_JobId--;
					continue;
				}
			soap_check_result(soap, "JobId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobId > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__CreatePrintJobResponseType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__CreatePrintJobResponseType, 0, sizeof(struct wprt__CreatePrintJobResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrintTicketType(struct soap *soap, const struct wprt__PrintTicketType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__JobDescriptionType(soap, &a->JobDescription);
	soap_serialize_PointerTowprt__JobProcessingType(soap, &a->JobProcessing);
	soap_serialize_PointerTowprt__DocumentProcessingType(soap, &a->DocumentProcessing);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrintTicketType(struct soap *soap, struct wprt__PrintTicketType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobDescription = NULL;
	a->JobProcessing = NULL;
	a->DocumentProcessing = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrintTicketType(struct soap *soap, const struct wprt__PrintTicketType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrintTicketType);
	if (soap_out_wprt__PrintTicketType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrintTicketType(struct soap *soap, const char *tag, int id, const struct wprt__PrintTicketType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__PrintTicketType), type);
	soap_out_PointerTowprt__JobDescriptionType(soap, "wprt:JobDescription", -1, &a->JobDescription, "");
	soap_out_PointerTowprt__JobProcessingType(soap, "wprt:JobProcessing", -1, &a->JobProcessing, "");
	soap_out_PointerTowprt__DocumentProcessingType(soap, "wprt:DocumentProcessing", -1, &a->DocumentProcessing, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__PrintTicketType * SOAP_FMAC4 soap_get_wprt__PrintTicketType(struct soap *soap, struct wprt__PrintTicketType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrintTicketType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrintTicketType * SOAP_FMAC4 soap_in_wprt__PrintTicketType(struct soap *soap, const char *tag, struct wprt__PrintTicketType *a, const char *type)
{
	short soap_flag_JobDescription = 1, soap_flag_JobProcessing = 1, soap_flag_DocumentProcessing = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__PrintTicketType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__PrintTicketType, sizeof(struct wprt__PrintTicketType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__PrintTicketType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobDescriptionType(soap, "JobDescription", &a->JobDescription, "wprt:JobDescriptionType"))
				{	soap_flag_JobDescription--;
					continue;
				}
			if (soap_flag_JobProcessing && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__JobProcessingType(soap, "JobProcessing", &a->JobProcessing, "wprt:JobProcessingType"))
				{	soap_flag_JobProcessing--;
					continue;
				}
			if (soap_flag_DocumentProcessing && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__DocumentProcessingType(soap, "DocumentProcessing", &a->DocumentProcessing, "wprt:DocumentProcessingType"))
				{	soap_flag_DocumentProcessing--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__PrintTicketType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__PrintTicketType, 0, sizeof(struct wprt__PrintTicketType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__CreatePrintJobRequestType(struct soap *soap, const struct wprt__CreatePrintJobRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowprt__PrintTicketType(soap, &a->PrintTicket);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__CreatePrintJobRequestType(struct soap *soap, struct wprt__CreatePrintJobRequestType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PrintTicket = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__CreatePrintJobRequestType(struct soap *soap, const struct wprt__CreatePrintJobRequestType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__CreatePrintJobRequestType);
	if (soap_out_wprt__CreatePrintJobRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__CreatePrintJobRequestType(struct soap *soap, const char *tag, int id, const struct wprt__CreatePrintJobRequestType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wprt__CreatePrintJobRequestType), type);
	soap_out_PointerTowprt__PrintTicketType(soap, "wprt:PrintTicket", -1, &a->PrintTicket, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wprt__CreatePrintJobRequestType * SOAP_FMAC4 soap_get_wprt__CreatePrintJobRequestType(struct soap *soap, struct wprt__CreatePrintJobRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__CreatePrintJobRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CreatePrintJobRequestType * SOAP_FMAC4 soap_in_wprt__CreatePrintJobRequestType(struct soap *soap, const char *tag, struct wprt__CreatePrintJobRequestType *a, const char *type)
{
	short soap_flag_PrintTicket = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wprt__CreatePrintJobRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wprt__CreatePrintJobRequestType, sizeof(struct wprt__CreatePrintJobRequestType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wprt__CreatePrintJobRequestType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrintTicket && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowprt__PrintTicketType(soap, "PrintTicket", &a->PrintTicket, "wprt:PrintTicketType"))
				{	soap_flag_PrintTicket--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PrintTicket > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wprt__CreatePrintJobRequestType *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_wprt__CreatePrintJobRequestType, 0, sizeof(struct wprt__CreatePrintJobRequestType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, struct _xop__Include const*a)
{
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE__xop__Include))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE__xop__Include);
	if (soap_out__xop__Include(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE__xop__Include);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__xop__Include, 0, sizeof(struct _xop__Include), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__union_PrinterElementDataType(struct soap *soap, int choice, const union _wprt__union_PrinterElementDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__wprt__union_PrinterElementDataType_PrinterDescription:
		soap_serialize_PointerTowprt__PrinterDescriptionType(soap, &a->PrinterDescription);
		break;
	case SOAP_UNION__wprt__union_PrinterElementDataType_PrinterConfiguration:
		soap_serialize_PointerTowprt__PrinterConfigurationType(soap, &a->PrinterConfiguration);
		break;
	case SOAP_UNION__wprt__union_PrinterElementDataType_PrinterStatus:
		soap_serialize_PointerTowprt__PrinterStatusType(soap, &a->PrinterStatus);
		break;
	case SOAP_UNION__wprt__union_PrinterElementDataType_DefaultPrintTicket:
		soap_serialize_PointerTowprt__PrintTicketType(soap, &a->DefaultPrintTicket);
		break;
	case SOAP_UNION__wprt__union_PrinterElementDataType_PrinterCapabilities:
		soap_serialize_PointerTowprt__PrinterCapabilitiesType(soap, &a->PrinterCapabilities);
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__union_PrinterElementDataType(struct soap *soap, int choice, const union _wprt__union_PrinterElementDataType *a)
{
	switch (choice)
	{
	case SOAP_UNION__wprt__union_PrinterElementDataType_PrinterDescription:
		return soap_out_PointerTowprt__PrinterDescriptionType(soap, "wprt:PrinterDescription", -1, &a->PrinterDescription, "");
	case SOAP_UNION__wprt__union_PrinterElementDataType_PrinterConfiguration:
		return soap_out_PointerTowprt__PrinterConfigurationType(soap, "wprt:PrinterConfiguration", -1, &a->PrinterConfiguration, "");
	case SOAP_UNION__wprt__union_PrinterElementDataType_PrinterStatus:
		return soap_out_PointerTowprt__PrinterStatusType(soap, "wprt:PrinterStatus", -1, &a->PrinterStatus, "");
	case SOAP_UNION__wprt__union_PrinterElementDataType_DefaultPrintTicket:
		return soap_out_PointerTowprt__PrintTicketType(soap, "wprt:DefaultPrintTicket", -1, &a->DefaultPrintTicket, "");
	case SOAP_UNION__wprt__union_PrinterElementDataType_PrinterCapabilities:
		return soap_out_PointerTowprt__PrinterCapabilitiesType(soap, "wprt:PrinterCapabilities", -1, &a->PrinterCapabilities, "");
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _wprt__union_PrinterElementDataType * SOAP_FMAC4 soap_in__wprt__union_PrinterElementDataType(struct soap *soap, int *choice, union _wprt__union_PrinterElementDataType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->PrinterDescription = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowprt__PrinterDescriptionType(soap, "PrinterDescription", &a->PrinterDescription, "wprt:PrinterDescriptionType"))
	{	*choice = SOAP_UNION__wprt__union_PrinterElementDataType_PrinterDescription;
		return a;
	}
	a->PrinterConfiguration = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowprt__PrinterConfigurationType(soap, "PrinterConfiguration", &a->PrinterConfiguration, "wprt:PrinterConfigurationType"))
	{	*choice = SOAP_UNION__wprt__union_PrinterElementDataType_PrinterConfiguration;
		return a;
	}
	a->PrinterStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowprt__PrinterStatusType(soap, "PrinterStatus", &a->PrinterStatus, "wprt:PrinterStatusType"))
	{	*choice = SOAP_UNION__wprt__union_PrinterElementDataType_PrinterStatus;
		return a;
	}
	a->DefaultPrintTicket = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowprt__PrintTicketType(soap, "DefaultPrintTicket", &a->DefaultPrintTicket, "wprt:PrintTicketType"))
	{	*choice = SOAP_UNION__wprt__union_PrinterElementDataType_DefaultPrintTicket;
		return a;
	}
	a->PrinterCapabilities = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowprt__PrinterCapabilitiesType(soap, "PrinterCapabilities", &a->PrinterCapabilities, "wprt:PrinterCapabilitiesType"))
	{	*choice = SOAP_UNION__wprt__union_PrinterElementDataType_PrinterCapabilities;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wprt__union_JobElementDataType(struct soap *soap, int choice, const union _wprt__union_JobElementDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__wprt__union_JobElementDataType_JobStatus:
		soap_serialize_PointerTowprt__JobStatusType(soap, &a->JobStatus);
		break;
	case SOAP_UNION__wprt__union_JobElementDataType_PrintTicket:
		soap_serialize_PointerTowprt__PrintTicketType(soap, &a->PrintTicket);
		break;
	case SOAP_UNION__wprt__union_JobElementDataType_Documents:
		soap_serialize_PointerTowprt__DocumentsType(soap, &a->Documents);
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wprt__union_JobElementDataType(struct soap *soap, int choice, const union _wprt__union_JobElementDataType *a)
{
	switch (choice)
	{
	case SOAP_UNION__wprt__union_JobElementDataType_JobStatus:
		return soap_out_PointerTowprt__JobStatusType(soap, "wprt:JobStatus", -1, &a->JobStatus, "");
	case SOAP_UNION__wprt__union_JobElementDataType_PrintTicket:
		return soap_out_PointerTowprt__PrintTicketType(soap, "wprt:PrintTicket", -1, &a->PrintTicket, "");
	case SOAP_UNION__wprt__union_JobElementDataType_Documents:
		return soap_out_PointerTowprt__DocumentsType(soap, "wprt:Documents", -1, &a->Documents, "");
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _wprt__union_JobElementDataType * SOAP_FMAC4 soap_in__wprt__union_JobElementDataType(struct soap *soap, int *choice, union _wprt__union_JobElementDataType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->JobStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowprt__JobStatusType(soap, "JobStatus", &a->JobStatus, "wprt:JobStatusType"))
	{	*choice = SOAP_UNION__wprt__union_JobElementDataType_JobStatus;
		return a;
	}
	a->PrintTicket = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowprt__PrintTicketType(soap, "PrintTicket", &a->PrintTicket, "wprt:PrintTicketType"))
	{	*choice = SOAP_UNION__wprt__union_JobElementDataType_PrintTicket;
		return a;
	}
	a->Documents = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowprt__DocumentsType(soap, "Documents", &a->Documents, "wprt:DocumentsType"))
	{	*choice = SOAP_UNION__wprt__union_JobElementDataType_Documents;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobEndStateEventType(struct soap *soap, struct wprt__JobEndStateEventType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobEndStateEventType))
		soap_serialize_wprt__JobEndStateEventType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobEndStateEventType(struct soap *soap, struct wprt__JobEndStateEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobEndStateEventType);
	if (soap_out_PointerTowprt__JobEndStateEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobEndStateEventType(struct soap *soap, const char *tag, int id, struct wprt__JobEndStateEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobEndStateEventType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobEndStateEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobEndStateEventType ** SOAP_FMAC4 soap_get_PointerTowprt__JobEndStateEventType(struct soap *soap, struct wprt__JobEndStateEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobEndStateEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobEndStateEventType ** SOAP_FMAC4 soap_in_PointerTowprt__JobEndStateEventType(struct soap *soap, const char *tag, struct wprt__JobEndStateEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobEndStateEventType **)soap_malloc(soap, sizeof(struct wprt__JobEndStateEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobEndStateEventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobEndStateEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobEndStateEventType, sizeof(struct wprt__JobEndStateEventType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobStatusEventType(struct soap *soap, struct wprt__JobStatusEventType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobStatusEventType))
		soap_serialize_wprt__JobStatusEventType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobStatusEventType(struct soap *soap, struct wprt__JobStatusEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobStatusEventType);
	if (soap_out_PointerTowprt__JobStatusEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobStatusEventType(struct soap *soap, const char *tag, int id, struct wprt__JobStatusEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobStatusEventType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobStatusEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobStatusEventType ** SOAP_FMAC4 soap_get_PointerTowprt__JobStatusEventType(struct soap *soap, struct wprt__JobStatusEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobStatusEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStatusEventType ** SOAP_FMAC4 soap_in_PointerTowprt__JobStatusEventType(struct soap *soap, const char *tag, struct wprt__JobStatusEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobStatusEventType **)soap_malloc(soap, sizeof(struct wprt__JobStatusEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobStatusEventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobStatusEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobStatusEventType, sizeof(struct wprt__JobStatusEventType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterStatusConditionClearedEventType(struct soap *soap, struct wprt__PrinterStatusConditionClearedEventType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType))
		soap_serialize_wprt__PrinterStatusConditionClearedEventType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterStatusConditionClearedEventType(struct soap *soap, struct wprt__PrinterStatusConditionClearedEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterStatusConditionClearedEventType);
	if (soap_out_PointerTowprt__PrinterStatusConditionClearedEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterStatusConditionClearedEventType(struct soap *soap, const char *tag, int id, struct wprt__PrinterStatusConditionClearedEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterStatusConditionClearedEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterStatusConditionClearedEventType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterStatusConditionClearedEventType(struct soap *soap, struct wprt__PrinterStatusConditionClearedEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterStatusConditionClearedEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStatusConditionClearedEventType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterStatusConditionClearedEventType(struct soap *soap, const char *tag, struct wprt__PrinterStatusConditionClearedEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterStatusConditionClearedEventType **)soap_malloc(soap, sizeof(struct wprt__PrinterStatusConditionClearedEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterStatusConditionClearedEventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStatusConditionClearedEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterStatusConditionClearedEventType, sizeof(struct wprt__PrinterStatusConditionClearedEventType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterStatusConditionEventType(struct soap *soap, struct wprt__PrinterStatusConditionEventType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterStatusConditionEventType))
		soap_serialize_wprt__PrinterStatusConditionEventType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterStatusConditionEventType(struct soap *soap, struct wprt__PrinterStatusConditionEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterStatusConditionEventType);
	if (soap_out_PointerTowprt__PrinterStatusConditionEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterStatusConditionEventType(struct soap *soap, const char *tag, int id, struct wprt__PrinterStatusConditionEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterStatusConditionEventType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterStatusConditionEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterStatusConditionEventType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterStatusConditionEventType(struct soap *soap, struct wprt__PrinterStatusConditionEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterStatusConditionEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStatusConditionEventType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterStatusConditionEventType(struct soap *soap, const char *tag, struct wprt__PrinterStatusConditionEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterStatusConditionEventType **)soap_malloc(soap, sizeof(struct wprt__PrinterStatusConditionEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterStatusConditionEventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStatusConditionEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterStatusConditionEventType, sizeof(struct wprt__PrinterStatusConditionEventType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterStatusSummaryEventType(struct soap *soap, struct wprt__PrinterStatusSummaryEventType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterStatusSummaryEventType))
		soap_serialize_wprt__PrinterStatusSummaryEventType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterStatusSummaryEventType(struct soap *soap, struct wprt__PrinterStatusSummaryEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterStatusSummaryEventType);
	if (soap_out_PointerTowprt__PrinterStatusSummaryEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterStatusSummaryEventType(struct soap *soap, const char *tag, int id, struct wprt__PrinterStatusSummaryEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterStatusSummaryEventType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterStatusSummaryEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterStatusSummaryEventType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterStatusSummaryEventType(struct soap *soap, struct wprt__PrinterStatusSummaryEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterStatusSummaryEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStatusSummaryEventType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterStatusSummaryEventType(struct soap *soap, const char *tag, struct wprt__PrinterStatusSummaryEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterStatusSummaryEventType **)soap_malloc(soap, sizeof(struct wprt__PrinterStatusSummaryEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterStatusSummaryEventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStatusSummaryEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterStatusSummaryEventType, sizeof(struct wprt__PrinterStatusSummaryEventType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterElementsChangeEventType(struct soap *soap, struct wprt__PrinterElementsChangeEventType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterElementsChangeEventType))
		soap_serialize_wprt__PrinterElementsChangeEventType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterElementsChangeEventType(struct soap *soap, struct wprt__PrinterElementsChangeEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterElementsChangeEventType);
	if (soap_out_PointerTowprt__PrinterElementsChangeEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterElementsChangeEventType(struct soap *soap, const char *tag, int id, struct wprt__PrinterElementsChangeEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterElementsChangeEventType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterElementsChangeEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterElementsChangeEventType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterElementsChangeEventType(struct soap *soap, struct wprt__PrinterElementsChangeEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterElementsChangeEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterElementsChangeEventType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterElementsChangeEventType(struct soap *soap, const char *tag, struct wprt__PrinterElementsChangeEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterElementsChangeEventType **)soap_malloc(soap, sizeof(struct wprt__PrinterElementsChangeEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterElementsChangeEventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterElementsChangeEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterElementsChangeEventType, sizeof(struct wprt__PrinterElementsChangeEventType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__SetEventRateResponseType(struct soap *soap, struct wprt__SetEventRateResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__SetEventRateResponseType))
		soap_serialize_wprt__SetEventRateResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__SetEventRateResponseType(struct soap *soap, struct wprt__SetEventRateResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__SetEventRateResponseType);
	if (soap_out_PointerTowprt__SetEventRateResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__SetEventRateResponseType(struct soap *soap, const char *tag, int id, struct wprt__SetEventRateResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__SetEventRateResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__SetEventRateResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__SetEventRateResponseType ** SOAP_FMAC4 soap_get_PointerTowprt__SetEventRateResponseType(struct soap *soap, struct wprt__SetEventRateResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__SetEventRateResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SetEventRateResponseType ** SOAP_FMAC4 soap_in_PointerTowprt__SetEventRateResponseType(struct soap *soap, const char *tag, struct wprt__SetEventRateResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__SetEventRateResponseType **)soap_malloc(soap, sizeof(struct wprt__SetEventRateResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__SetEventRateResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__SetEventRateResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__SetEventRateResponseType, sizeof(struct wprt__SetEventRateResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__SetEventRateRequestType(struct soap *soap, struct wprt__SetEventRateRequestType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__SetEventRateRequestType))
		soap_serialize_wprt__SetEventRateRequestType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__SetEventRateRequestType(struct soap *soap, struct wprt__SetEventRateRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__SetEventRateRequestType);
	if (soap_out_PointerTowprt__SetEventRateRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__SetEventRateRequestType(struct soap *soap, const char *tag, int id, struct wprt__SetEventRateRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__SetEventRateRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__SetEventRateRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__SetEventRateRequestType ** SOAP_FMAC4 soap_get_PointerTowprt__SetEventRateRequestType(struct soap *soap, struct wprt__SetEventRateRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__SetEventRateRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SetEventRateRequestType ** SOAP_FMAC4 soap_in_PointerTowprt__SetEventRateRequestType(struct soap *soap, const char *tag, struct wprt__SetEventRateRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__SetEventRateRequestType **)soap_malloc(soap, sizeof(struct wprt__SetEventRateRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__SetEventRateRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__SetEventRateRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__SetEventRateRequestType, sizeof(struct wprt__SetEventRateRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__GetJobHistoryResponseType(struct soap *soap, struct wprt__GetJobHistoryResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__GetJobHistoryResponseType))
		soap_serialize_wprt__GetJobHistoryResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__GetJobHistoryResponseType(struct soap *soap, struct wprt__GetJobHistoryResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__GetJobHistoryResponseType);
	if (soap_out_PointerTowprt__GetJobHistoryResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__GetJobHistoryResponseType(struct soap *soap, const char *tag, int id, struct wprt__GetJobHistoryResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__GetJobHistoryResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__GetJobHistoryResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__GetJobHistoryResponseType ** SOAP_FMAC4 soap_get_PointerTowprt__GetJobHistoryResponseType(struct soap *soap, struct wprt__GetJobHistoryResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__GetJobHistoryResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetJobHistoryResponseType ** SOAP_FMAC4 soap_in_PointerTowprt__GetJobHistoryResponseType(struct soap *soap, const char *tag, struct wprt__GetJobHistoryResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__GetJobHistoryResponseType **)soap_malloc(soap, sizeof(struct wprt__GetJobHistoryResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__GetJobHistoryResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__GetJobHistoryResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__GetJobHistoryResponseType, sizeof(struct wprt__GetJobHistoryResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__GetJobHistoryRequestType(struct soap *soap, struct wprt__GetJobHistoryRequestType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__GetJobHistoryRequestType))
		soap_serialize_wprt__GetJobHistoryRequestType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__GetJobHistoryRequestType(struct soap *soap, struct wprt__GetJobHistoryRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__GetJobHistoryRequestType);
	if (soap_out_PointerTowprt__GetJobHistoryRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__GetJobHistoryRequestType(struct soap *soap, const char *tag, int id, struct wprt__GetJobHistoryRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__GetJobHistoryRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__GetJobHistoryRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__GetJobHistoryRequestType ** SOAP_FMAC4 soap_get_PointerTowprt__GetJobHistoryRequestType(struct soap *soap, struct wprt__GetJobHistoryRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__GetJobHistoryRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetJobHistoryRequestType ** SOAP_FMAC4 soap_in_PointerTowprt__GetJobHistoryRequestType(struct soap *soap, const char *tag, struct wprt__GetJobHistoryRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__GetJobHistoryRequestType **)soap_malloc(soap, sizeof(struct wprt__GetJobHistoryRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__GetJobHistoryRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__GetJobHistoryRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__GetJobHistoryRequestType, sizeof(struct wprt__GetJobHistoryRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__GetActiveJobsResponseType(struct soap *soap, struct wprt__GetActiveJobsResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__GetActiveJobsResponseType))
		soap_serialize_wprt__GetActiveJobsResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__GetActiveJobsResponseType(struct soap *soap, struct wprt__GetActiveJobsResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__GetActiveJobsResponseType);
	if (soap_out_PointerTowprt__GetActiveJobsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__GetActiveJobsResponseType(struct soap *soap, const char *tag, int id, struct wprt__GetActiveJobsResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__GetActiveJobsResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__GetActiveJobsResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__GetActiveJobsResponseType ** SOAP_FMAC4 soap_get_PointerTowprt__GetActiveJobsResponseType(struct soap *soap, struct wprt__GetActiveJobsResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__GetActiveJobsResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetActiveJobsResponseType ** SOAP_FMAC4 soap_in_PointerTowprt__GetActiveJobsResponseType(struct soap *soap, const char *tag, struct wprt__GetActiveJobsResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__GetActiveJobsResponseType **)soap_malloc(soap, sizeof(struct wprt__GetActiveJobsResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__GetActiveJobsResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__GetActiveJobsResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__GetActiveJobsResponseType, sizeof(struct wprt__GetActiveJobsResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__GetActiveJobsRequestType(struct soap *soap, struct wprt__GetActiveJobsRequestType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__GetActiveJobsRequestType))
		soap_serialize_wprt__GetActiveJobsRequestType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__GetActiveJobsRequestType(struct soap *soap, struct wprt__GetActiveJobsRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__GetActiveJobsRequestType);
	if (soap_out_PointerTowprt__GetActiveJobsRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__GetActiveJobsRequestType(struct soap *soap, const char *tag, int id, struct wprt__GetActiveJobsRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__GetActiveJobsRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__GetActiveJobsRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__GetActiveJobsRequestType ** SOAP_FMAC4 soap_get_PointerTowprt__GetActiveJobsRequestType(struct soap *soap, struct wprt__GetActiveJobsRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__GetActiveJobsRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetActiveJobsRequestType ** SOAP_FMAC4 soap_in_PointerTowprt__GetActiveJobsRequestType(struct soap *soap, const char *tag, struct wprt__GetActiveJobsRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__GetActiveJobsRequestType **)soap_malloc(soap, sizeof(struct wprt__GetActiveJobsRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__GetActiveJobsRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__GetActiveJobsRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__GetActiveJobsRequestType, sizeof(struct wprt__GetActiveJobsRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__GetJobElementsResponseType(struct soap *soap, struct wprt__GetJobElementsResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__GetJobElementsResponseType))
		soap_serialize_wprt__GetJobElementsResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__GetJobElementsResponseType(struct soap *soap, struct wprt__GetJobElementsResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__GetJobElementsResponseType);
	if (soap_out_PointerTowprt__GetJobElementsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__GetJobElementsResponseType(struct soap *soap, const char *tag, int id, struct wprt__GetJobElementsResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__GetJobElementsResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__GetJobElementsResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__GetJobElementsResponseType ** SOAP_FMAC4 soap_get_PointerTowprt__GetJobElementsResponseType(struct soap *soap, struct wprt__GetJobElementsResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__GetJobElementsResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetJobElementsResponseType ** SOAP_FMAC4 soap_in_PointerTowprt__GetJobElementsResponseType(struct soap *soap, const char *tag, struct wprt__GetJobElementsResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__GetJobElementsResponseType **)soap_malloc(soap, sizeof(struct wprt__GetJobElementsResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__GetJobElementsResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__GetJobElementsResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__GetJobElementsResponseType, sizeof(struct wprt__GetJobElementsResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__GetJobElementsRequestType(struct soap *soap, struct wprt__GetJobElementsRequestType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__GetJobElementsRequestType))
		soap_serialize_wprt__GetJobElementsRequestType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__GetJobElementsRequestType(struct soap *soap, struct wprt__GetJobElementsRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__GetJobElementsRequestType);
	if (soap_out_PointerTowprt__GetJobElementsRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__GetJobElementsRequestType(struct soap *soap, const char *tag, int id, struct wprt__GetJobElementsRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__GetJobElementsRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__GetJobElementsRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__GetJobElementsRequestType ** SOAP_FMAC4 soap_get_PointerTowprt__GetJobElementsRequestType(struct soap *soap, struct wprt__GetJobElementsRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__GetJobElementsRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetJobElementsRequestType ** SOAP_FMAC4 soap_in_PointerTowprt__GetJobElementsRequestType(struct soap *soap, const char *tag, struct wprt__GetJobElementsRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__GetJobElementsRequestType **)soap_malloc(soap, sizeof(struct wprt__GetJobElementsRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__GetJobElementsRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__GetJobElementsRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__GetJobElementsRequestType, sizeof(struct wprt__GetJobElementsRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__GetPrinterElementsResponseType(struct soap *soap, struct wprt__GetPrinterElementsResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__GetPrinterElementsResponseType))
		soap_serialize_wprt__GetPrinterElementsResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__GetPrinterElementsResponseType(struct soap *soap, struct wprt__GetPrinterElementsResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__GetPrinterElementsResponseType);
	if (soap_out_PointerTowprt__GetPrinterElementsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__GetPrinterElementsResponseType(struct soap *soap, const char *tag, int id, struct wprt__GetPrinterElementsResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__GetPrinterElementsResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__GetPrinterElementsResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__GetPrinterElementsResponseType ** SOAP_FMAC4 soap_get_PointerTowprt__GetPrinterElementsResponseType(struct soap *soap, struct wprt__GetPrinterElementsResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__GetPrinterElementsResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetPrinterElementsResponseType ** SOAP_FMAC4 soap_in_PointerTowprt__GetPrinterElementsResponseType(struct soap *soap, const char *tag, struct wprt__GetPrinterElementsResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__GetPrinterElementsResponseType **)soap_malloc(soap, sizeof(struct wprt__GetPrinterElementsResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__GetPrinterElementsResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__GetPrinterElementsResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__GetPrinterElementsResponseType, sizeof(struct wprt__GetPrinterElementsResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__GetPrinterElementsRequestType(struct soap *soap, struct wprt__GetPrinterElementsRequestType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__GetPrinterElementsRequestType))
		soap_serialize_wprt__GetPrinterElementsRequestType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__GetPrinterElementsRequestType(struct soap *soap, struct wprt__GetPrinterElementsRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__GetPrinterElementsRequestType);
	if (soap_out_PointerTowprt__GetPrinterElementsRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__GetPrinterElementsRequestType(struct soap *soap, const char *tag, int id, struct wprt__GetPrinterElementsRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__GetPrinterElementsRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__GetPrinterElementsRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__GetPrinterElementsRequestType ** SOAP_FMAC4 soap_get_PointerTowprt__GetPrinterElementsRequestType(struct soap *soap, struct wprt__GetPrinterElementsRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__GetPrinterElementsRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__GetPrinterElementsRequestType ** SOAP_FMAC4 soap_in_PointerTowprt__GetPrinterElementsRequestType(struct soap *soap, const char *tag, struct wprt__GetPrinterElementsRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__GetPrinterElementsRequestType **)soap_malloc(soap, sizeof(struct wprt__GetPrinterElementsRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__GetPrinterElementsRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__GetPrinterElementsRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__GetPrinterElementsRequestType, sizeof(struct wprt__GetPrinterElementsRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__CancelJobResponseType(struct soap *soap, struct wprt__CancelJobResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__CancelJobResponseType))
		soap_serialize_wprt__CancelJobResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__CancelJobResponseType(struct soap *soap, struct wprt__CancelJobResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__CancelJobResponseType);
	if (soap_out_PointerTowprt__CancelJobResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__CancelJobResponseType(struct soap *soap, const char *tag, int id, struct wprt__CancelJobResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__CancelJobResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__CancelJobResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__CancelJobResponseType ** SOAP_FMAC4 soap_get_PointerTowprt__CancelJobResponseType(struct soap *soap, struct wprt__CancelJobResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__CancelJobResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CancelJobResponseType ** SOAP_FMAC4 soap_in_PointerTowprt__CancelJobResponseType(struct soap *soap, const char *tag, struct wprt__CancelJobResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__CancelJobResponseType **)soap_malloc(soap, sizeof(struct wprt__CancelJobResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__CancelJobResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__CancelJobResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__CancelJobResponseType, sizeof(struct wprt__CancelJobResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__CancelJobRequestType(struct soap *soap, struct wprt__CancelJobRequestType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__CancelJobRequestType))
		soap_serialize_wprt__CancelJobRequestType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__CancelJobRequestType(struct soap *soap, struct wprt__CancelJobRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__CancelJobRequestType);
	if (soap_out_PointerTowprt__CancelJobRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__CancelJobRequestType(struct soap *soap, const char *tag, int id, struct wprt__CancelJobRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__CancelJobRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__CancelJobRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__CancelJobRequestType ** SOAP_FMAC4 soap_get_PointerTowprt__CancelJobRequestType(struct soap *soap, struct wprt__CancelJobRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__CancelJobRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CancelJobRequestType ** SOAP_FMAC4 soap_in_PointerTowprt__CancelJobRequestType(struct soap *soap, const char *tag, struct wprt__CancelJobRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__CancelJobRequestType **)soap_malloc(soap, sizeof(struct wprt__CancelJobRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__CancelJobRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__CancelJobRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__CancelJobRequestType, sizeof(struct wprt__CancelJobRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__AddDocumentResponseType(struct soap *soap, struct wprt__AddDocumentResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__AddDocumentResponseType))
		soap_serialize_wprt__AddDocumentResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__AddDocumentResponseType(struct soap *soap, struct wprt__AddDocumentResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__AddDocumentResponseType);
	if (soap_out_PointerTowprt__AddDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__AddDocumentResponseType(struct soap *soap, const char *tag, int id, struct wprt__AddDocumentResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__AddDocumentResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__AddDocumentResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__AddDocumentResponseType ** SOAP_FMAC4 soap_get_PointerTowprt__AddDocumentResponseType(struct soap *soap, struct wprt__AddDocumentResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__AddDocumentResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__AddDocumentResponseType ** SOAP_FMAC4 soap_in_PointerTowprt__AddDocumentResponseType(struct soap *soap, const char *tag, struct wprt__AddDocumentResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__AddDocumentResponseType **)soap_malloc(soap, sizeof(struct wprt__AddDocumentResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__AddDocumentResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__AddDocumentResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__AddDocumentResponseType, sizeof(struct wprt__AddDocumentResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__AddDocumentRequestType(struct soap *soap, struct wprt__AddDocumentRequestType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__AddDocumentRequestType))
		soap_serialize_wprt__AddDocumentRequestType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__AddDocumentRequestType(struct soap *soap, struct wprt__AddDocumentRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__AddDocumentRequestType);
	if (soap_out_PointerTowprt__AddDocumentRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__AddDocumentRequestType(struct soap *soap, const char *tag, int id, struct wprt__AddDocumentRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__AddDocumentRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__AddDocumentRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__AddDocumentRequestType ** SOAP_FMAC4 soap_get_PointerTowprt__AddDocumentRequestType(struct soap *soap, struct wprt__AddDocumentRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__AddDocumentRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__AddDocumentRequestType ** SOAP_FMAC4 soap_in_PointerTowprt__AddDocumentRequestType(struct soap *soap, const char *tag, struct wprt__AddDocumentRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__AddDocumentRequestType **)soap_malloc(soap, sizeof(struct wprt__AddDocumentRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__AddDocumentRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__AddDocumentRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__AddDocumentRequestType, sizeof(struct wprt__AddDocumentRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__SendDocumentResponseType(struct soap *soap, struct wprt__SendDocumentResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__SendDocumentResponseType))
		soap_serialize_wprt__SendDocumentResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__SendDocumentResponseType(struct soap *soap, struct wprt__SendDocumentResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__SendDocumentResponseType);
	if (soap_out_PointerTowprt__SendDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__SendDocumentResponseType(struct soap *soap, const char *tag, int id, struct wprt__SendDocumentResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__SendDocumentResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__SendDocumentResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__SendDocumentResponseType ** SOAP_FMAC4 soap_get_PointerTowprt__SendDocumentResponseType(struct soap *soap, struct wprt__SendDocumentResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__SendDocumentResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SendDocumentResponseType ** SOAP_FMAC4 soap_in_PointerTowprt__SendDocumentResponseType(struct soap *soap, const char *tag, struct wprt__SendDocumentResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__SendDocumentResponseType **)soap_malloc(soap, sizeof(struct wprt__SendDocumentResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__SendDocumentResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__SendDocumentResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__SendDocumentResponseType, sizeof(struct wprt__SendDocumentResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__SendDocumentRequestType(struct soap *soap, struct wprt__SendDocumentRequestType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__SendDocumentRequestType))
		soap_serialize_wprt__SendDocumentRequestType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__SendDocumentRequestType(struct soap *soap, struct wprt__SendDocumentRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__SendDocumentRequestType);
	if (soap_out_PointerTowprt__SendDocumentRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__SendDocumentRequestType(struct soap *soap, const char *tag, int id, struct wprt__SendDocumentRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__SendDocumentRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__SendDocumentRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__SendDocumentRequestType ** SOAP_FMAC4 soap_get_PointerTowprt__SendDocumentRequestType(struct soap *soap, struct wprt__SendDocumentRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__SendDocumentRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SendDocumentRequestType ** SOAP_FMAC4 soap_in_PointerTowprt__SendDocumentRequestType(struct soap *soap, const char *tag, struct wprt__SendDocumentRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__SendDocumentRequestType **)soap_malloc(soap, sizeof(struct wprt__SendDocumentRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__SendDocumentRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__SendDocumentRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__SendDocumentRequestType, sizeof(struct wprt__SendDocumentRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__CreatePrintJobResponseType(struct soap *soap, struct wprt__CreatePrintJobResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__CreatePrintJobResponseType))
		soap_serialize_wprt__CreatePrintJobResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__CreatePrintJobResponseType(struct soap *soap, struct wprt__CreatePrintJobResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__CreatePrintJobResponseType);
	if (soap_out_PointerTowprt__CreatePrintJobResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__CreatePrintJobResponseType(struct soap *soap, const char *tag, int id, struct wprt__CreatePrintJobResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__CreatePrintJobResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__CreatePrintJobResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__CreatePrintJobResponseType ** SOAP_FMAC4 soap_get_PointerTowprt__CreatePrintJobResponseType(struct soap *soap, struct wprt__CreatePrintJobResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__CreatePrintJobResponseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CreatePrintJobResponseType ** SOAP_FMAC4 soap_in_PointerTowprt__CreatePrintJobResponseType(struct soap *soap, const char *tag, struct wprt__CreatePrintJobResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__CreatePrintJobResponseType **)soap_malloc(soap, sizeof(struct wprt__CreatePrintJobResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__CreatePrintJobResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__CreatePrintJobResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__CreatePrintJobResponseType, sizeof(struct wprt__CreatePrintJobResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__CreatePrintJobRequestType(struct soap *soap, struct wprt__CreatePrintJobRequestType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__CreatePrintJobRequestType))
		soap_serialize_wprt__CreatePrintJobRequestType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__CreatePrintJobRequestType(struct soap *soap, struct wprt__CreatePrintJobRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__CreatePrintJobRequestType);
	if (soap_out_PointerTowprt__CreatePrintJobRequestType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__CreatePrintJobRequestType(struct soap *soap, const char *tag, int id, struct wprt__CreatePrintJobRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__CreatePrintJobRequestType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__CreatePrintJobRequestType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__CreatePrintJobRequestType ** SOAP_FMAC4 soap_get_PointerTowprt__CreatePrintJobRequestType(struct soap *soap, struct wprt__CreatePrintJobRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__CreatePrintJobRequestType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CreatePrintJobRequestType ** SOAP_FMAC4 soap_in_PointerTowprt__CreatePrintJobRequestType(struct soap *soap, const char *tag, struct wprt__CreatePrintJobRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__CreatePrintJobRequestType **)soap_malloc(soap, sizeof(struct wprt__CreatePrintJobRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__CreatePrintJobRequestType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__CreatePrintJobRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__CreatePrintJobRequestType, sizeof(struct wprt__CreatePrintJobRequestType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobTableType(struct soap *soap, struct wprt__JobTableType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobTableType))
		soap_serialize_wprt__JobTableType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobTableType(struct soap *soap, struct wprt__JobTableType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobTableType);
	if (soap_out_PointerTowprt__JobTableType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobTableType(struct soap *soap, const char *tag, int id, struct wprt__JobTableType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobTableType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobTableType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobTableType ** SOAP_FMAC4 soap_get_PointerTowprt__JobTableType(struct soap *soap, struct wprt__JobTableType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobTableType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobTableType ** SOAP_FMAC4 soap_in_PointerTowprt__JobTableType(struct soap *soap, const char *tag, struct wprt__JobTableType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobTableType **)soap_malloc(soap, sizeof(struct wprt__JobTableType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobTableType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobTableType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobTableType, sizeof(struct wprt__JobTableType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterElementDataType(struct soap *soap, struct wprt__PrinterElementDataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterElementDataType))
		soap_serialize_wprt__PrinterElementDataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterElementDataType(struct soap *soap, struct wprt__PrinterElementDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterElementDataType);
	if (soap_out_PointerTowprt__PrinterElementDataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterElementDataType(struct soap *soap, const char *tag, int id, struct wprt__PrinterElementDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterElementDataType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterElementDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterElementDataType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterElementDataType(struct soap *soap, struct wprt__PrinterElementDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterElementDataType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterElementDataType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterElementDataType(struct soap *soap, const char *tag, struct wprt__PrinterElementDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterElementDataType **)soap_malloc(soap, sizeof(struct wprt__PrinterElementDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterElementDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterElementDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterElementDataType, sizeof(struct wprt__PrinterElementDataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wprt__DocumentValuesType_DocumentDescription(struct soap *soap, struct _wprt__DocumentValuesType_DocumentDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription))
		soap_serialize__wprt__DocumentValuesType_DocumentDescription(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wprt__DocumentValuesType_DocumentDescription(struct soap *soap, struct _wprt__DocumentValuesType_DocumentDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wprt__DocumentValuesType_DocumentDescription);
	if (soap_out_PointerTo_wprt__DocumentValuesType_DocumentDescription(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wprt__DocumentValuesType_DocumentDescription(struct soap *soap, const char *tag, int id, struct _wprt__DocumentValuesType_DocumentDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription);
	if (id < 0)
		return soap->error;
	return soap_out__wprt__DocumentValuesType_DocumentDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wprt__DocumentValuesType_DocumentDescription ** SOAP_FMAC4 soap_get_PointerTo_wprt__DocumentValuesType_DocumentDescription(struct soap *soap, struct _wprt__DocumentValuesType_DocumentDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wprt__DocumentValuesType_DocumentDescription(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__DocumentValuesType_DocumentDescription ** SOAP_FMAC4 soap_in_PointerTo_wprt__DocumentValuesType_DocumentDescription(struct soap *soap, const char *tag, struct _wprt__DocumentValuesType_DocumentDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wprt__DocumentValuesType_DocumentDescription **)soap_malloc(soap, sizeof(struct _wprt__DocumentValuesType_DocumentDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wprt__DocumentValuesType_DocumentDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wprt__DocumentValuesType_DocumentDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wprt__DocumentValuesType_DocumentDescription, sizeof(struct _wprt__DocumentValuesType_DocumentDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ValueStringListType(struct soap *soap, struct wprt__ValueStringListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ValueStringListType))
		soap_serialize_wprt__ValueStringListType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ValueStringListType(struct soap *soap, struct wprt__ValueStringListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ValueStringListType);
	if (soap_out_PointerTowprt__ValueStringListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ValueStringListType(struct soap *soap, const char *tag, int id, struct wprt__ValueStringListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ValueStringListType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ValueStringListType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ValueStringListType ** SOAP_FMAC4 soap_get_PointerTowprt__ValueStringListType(struct soap *soap, struct wprt__ValueStringListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ValueStringListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ValueStringListType ** SOAP_FMAC4 soap_in_PointerTowprt__ValueStringListType(struct soap *soap, const char *tag, struct wprt__ValueStringListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ValueStringListType **)soap_malloc(soap, sizeof(struct wprt__ValueStringListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ValueStringListType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ValueStringListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ValueStringListType, sizeof(struct wprt__ValueStringListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wprt__JobValuesType_DocumentProcessing(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing))
		soap_serialize__wprt__JobValuesType_DocumentProcessing(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wprt__JobValuesType_DocumentProcessing(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing);
	if (soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing(struct soap *soap, const char *tag, int id, struct _wprt__JobValuesType_DocumentProcessing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing);
	if (id < 0)
		return soap->error;
	return soap_out__wprt__JobValuesType_DocumentProcessing(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing ** SOAP_FMAC4 soap_get_PointerTo_wprt__JobValuesType_DocumentProcessing(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing ** SOAP_FMAC4 soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing(struct soap *soap, const char *tag, struct _wprt__JobValuesType_DocumentProcessing **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wprt__JobValuesType_DocumentProcessing **)soap_malloc(soap, sizeof(struct _wprt__JobValuesType_DocumentProcessing *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wprt__JobValuesType_DocumentProcessing(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_DocumentProcessing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing, sizeof(struct _wprt__JobValuesType_DocumentProcessing), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_Resolution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution))
		soap_serialize__wprt__JobValuesType_DocumentProcessing_Resolution(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_Resolution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution);
	if (soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, const char *tag, int id, struct _wprt__JobValuesType_DocumentProcessing_Resolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution);
	if (id < 0)
		return soap->error;
	return soap_out__wprt__JobValuesType_DocumentProcessing_Resolution(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing_Resolution ** SOAP_FMAC4 soap_get_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_Resolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing_Resolution ** SOAP_FMAC4 soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing_Resolution(struct soap *soap, const char *tag, struct _wprt__JobValuesType_DocumentProcessing_Resolution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wprt__JobValuesType_DocumentProcessing_Resolution **)soap_malloc(soap, sizeof(struct _wprt__JobValuesType_DocumentProcessing_Resolution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wprt__JobValuesType_DocumentProcessing_Resolution(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_DocumentProcessing_Resolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_Resolution, sizeof(struct _wprt__JobValuesType_DocumentProcessing_Resolution), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ResolutionEntryType(struct soap *soap, struct wprt__ResolutionEntryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ResolutionEntryType))
		soap_serialize_wprt__ResolutionEntryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ResolutionEntryType(struct soap *soap, struct wprt__ResolutionEntryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ResolutionEntryType);
	if (soap_out_PointerTowprt__ResolutionEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ResolutionEntryType(struct soap *soap, const char *tag, int id, struct wprt__ResolutionEntryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ResolutionEntryType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ResolutionEntryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ResolutionEntryType ** SOAP_FMAC4 soap_get_PointerTowprt__ResolutionEntryType(struct soap *soap, struct wprt__ResolutionEntryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ResolutionEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ResolutionEntryType ** SOAP_FMAC4 soap_in_PointerTowprt__ResolutionEntryType(struct soap *soap, const char *tag, struct wprt__ResolutionEntryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ResolutionEntryType **)soap_malloc(soap, sizeof(struct wprt__ResolutionEntryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ResolutionEntryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ResolutionEntryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ResolutionEntryType, sizeof(struct wprt__ResolutionEntryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_NumberUp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp))
		soap_serialize__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_NumberUp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp);
	if (soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, const char *tag, int id, struct _wprt__JobValuesType_DocumentProcessing_NumberUp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp);
	if (id < 0)
		return soap->error;
	return soap_out__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing_NumberUp ** SOAP_FMAC4 soap_get_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, struct _wprt__JobValuesType_DocumentProcessing_NumberUp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_DocumentProcessing_NumberUp ** SOAP_FMAC4 soap_in_PointerTo_wprt__JobValuesType_DocumentProcessing_NumberUp(struct soap *soap, const char *tag, struct _wprt__JobValuesType_DocumentProcessing_NumberUp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wprt__JobValuesType_DocumentProcessing_NumberUp **)soap_malloc(soap, sizeof(struct _wprt__JobValuesType_DocumentProcessing_NumberUp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wprt__JobValuesType_DocumentProcessing_NumberUp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_DocumentProcessing_NumberUp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wprt__JobValuesType_DocumentProcessing_NumberUp, sizeof(struct _wprt__JobValuesType_DocumentProcessing_NumberUp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ValueIntListType(struct soap *soap, struct wprt__ValueIntListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ValueIntListType))
		soap_serialize_wprt__ValueIntListType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ValueIntListType(struct soap *soap, struct wprt__ValueIntListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ValueIntListType);
	if (soap_out_PointerTowprt__ValueIntListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ValueIntListType(struct soap *soap, const char *tag, int id, struct wprt__ValueIntListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ValueIntListType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ValueIntListType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ValueIntListType ** SOAP_FMAC4 soap_get_PointerTowprt__ValueIntListType(struct soap *soap, struct wprt__ValueIntListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ValueIntListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ValueIntListType ** SOAP_FMAC4 soap_in_PointerTowprt__ValueIntListType(struct soap *soap, const char *tag, struct wprt__ValueIntListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ValueIntListType **)soap_malloc(soap, sizeof(struct wprt__ValueIntListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ValueIntListType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ValueIntListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ValueIntListType, sizeof(struct wprt__ValueIntListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing(struct soap *soap, struct _wprt__JobValuesType_JobProcessing *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wprt__JobValuesType_JobProcessing))
		soap_serialize__wprt__JobValuesType_JobProcessing(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wprt__JobValuesType_JobProcessing(struct soap *soap, struct _wprt__JobValuesType_JobProcessing *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing);
	if (soap_out_PointerTo_wprt__JobValuesType_JobProcessing(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wprt__JobValuesType_JobProcessing(struct soap *soap, const char *tag, int id, struct _wprt__JobValuesType_JobProcessing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wprt__JobValuesType_JobProcessing);
	if (id < 0)
		return soap->error;
	return soap_out__wprt__JobValuesType_JobProcessing(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing ** SOAP_FMAC4 soap_get_PointerTo_wprt__JobValuesType_JobProcessing(struct soap *soap, struct _wprt__JobValuesType_JobProcessing **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wprt__JobValuesType_JobProcessing(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing ** SOAP_FMAC4 soap_in_PointerTo_wprt__JobValuesType_JobProcessing(struct soap *soap, const char *tag, struct _wprt__JobValuesType_JobProcessing **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wprt__JobValuesType_JobProcessing **)soap_malloc(soap, sizeof(struct _wprt__JobValuesType_JobProcessing *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wprt__JobValuesType_JobProcessing(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_JobProcessing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wprt__JobValuesType_JobProcessing, sizeof(struct _wprt__JobValuesType_JobProcessing), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings))
		soap_serialize__wprt__JobValuesType_JobProcessing_JobFinishings(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings);
	if (soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, const char *tag, int id, struct _wprt__JobValuesType_JobProcessing_JobFinishings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings);
	if (id < 0)
		return soap->error;
	return soap_out__wprt__JobValuesType_JobProcessing_JobFinishings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings ** SOAP_FMAC4 soap_get_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings ** SOAP_FMAC4 soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings(struct soap *soap, const char *tag, struct _wprt__JobValuesType_JobProcessing_JobFinishings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings **)soap_malloc(soap, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wprt__JobValuesType_JobProcessing_JobFinishings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch))
		soap_serialize__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch);
	if (soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, const char *tag, int id, struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch);
	if (id < 0)
		return soap->error;
	return soap_out__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch ** SOAP_FMAC4 soap_get_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch ** SOAP_FMAC4 soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(struct soap *soap, const char *tag, struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch **)soap_malloc(soap, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings_HolePunch), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple))
		soap_serialize__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple);
	if (soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, const char *tag, int id, struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple);
	if (id < 0)
		return soap->error;
	return soap_out__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple ** SOAP_FMAC4 soap_get_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple ** SOAP_FMAC4 soap_in_PointerTo_wprt__JobValuesType_JobProcessing_JobFinishings_Staple(struct soap *soap, const char *tag, struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple **)soap_malloc(soap, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wprt__JobValuesType_JobProcessing_JobFinishings_Staple(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wprt__JobValuesType_JobProcessing_JobFinishings_Staple, sizeof(struct _wprt__JobValuesType_JobProcessing_JobFinishings_Staple), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ValueTokenListType(struct soap *soap, struct wprt__ValueTokenListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ValueTokenListType))
		soap_serialize_wprt__ValueTokenListType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ValueTokenListType(struct soap *soap, struct wprt__ValueTokenListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ValueTokenListType);
	if (soap_out_PointerTowprt__ValueTokenListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ValueTokenListType(struct soap *soap, const char *tag, int id, struct wprt__ValueTokenListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ValueTokenListType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ValueTokenListType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ValueTokenListType ** SOAP_FMAC4 soap_get_PointerTowprt__ValueTokenListType(struct soap *soap, struct wprt__ValueTokenListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ValueTokenListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ValueTokenListType ** SOAP_FMAC4 soap_in_PointerTowprt__ValueTokenListType(struct soap *soap, const char *tag, struct wprt__ValueTokenListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ValueTokenListType **)soap_malloc(soap, sizeof(struct wprt__ValueTokenListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ValueTokenListType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ValueTokenListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ValueTokenListType, sizeof(struct wprt__ValueTokenListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ValueIntRangeType(struct soap *soap, struct wprt__ValueIntRangeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ValueIntRangeType))
		soap_serialize_wprt__ValueIntRangeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ValueIntRangeType(struct soap *soap, struct wprt__ValueIntRangeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ValueIntRangeType);
	if (soap_out_PointerTowprt__ValueIntRangeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ValueIntRangeType(struct soap *soap, const char *tag, int id, struct wprt__ValueIntRangeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ValueIntRangeType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ValueIntRangeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ValueIntRangeType ** SOAP_FMAC4 soap_get_PointerTowprt__ValueIntRangeType(struct soap *soap, struct wprt__ValueIntRangeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ValueIntRangeType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ValueIntRangeType ** SOAP_FMAC4 soap_in_PointerTowprt__ValueIntRangeType(struct soap *soap, const char *tag, struct wprt__ValueIntRangeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ValueIntRangeType **)soap_malloc(soap, sizeof(struct wprt__ValueIntRangeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ValueIntRangeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ValueIntRangeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ValueIntRangeType, sizeof(struct wprt__ValueIntRangeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DocumentValuesType(struct soap *soap, struct wprt__DocumentValuesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DocumentValuesType))
		soap_serialize_wprt__DocumentValuesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DocumentValuesType(struct soap *soap, struct wprt__DocumentValuesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DocumentValuesType);
	if (soap_out_PointerTowprt__DocumentValuesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DocumentValuesType(struct soap *soap, const char *tag, int id, struct wprt__DocumentValuesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DocumentValuesType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DocumentValuesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DocumentValuesType ** SOAP_FMAC4 soap_get_PointerTowprt__DocumentValuesType(struct soap *soap, struct wprt__DocumentValuesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DocumentValuesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentValuesType ** SOAP_FMAC4 soap_in_PointerTowprt__DocumentValuesType(struct soap *soap, const char *tag, struct wprt__DocumentValuesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DocumentValuesType **)soap_malloc(soap, sizeof(struct wprt__DocumentValuesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DocumentValuesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentValuesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DocumentValuesType, sizeof(struct wprt__DocumentValuesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobValuesType(struct soap *soap, struct wprt__JobValuesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobValuesType))
		soap_serialize_wprt__JobValuesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobValuesType(struct soap *soap, struct wprt__JobValuesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobValuesType);
	if (soap_out_PointerTowprt__JobValuesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobValuesType(struct soap *soap, const char *tag, int id, struct wprt__JobValuesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobValuesType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobValuesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobValuesType ** SOAP_FMAC4 soap_get_PointerTowprt__JobValuesType(struct soap *soap, struct wprt__JobValuesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobValuesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobValuesType ** SOAP_FMAC4 soap_in_PointerTowprt__JobValuesType(struct soap *soap, const char *tag, struct wprt__JobValuesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobValuesType **)soap_malloc(soap, sizeof(struct wprt__JobValuesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobValuesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobValuesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobValuesType, sizeof(struct wprt__JobValuesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ComponentNameType(struct soap *soap, struct wprt__ComponentNameType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ComponentNameType))
		soap_serialize_wprt__ComponentNameType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ComponentNameType(struct soap *soap, struct wprt__ComponentNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ComponentNameType);
	if (soap_out_PointerTowprt__ComponentNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ComponentNameType(struct soap *soap, const char *tag, int id, struct wprt__ComponentNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ComponentNameType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ComponentNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ComponentNameType ** SOAP_FMAC4 soap_get_PointerTowprt__ComponentNameType(struct soap *soap, struct wprt__ComponentNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ComponentNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ComponentNameType ** SOAP_FMAC4 soap_in_PointerTowprt__ComponentNameType(struct soap *soap, const char *tag, struct wprt__ComponentNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ComponentNameType **)soap_malloc(soap, sizeof(struct wprt__ComponentNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ComponentNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ComponentNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ComponentNameType, sizeof(struct wprt__ComponentNameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ComponentGroupType(struct soap *soap, struct wprt__ComponentGroupType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ComponentGroupType))
		soap_serialize_wprt__ComponentGroupType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ComponentGroupType(struct soap *soap, struct wprt__ComponentGroupType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ComponentGroupType);
	if (soap_out_PointerTowprt__ComponentGroupType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ComponentGroupType(struct soap *soap, const char *tag, int id, struct wprt__ComponentGroupType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ComponentGroupType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ComponentGroupType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ComponentGroupType ** SOAP_FMAC4 soap_get_PointerTowprt__ComponentGroupType(struct soap *soap, struct wprt__ComponentGroupType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ComponentGroupType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ComponentGroupType ** SOAP_FMAC4 soap_in_PointerTowprt__ComponentGroupType(struct soap *soap, const char *tag, struct wprt__ComponentGroupType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ComponentGroupType **)soap_malloc(soap, sizeof(struct wprt__ComponentGroupType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ComponentGroupType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ComponentGroupType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ComponentGroupType, sizeof(struct wprt__ComponentGroupType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ConditionSeverityType(struct soap *soap, struct wprt__ConditionSeverityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ConditionSeverityType))
		soap_serialize_wprt__ConditionSeverityType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ConditionSeverityType(struct soap *soap, struct wprt__ConditionSeverityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ConditionSeverityType);
	if (soap_out_PointerTowprt__ConditionSeverityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ConditionSeverityType(struct soap *soap, const char *tag, int id, struct wprt__ConditionSeverityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ConditionSeverityType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ConditionSeverityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ConditionSeverityType ** SOAP_FMAC4 soap_get_PointerTowprt__ConditionSeverityType(struct soap *soap, struct wprt__ConditionSeverityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ConditionSeverityType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionSeverityType ** SOAP_FMAC4 soap_in_PointerTowprt__ConditionSeverityType(struct soap *soap, const char *tag, struct wprt__ConditionSeverityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ConditionSeverityType **)soap_malloc(soap, sizeof(struct wprt__ConditionSeverityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ConditionSeverityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ConditionSeverityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ConditionSeverityType, sizeof(struct wprt__ConditionSeverityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ConditionComponentType(struct soap *soap, struct wprt__ConditionComponentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ConditionComponentType))
		soap_serialize_wprt__ConditionComponentType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ConditionComponentType(struct soap *soap, struct wprt__ConditionComponentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ConditionComponentType);
	if (soap_out_PointerTowprt__ConditionComponentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ConditionComponentType(struct soap *soap, const char *tag, int id, struct wprt__ConditionComponentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ConditionComponentType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ConditionComponentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ConditionComponentType ** SOAP_FMAC4 soap_get_PointerTowprt__ConditionComponentType(struct soap *soap, struct wprt__ConditionComponentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ConditionComponentType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionComponentType ** SOAP_FMAC4 soap_in_PointerTowprt__ConditionComponentType(struct soap *soap, const char *tag, struct wprt__ConditionComponentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ConditionComponentType **)soap_malloc(soap, sizeof(struct wprt__ConditionComponentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ConditionComponentType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ConditionComponentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ConditionComponentType, sizeof(struct wprt__ConditionComponentType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ConditionNameType(struct soap *soap, struct wprt__ConditionNameType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ConditionNameType))
		soap_serialize_wprt__ConditionNameType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ConditionNameType(struct soap *soap, struct wprt__ConditionNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ConditionNameType);
	if (soap_out_PointerTowprt__ConditionNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ConditionNameType(struct soap *soap, const char *tag, int id, struct wprt__ConditionNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ConditionNameType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ConditionNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ConditionNameType ** SOAP_FMAC4 soap_get_PointerTowprt__ConditionNameType(struct soap *soap, struct wprt__ConditionNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ConditionNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionNameType ** SOAP_FMAC4 soap_in_PointerTowprt__ConditionNameType(struct soap *soap, const char *tag, struct wprt__ConditionNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ConditionNameType **)soap_malloc(soap, sizeof(struct wprt__ConditionNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ConditionNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ConditionNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ConditionNameType, sizeof(struct wprt__ConditionNameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ConditionHistoryEntryType(struct soap *soap, struct wprt__ConditionHistoryEntryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ConditionHistoryEntryType))
		soap_serialize_wprt__ConditionHistoryEntryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ConditionHistoryEntryType(struct soap *soap, struct wprt__ConditionHistoryEntryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ConditionHistoryEntryType);
	if (soap_out_PointerTowprt__ConditionHistoryEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ConditionHistoryEntryType(struct soap *soap, const char *tag, int id, struct wprt__ConditionHistoryEntryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ConditionHistoryEntryType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ConditionHistoryEntryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ConditionHistoryEntryType ** SOAP_FMAC4 soap_get_PointerTowprt__ConditionHistoryEntryType(struct soap *soap, struct wprt__ConditionHistoryEntryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ConditionHistoryEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionHistoryEntryType ** SOAP_FMAC4 soap_in_PointerTowprt__ConditionHistoryEntryType(struct soap *soap, const char *tag, struct wprt__ConditionHistoryEntryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ConditionHistoryEntryType **)soap_malloc(soap, sizeof(struct wprt__ConditionHistoryEntryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ConditionHistoryEntryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ConditionHistoryEntryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ConditionHistoryEntryType, sizeof(struct wprt__ConditionHistoryEntryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ConditionHistoryTableType(struct soap *soap, struct wprt__ConditionHistoryTableType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ConditionHistoryTableType))
		soap_serialize_wprt__ConditionHistoryTableType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ConditionHistoryTableType(struct soap *soap, struct wprt__ConditionHistoryTableType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ConditionHistoryTableType);
	if (soap_out_PointerTowprt__ConditionHistoryTableType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ConditionHistoryTableType(struct soap *soap, const char *tag, int id, struct wprt__ConditionHistoryTableType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ConditionHistoryTableType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ConditionHistoryTableType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ConditionHistoryTableType ** SOAP_FMAC4 soap_get_PointerTowprt__ConditionHistoryTableType(struct soap *soap, struct wprt__ConditionHistoryTableType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ConditionHistoryTableType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConditionHistoryTableType ** SOAP_FMAC4 soap_in_PointerTowprt__ConditionHistoryTableType(struct soap *soap, const char *tag, struct wprt__ConditionHistoryTableType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ConditionHistoryTableType **)soap_malloc(soap, sizeof(struct wprt__ConditionHistoryTableType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ConditionHistoryTableType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ConditionHistoryTableType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ConditionHistoryTableType, sizeof(struct wprt__ConditionHistoryTableType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ActiveConditionTableType(struct soap *soap, struct wprt__ActiveConditionTableType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ActiveConditionTableType))
		soap_serialize_wprt__ActiveConditionTableType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ActiveConditionTableType(struct soap *soap, struct wprt__ActiveConditionTableType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ActiveConditionTableType);
	if (soap_out_PointerTowprt__ActiveConditionTableType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ActiveConditionTableType(struct soap *soap, const char *tag, int id, struct wprt__ActiveConditionTableType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ActiveConditionTableType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ActiveConditionTableType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ActiveConditionTableType ** SOAP_FMAC4 soap_get_PointerTowprt__ActiveConditionTableType(struct soap *soap, struct wprt__ActiveConditionTableType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ActiveConditionTableType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ActiveConditionTableType ** SOAP_FMAC4 soap_in_PointerTowprt__ActiveConditionTableType(struct soap *soap, const char *tag, struct wprt__ActiveConditionTableType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ActiveConditionTableType **)soap_malloc(soap, sizeof(struct wprt__ActiveConditionTableType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ActiveConditionTableType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ActiveConditionTableType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ActiveConditionTableType, sizeof(struct wprt__ActiveConditionTableType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__OutputBinEntryType(struct soap *soap, struct wprt__OutputBinEntryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__OutputBinEntryType))
		soap_serialize_wprt__OutputBinEntryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__OutputBinEntryType(struct soap *soap, struct wprt__OutputBinEntryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__OutputBinEntryType);
	if (soap_out_PointerTowprt__OutputBinEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__OutputBinEntryType(struct soap *soap, const char *tag, int id, struct wprt__OutputBinEntryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__OutputBinEntryType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__OutputBinEntryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__OutputBinEntryType ** SOAP_FMAC4 soap_get_PointerTowprt__OutputBinEntryType(struct soap *soap, struct wprt__OutputBinEntryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__OutputBinEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__OutputBinEntryType ** SOAP_FMAC4 soap_in_PointerTowprt__OutputBinEntryType(struct soap *soap, const char *tag, struct wprt__OutputBinEntryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__OutputBinEntryType **)soap_malloc(soap, sizeof(struct wprt__OutputBinEntryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__OutputBinEntryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__OutputBinEntryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__OutputBinEntryType, sizeof(struct wprt__OutputBinEntryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__InputBinEntryType(struct soap *soap, struct wprt__InputBinEntryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__InputBinEntryType))
		soap_serialize_wprt__InputBinEntryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__InputBinEntryType(struct soap *soap, struct wprt__InputBinEntryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__InputBinEntryType);
	if (soap_out_PointerTowprt__InputBinEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__InputBinEntryType(struct soap *soap, const char *tag, int id, struct wprt__InputBinEntryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__InputBinEntryType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__InputBinEntryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__InputBinEntryType ** SOAP_FMAC4 soap_get_PointerTowprt__InputBinEntryType(struct soap *soap, struct wprt__InputBinEntryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__InputBinEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinEntryType ** SOAP_FMAC4 soap_in_PointerTowprt__InputBinEntryType(struct soap *soap, const char *tag, struct wprt__InputBinEntryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__InputBinEntryType **)soap_malloc(soap, sizeof(struct wprt__InputBinEntryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__InputBinEntryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__InputBinEntryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__InputBinEntryType, sizeof(struct wprt__InputBinEntryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ConsumableEntryType(struct soap *soap, struct wprt__ConsumableEntryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ConsumableEntryType))
		soap_serialize_wprt__ConsumableEntryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ConsumableEntryType(struct soap *soap, struct wprt__ConsumableEntryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ConsumableEntryType);
	if (soap_out_PointerTowprt__ConsumableEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ConsumableEntryType(struct soap *soap, const char *tag, int id, struct wprt__ConsumableEntryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ConsumableEntryType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ConsumableEntryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ConsumableEntryType ** SOAP_FMAC4 soap_get_PointerTowprt__ConsumableEntryType(struct soap *soap, struct wprt__ConsumableEntryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ConsumableEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConsumableEntryType ** SOAP_FMAC4 soap_in_PointerTowprt__ConsumableEntryType(struct soap *soap, const char *tag, struct wprt__ConsumableEntryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ConsumableEntryType **)soap_malloc(soap, sizeof(struct wprt__ConsumableEntryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ConsumableEntryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ConsumableEntryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ConsumableEntryType, sizeof(struct wprt__ConsumableEntryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__StorageEntryType(struct soap *soap, struct wprt__StorageEntryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__StorageEntryType))
		soap_serialize_wprt__StorageEntryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__StorageEntryType(struct soap *soap, struct wprt__StorageEntryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__StorageEntryType);
	if (soap_out_PointerTowprt__StorageEntryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__StorageEntryType(struct soap *soap, const char *tag, int id, struct wprt__StorageEntryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__StorageEntryType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__StorageEntryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__StorageEntryType ** SOAP_FMAC4 soap_get_PointerTowprt__StorageEntryType(struct soap *soap, struct wprt__StorageEntryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__StorageEntryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StorageEntryType ** SOAP_FMAC4 soap_in_PointerTowprt__StorageEntryType(struct soap *soap, const char *tag, struct wprt__StorageEntryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__StorageEntryType **)soap_malloc(soap, sizeof(struct wprt__StorageEntryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__StorageEntryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__StorageEntryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__StorageEntryType, sizeof(struct wprt__StorageEntryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__OutputBinsType(struct soap *soap, struct wprt__OutputBinsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__OutputBinsType))
		soap_serialize_wprt__OutputBinsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__OutputBinsType(struct soap *soap, struct wprt__OutputBinsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__OutputBinsType);
	if (soap_out_PointerTowprt__OutputBinsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__OutputBinsType(struct soap *soap, const char *tag, int id, struct wprt__OutputBinsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__OutputBinsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__OutputBinsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__OutputBinsType ** SOAP_FMAC4 soap_get_PointerTowprt__OutputBinsType(struct soap *soap, struct wprt__OutputBinsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__OutputBinsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__OutputBinsType ** SOAP_FMAC4 soap_in_PointerTowprt__OutputBinsType(struct soap *soap, const char *tag, struct wprt__OutputBinsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__OutputBinsType **)soap_malloc(soap, sizeof(struct wprt__OutputBinsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__OutputBinsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__OutputBinsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__OutputBinsType, sizeof(struct wprt__OutputBinsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__FinishingsType(struct soap *soap, struct wprt__FinishingsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__FinishingsType))
		soap_serialize_wprt__FinishingsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__FinishingsType(struct soap *soap, struct wprt__FinishingsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__FinishingsType);
	if (soap_out_PointerTowprt__FinishingsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__FinishingsType(struct soap *soap, const char *tag, int id, struct wprt__FinishingsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__FinishingsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__FinishingsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__FinishingsType ** SOAP_FMAC4 soap_get_PointerTowprt__FinishingsType(struct soap *soap, struct wprt__FinishingsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__FinishingsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__FinishingsType ** SOAP_FMAC4 soap_in_PointerTowprt__FinishingsType(struct soap *soap, const char *tag, struct wprt__FinishingsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__FinishingsType **)soap_malloc(soap, sizeof(struct wprt__FinishingsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__FinishingsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__FinishingsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__FinishingsType, sizeof(struct wprt__FinishingsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__InputBinsType(struct soap *soap, struct wprt__InputBinsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__InputBinsType))
		soap_serialize_wprt__InputBinsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__InputBinsType(struct soap *soap, struct wprt__InputBinsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__InputBinsType);
	if (soap_out_PointerTowprt__InputBinsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__InputBinsType(struct soap *soap, const char *tag, int id, struct wprt__InputBinsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__InputBinsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__InputBinsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__InputBinsType ** SOAP_FMAC4 soap_get_PointerTowprt__InputBinsType(struct soap *soap, struct wprt__InputBinsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__InputBinsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinsType ** SOAP_FMAC4 soap_in_PointerTowprt__InputBinsType(struct soap *soap, const char *tag, struct wprt__InputBinsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__InputBinsType **)soap_malloc(soap, sizeof(struct wprt__InputBinsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__InputBinsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__InputBinsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__InputBinsType, sizeof(struct wprt__InputBinsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ConsumablesType(struct soap *soap, struct wprt__ConsumablesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ConsumablesType))
		soap_serialize_wprt__ConsumablesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ConsumablesType(struct soap *soap, struct wprt__ConsumablesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ConsumablesType);
	if (soap_out_PointerTowprt__ConsumablesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ConsumablesType(struct soap *soap, const char *tag, int id, struct wprt__ConsumablesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ConsumablesType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ConsumablesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ConsumablesType ** SOAP_FMAC4 soap_get_PointerTowprt__ConsumablesType(struct soap *soap, struct wprt__ConsumablesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ConsumablesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConsumablesType ** SOAP_FMAC4 soap_in_PointerTowprt__ConsumablesType(struct soap *soap, const char *tag, struct wprt__ConsumablesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ConsumablesType **)soap_malloc(soap, sizeof(struct wprt__ConsumablesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ConsumablesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ConsumablesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ConsumablesType, sizeof(struct wprt__ConsumablesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__StorageBaseType(struct soap *soap, struct wprt__StorageBaseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__StorageBaseType))
		soap_serialize_wprt__StorageBaseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__StorageBaseType(struct soap *soap, struct wprt__StorageBaseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__StorageBaseType);
	if (soap_out_PointerTowprt__StorageBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__StorageBaseType(struct soap *soap, const char *tag, int id, struct wprt__StorageBaseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__StorageBaseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__StorageBaseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__StorageBaseType ** SOAP_FMAC4 soap_get_PointerTowprt__StorageBaseType(struct soap *soap, struct wprt__StorageBaseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__StorageBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StorageBaseType ** SOAP_FMAC4 soap_in_PointerTowprt__StorageBaseType(struct soap *soap, const char *tag, struct wprt__StorageBaseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__StorageBaseType **)soap_malloc(soap, sizeof(struct wprt__StorageBaseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__StorageBaseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__StorageBaseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__StorageBaseType, sizeof(struct wprt__StorageBaseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__LocalizedStringType(struct soap *soap, struct wprt__LocalizedStringType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__LocalizedStringType))
		soap_serialize_wprt__LocalizedStringType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__LocalizedStringType(struct soap *soap, struct wprt__LocalizedStringType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__LocalizedStringType);
	if (soap_out_PointerTowprt__LocalizedStringType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__LocalizedStringType(struct soap *soap, const char *tag, int id, struct wprt__LocalizedStringType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__LocalizedStringType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__LocalizedStringType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__LocalizedStringType ** SOAP_FMAC4 soap_get_PointerTowprt__LocalizedStringType(struct soap *soap, struct wprt__LocalizedStringType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__LocalizedStringType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__LocalizedStringType ** SOAP_FMAC4 soap_in_PointerTowprt__LocalizedStringType(struct soap *soap, const char *tag, struct wprt__LocalizedStringType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__LocalizedStringType **)soap_malloc(soap, sizeof(struct wprt__LocalizedStringType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__LocalizedStringType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__LocalizedStringType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__LocalizedStringType, sizeof(struct wprt__LocalizedStringType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DeviceIdType(struct soap *soap, struct wprt__DeviceIdType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DeviceIdType))
		soap_serialize_wprt__DeviceIdType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DeviceIdType(struct soap *soap, struct wprt__DeviceIdType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DeviceIdType);
	if (soap_out_PointerTowprt__DeviceIdType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DeviceIdType(struct soap *soap, const char *tag, int id, struct wprt__DeviceIdType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DeviceIdType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DeviceIdType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DeviceIdType ** SOAP_FMAC4 soap_get_PointerTowprt__DeviceIdType(struct soap *soap, struct wprt__DeviceIdType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DeviceIdType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DeviceIdType ** SOAP_FMAC4 soap_in_PointerTowprt__DeviceIdType(struct soap *soap, const char *tag, struct wprt__DeviceIdType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DeviceIdType **)soap_malloc(soap, sizeof(struct wprt__DeviceIdType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DeviceIdType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DeviceIdType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DeviceIdType, sizeof(struct wprt__DeviceIdType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterStatusType(struct soap *soap, struct wprt__PrinterStatusType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterStatusType))
		soap_serialize_wprt__PrinterStatusType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterStatusType(struct soap *soap, struct wprt__PrinterStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterStatusType);
	if (soap_out_PointerTowprt__PrinterStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterStatusType(struct soap *soap, const char *tag, int id, struct wprt__PrinterStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterStatusType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterStatusType(struct soap *soap, struct wprt__PrinterStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterStatusType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStatusType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterStatusType(struct soap *soap, const char *tag, struct wprt__PrinterStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterStatusType **)soap_malloc(soap, sizeof(struct wprt__PrinterStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterStatusType, sizeof(struct wprt__PrinterStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobElementDataType(struct soap *soap, struct wprt__JobElementDataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobElementDataType))
		soap_serialize_wprt__JobElementDataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobElementDataType(struct soap *soap, struct wprt__JobElementDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobElementDataType);
	if (soap_out_PointerTowprt__JobElementDataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobElementDataType(struct soap *soap, const char *tag, int id, struct wprt__JobElementDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobElementDataType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobElementDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobElementDataType ** SOAP_FMAC4 soap_get_PointerTowprt__JobElementDataType(struct soap *soap, struct wprt__JobElementDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobElementDataType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobElementDataType ** SOAP_FMAC4 soap_in_PointerTowprt__JobElementDataType(struct soap *soap, const char *tag, struct wprt__JobElementDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobElementDataType **)soap_malloc(soap, sizeof(struct wprt__JobElementDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobElementDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobElementDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobElementDataType, sizeof(struct wprt__JobElementDataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__QNameExtType(struct soap *soap, struct wprt__QNameExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__QNameExtType))
		soap_serialize_wprt__QNameExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__QNameExtType(struct soap *soap, struct wprt__QNameExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__QNameExtType);
	if (soap_out_PointerTowprt__QNameExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__QNameExtType(struct soap *soap, const char *tag, int id, struct wprt__QNameExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__QNameExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__QNameExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__QNameExtType ** SOAP_FMAC4 soap_get_PointerTowprt__QNameExtType(struct soap *soap, struct wprt__QNameExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__QNameExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__QNameExtType ** SOAP_FMAC4 soap_in_PointerTowprt__QNameExtType(struct soap *soap, const char *tag, struct wprt__QNameExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__QNameExtType **)soap_malloc(soap, sizeof(struct wprt__QNameExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__QNameExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__QNameExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__QNameExtType, sizeof(struct wprt__QNameExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__HolePunchPatternType(struct soap *soap, struct wprt__HolePunchPatternType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__HolePunchPatternType))
		soap_serialize_wprt__HolePunchPatternType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__HolePunchPatternType(struct soap *soap, struct wprt__HolePunchPatternType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__HolePunchPatternType);
	if (soap_out_PointerTowprt__HolePunchPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__HolePunchPatternType(struct soap *soap, const char *tag, int id, struct wprt__HolePunchPatternType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__HolePunchPatternType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__HolePunchPatternType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__HolePunchPatternType ** SOAP_FMAC4 soap_get_PointerTowprt__HolePunchPatternType(struct soap *soap, struct wprt__HolePunchPatternType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__HolePunchPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__HolePunchPatternType ** SOAP_FMAC4 soap_in_PointerTowprt__HolePunchPatternType(struct soap *soap, const char *tag, struct wprt__HolePunchPatternType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__HolePunchPatternType **)soap_malloc(soap, sizeof(struct wprt__HolePunchPatternType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__HolePunchPatternType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__HolePunchPatternType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__HolePunchPatternType, sizeof(struct wprt__HolePunchPatternType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__HolePunchEdgeType(struct soap *soap, struct wprt__HolePunchEdgeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__HolePunchEdgeType))
		soap_serialize_wprt__HolePunchEdgeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__HolePunchEdgeType(struct soap *soap, struct wprt__HolePunchEdgeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__HolePunchEdgeType);
	if (soap_out_PointerTowprt__HolePunchEdgeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__HolePunchEdgeType(struct soap *soap, const char *tag, int id, struct wprt__HolePunchEdgeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__HolePunchEdgeType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__HolePunchEdgeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__HolePunchEdgeType ** SOAP_FMAC4 soap_get_PointerTowprt__HolePunchEdgeType(struct soap *soap, struct wprt__HolePunchEdgeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__HolePunchEdgeType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__HolePunchEdgeType ** SOAP_FMAC4 soap_in_PointerTowprt__HolePunchEdgeType(struct soap *soap, const char *tag, struct wprt__HolePunchEdgeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__HolePunchEdgeType **)soap_malloc(soap, sizeof(struct wprt__HolePunchEdgeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__HolePunchEdgeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__HolePunchEdgeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__HolePunchEdgeType, sizeof(struct wprt__HolePunchEdgeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__StapleAngleType(struct soap *soap, struct wprt__StapleAngleType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__StapleAngleType))
		soap_serialize_wprt__StapleAngleType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__StapleAngleType(struct soap *soap, struct wprt__StapleAngleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__StapleAngleType);
	if (soap_out_PointerTowprt__StapleAngleType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__StapleAngleType(struct soap *soap, const char *tag, int id, struct wprt__StapleAngleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__StapleAngleType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__StapleAngleType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__StapleAngleType ** SOAP_FMAC4 soap_get_PointerTowprt__StapleAngleType(struct soap *soap, struct wprt__StapleAngleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__StapleAngleType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StapleAngleType ** SOAP_FMAC4 soap_in_PointerTowprt__StapleAngleType(struct soap *soap, const char *tag, struct wprt__StapleAngleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__StapleAngleType **)soap_malloc(soap, sizeof(struct wprt__StapleAngleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__StapleAngleType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__StapleAngleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__StapleAngleType, sizeof(struct wprt__StapleAngleType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__StapleLocationType(struct soap *soap, struct wprt__StapleLocationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__StapleLocationType))
		soap_serialize_wprt__StapleLocationType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__StapleLocationType(struct soap *soap, struct wprt__StapleLocationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__StapleLocationType);
	if (soap_out_PointerTowprt__StapleLocationType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__StapleLocationType(struct soap *soap, const char *tag, int id, struct wprt__StapleLocationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__StapleLocationType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__StapleLocationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__StapleLocationType ** SOAP_FMAC4 soap_get_PointerTowprt__StapleLocationType(struct soap *soap, struct wprt__StapleLocationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__StapleLocationType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StapleLocationType ** SOAP_FMAC4 soap_in_PointerTowprt__StapleLocationType(struct soap *soap, const char *tag, struct wprt__StapleLocationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__StapleLocationType **)soap_malloc(soap, sizeof(struct wprt__StapleLocationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__StapleLocationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__StapleLocationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__StapleLocationType, sizeof(struct wprt__StapleLocationType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__HolePunchDetailsType(struct soap *soap, struct wprt__HolePunchDetailsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__HolePunchDetailsType))
		soap_serialize_wprt__HolePunchDetailsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__HolePunchDetailsType(struct soap *soap, struct wprt__HolePunchDetailsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__HolePunchDetailsType);
	if (soap_out_PointerTowprt__HolePunchDetailsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__HolePunchDetailsType(struct soap *soap, const char *tag, int id, struct wprt__HolePunchDetailsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__HolePunchDetailsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__HolePunchDetailsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__HolePunchDetailsType ** SOAP_FMAC4 soap_get_PointerTowprt__HolePunchDetailsType(struct soap *soap, struct wprt__HolePunchDetailsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__HolePunchDetailsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__HolePunchDetailsType ** SOAP_FMAC4 soap_in_PointerTowprt__HolePunchDetailsType(struct soap *soap, const char *tag, struct wprt__HolePunchDetailsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__HolePunchDetailsType **)soap_malloc(soap, sizeof(struct wprt__HolePunchDetailsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__HolePunchDetailsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__HolePunchDetailsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__HolePunchDetailsType, sizeof(struct wprt__HolePunchDetailsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__StapleDetailsType(struct soap *soap, struct wprt__StapleDetailsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__StapleDetailsType))
		soap_serialize_wprt__StapleDetailsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__StapleDetailsType(struct soap *soap, struct wprt__StapleDetailsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__StapleDetailsType);
	if (soap_out_PointerTowprt__StapleDetailsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__StapleDetailsType(struct soap *soap, const char *tag, int id, struct wprt__StapleDetailsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__StapleDetailsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__StapleDetailsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__StapleDetailsType ** SOAP_FMAC4 soap_get_PointerTowprt__StapleDetailsType(struct soap *soap, struct wprt__StapleDetailsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__StapleDetailsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StapleDetailsType ** SOAP_FMAC4 soap_in_PointerTowprt__StapleDetailsType(struct soap *soap, const char *tag, struct wprt__StapleDetailsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__StapleDetailsType **)soap_malloc(soap, sizeof(struct wprt__StapleDetailsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__StapleDetailsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__StapleDetailsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__StapleDetailsType, sizeof(struct wprt__StapleDetailsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__BooleanExtType(struct soap *soap, struct wprt__BooleanExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__BooleanExtType))
		soap_serialize_wprt__BooleanExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__BooleanExtType(struct soap *soap, struct wprt__BooleanExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__BooleanExtType);
	if (soap_out_PointerTowprt__BooleanExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__BooleanExtType(struct soap *soap, const char *tag, int id, struct wprt__BooleanExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__BooleanExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__BooleanExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__BooleanExtType ** SOAP_FMAC4 soap_get_PointerTowprt__BooleanExtType(struct soap *soap, struct wprt__BooleanExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__BooleanExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__BooleanExtType ** SOAP_FMAC4 soap_in_PointerTowprt__BooleanExtType(struct soap *soap, const char *tag, struct wprt__BooleanExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__BooleanExtType **)soap_malloc(soap, sizeof(struct wprt__BooleanExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__BooleanExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__BooleanExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__BooleanExtType, sizeof(struct wprt__BooleanExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobPriorityType(struct soap *soap, struct wprt__JobPriorityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobPriorityType))
		soap_serialize_wprt__JobPriorityType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobPriorityType(struct soap *soap, struct wprt__JobPriorityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobPriorityType);
	if (soap_out_PointerTowprt__JobPriorityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobPriorityType(struct soap *soap, const char *tag, int id, struct wprt__JobPriorityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobPriorityType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobPriorityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobPriorityType ** SOAP_FMAC4 soap_get_PointerTowprt__JobPriorityType(struct soap *soap, struct wprt__JobPriorityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobPriorityType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobPriorityType ** SOAP_FMAC4 soap_in_PointerTowprt__JobPriorityType(struct soap *soap, const char *tag, struct wprt__JobPriorityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobPriorityType **)soap_malloc(soap, sizeof(struct wprt__JobPriorityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobPriorityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobPriorityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobPriorityType, sizeof(struct wprt__JobPriorityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobFinishingsType(struct soap *soap, struct wprt__JobFinishingsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobFinishingsType))
		soap_serialize_wprt__JobFinishingsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobFinishingsType(struct soap *soap, struct wprt__JobFinishingsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobFinishingsType);
	if (soap_out_PointerTowprt__JobFinishingsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobFinishingsType(struct soap *soap, const char *tag, int id, struct wprt__JobFinishingsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobFinishingsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobFinishingsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobFinishingsType ** SOAP_FMAC4 soap_get_PointerTowprt__JobFinishingsType(struct soap *soap, struct wprt__JobFinishingsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobFinishingsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobFinishingsType ** SOAP_FMAC4 soap_in_PointerTowprt__JobFinishingsType(struct soap *soap, const char *tag, struct wprt__JobFinishingsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobFinishingsType **)soap_malloc(soap, sizeof(struct wprt__JobFinishingsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobFinishingsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobFinishingsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobFinishingsType, sizeof(struct wprt__JobFinishingsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobCopiesType(struct soap *soap, struct wprt__JobCopiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobCopiesType))
		soap_serialize_wprt__JobCopiesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobCopiesType(struct soap *soap, struct wprt__JobCopiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobCopiesType);
	if (soap_out_PointerTowprt__JobCopiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobCopiesType(struct soap *soap, const char *tag, int id, struct wprt__JobCopiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobCopiesType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobCopiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobCopiesType ** SOAP_FMAC4 soap_get_PointerTowprt__JobCopiesType(struct soap *soap, struct wprt__JobCopiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobCopiesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobCopiesType ** SOAP_FMAC4 soap_in_PointerTowprt__JobCopiesType(struct soap *soap, const char *tag, struct wprt__JobCopiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobCopiesType **)soap_malloc(soap, sizeof(struct wprt__JobCopiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobCopiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobCopiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobCopiesType, sizeof(struct wprt__JobCopiesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobProcessingType(struct soap *soap, struct wprt__JobProcessingType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobProcessingType))
		soap_serialize_wprt__JobProcessingType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobProcessingType(struct soap *soap, struct wprt__JobProcessingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobProcessingType);
	if (soap_out_PointerTowprt__JobProcessingType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobProcessingType(struct soap *soap, const char *tag, int id, struct wprt__JobProcessingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobProcessingType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobProcessingType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobProcessingType ** SOAP_FMAC4 soap_get_PointerTowprt__JobProcessingType(struct soap *soap, struct wprt__JobProcessingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobProcessingType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobProcessingType ** SOAP_FMAC4 soap_in_PointerTowprt__JobProcessingType(struct soap *soap, const char *tag, struct wprt__JobProcessingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobProcessingType **)soap_malloc(soap, sizeof(struct wprt__JobProcessingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobProcessingType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobProcessingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobProcessingType, sizeof(struct wprt__JobProcessingType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobDescriptionType(struct soap *soap, struct wprt__JobDescriptionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobDescriptionType))
		soap_serialize_wprt__JobDescriptionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobDescriptionType(struct soap *soap, struct wprt__JobDescriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobDescriptionType);
	if (soap_out_PointerTowprt__JobDescriptionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobDescriptionType(struct soap *soap, const char *tag, int id, struct wprt__JobDescriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobDescriptionType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobDescriptionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobDescriptionType ** SOAP_FMAC4 soap_get_PointerTowprt__JobDescriptionType(struct soap *soap, struct wprt__JobDescriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobDescriptionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobDescriptionType ** SOAP_FMAC4 soap_in_PointerTowprt__JobDescriptionType(struct soap *soap, const char *tag, struct wprt__JobDescriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobDescriptionType **)soap_malloc(soap, sizeof(struct wprt__JobDescriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobDescriptionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobDescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobDescriptionType, sizeof(struct wprt__JobDescriptionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobStateReasonType(struct soap *soap, struct wprt__JobStateReasonType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobStateReasonType))
		soap_serialize_wprt__JobStateReasonType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobStateReasonType(struct soap *soap, struct wprt__JobStateReasonType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobStateReasonType);
	if (soap_out_PointerTowprt__JobStateReasonType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobStateReasonType(struct soap *soap, const char *tag, int id, struct wprt__JobStateReasonType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobStateReasonType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobStateReasonType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobStateReasonType ** SOAP_FMAC4 soap_get_PointerTowprt__JobStateReasonType(struct soap *soap, struct wprt__JobStateReasonType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobStateReasonType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStateReasonType ** SOAP_FMAC4 soap_in_PointerTowprt__JobStateReasonType(struct soap *soap, const char *tag, struct wprt__JobStateReasonType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobStateReasonType **)soap_malloc(soap, sizeof(struct wprt__JobStateReasonType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobStateReasonType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobStateReasonType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobStateReasonType, sizeof(struct wprt__JobStateReasonType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobSummaryType(struct soap *soap, struct wprt__JobSummaryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobSummaryType))
		soap_serialize_wprt__JobSummaryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobSummaryType(struct soap *soap, struct wprt__JobSummaryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobSummaryType);
	if (soap_out_PointerTowprt__JobSummaryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobSummaryType(struct soap *soap, const char *tag, int id, struct wprt__JobSummaryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobSummaryType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobSummaryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobSummaryType ** SOAP_FMAC4 soap_get_PointerTowprt__JobSummaryType(struct soap *soap, struct wprt__JobSummaryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobSummaryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobSummaryType ** SOAP_FMAC4 soap_in_PointerTowprt__JobSummaryType(struct soap *soap, const char *tag, struct wprt__JobSummaryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobSummaryType **)soap_malloc(soap, sizeof(struct wprt__JobSummaryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobSummaryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobSummaryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobSummaryType, sizeof(struct wprt__JobSummaryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobType(struct soap *soap, struct wprt__JobType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobType))
		soap_serialize_wprt__JobType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobType(struct soap *soap, struct wprt__JobType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobType);
	if (soap_out_PointerTowprt__JobType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobType(struct soap *soap, const char *tag, int id, struct wprt__JobType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobType ** SOAP_FMAC4 soap_get_PointerTowprt__JobType(struct soap *soap, struct wprt__JobType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobType ** SOAP_FMAC4 soap_in_PointerTowprt__JobType(struct soap *soap, const char *tag, struct wprt__JobType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobType **)soap_malloc(soap, sizeof(struct wprt__JobType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobType, sizeof(struct wprt__JobType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DocumentsType(struct soap *soap, struct wprt__DocumentsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DocumentsType))
		soap_serialize_wprt__DocumentsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DocumentsType(struct soap *soap, struct wprt__DocumentsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DocumentsType);
	if (soap_out_PointerTowprt__DocumentsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DocumentsType(struct soap *soap, const char *tag, int id, struct wprt__DocumentsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DocumentsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DocumentsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DocumentsType ** SOAP_FMAC4 soap_get_PointerTowprt__DocumentsType(struct soap *soap, struct wprt__DocumentsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DocumentsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentsType ** SOAP_FMAC4 soap_in_PointerTowprt__DocumentsType(struct soap *soap, const char *tag, struct wprt__DocumentsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DocumentsType **)soap_malloc(soap, sizeof(struct wprt__DocumentsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DocumentsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DocumentsType, sizeof(struct wprt__DocumentsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ListOfJobsType(struct soap *soap, struct wprt__ListOfJobsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ListOfJobsType))
		soap_serialize_wprt__ListOfJobsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ListOfJobsType(struct soap *soap, struct wprt__ListOfJobsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ListOfJobsType);
	if (soap_out_PointerTowprt__ListOfJobsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ListOfJobsType(struct soap *soap, const char *tag, int id, struct wprt__ListOfJobsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ListOfJobsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ListOfJobsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ListOfJobsType ** SOAP_FMAC4 soap_get_PointerTowprt__ListOfJobsType(struct soap *soap, struct wprt__ListOfJobsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ListOfJobsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ListOfJobsType ** SOAP_FMAC4 soap_in_PointerTowprt__ListOfJobsType(struct soap *soap, const char *tag, struct wprt__ListOfJobsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ListOfJobsType **)soap_malloc(soap, sizeof(struct wprt__ListOfJobsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ListOfJobsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ListOfJobsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ListOfJobsType, sizeof(struct wprt__ListOfJobsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__NUpDirectionType(struct soap *soap, struct wprt__NUpDirectionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__NUpDirectionType))
		soap_serialize_wprt__NUpDirectionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__NUpDirectionType(struct soap *soap, struct wprt__NUpDirectionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__NUpDirectionType);
	if (soap_out_PointerTowprt__NUpDirectionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__NUpDirectionType(struct soap *soap, const char *tag, int id, struct wprt__NUpDirectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__NUpDirectionType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__NUpDirectionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__NUpDirectionType ** SOAP_FMAC4 soap_get_PointerTowprt__NUpDirectionType(struct soap *soap, struct wprt__NUpDirectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__NUpDirectionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__NUpDirectionType ** SOAP_FMAC4 soap_in_PointerTowprt__NUpDirectionType(struct soap *soap, const char *tag, struct wprt__NUpDirectionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__NUpDirectionType **)soap_malloc(soap, sizeof(struct wprt__NUpDirectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__NUpDirectionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__NUpDirectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__NUpDirectionType, sizeof(struct wprt__NUpDirectionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__NUpPagesPerSheetType(struct soap *soap, struct wprt__NUpPagesPerSheetType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__NUpPagesPerSheetType))
		soap_serialize_wprt__NUpPagesPerSheetType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__NUpPagesPerSheetType(struct soap *soap, struct wprt__NUpPagesPerSheetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__NUpPagesPerSheetType);
	if (soap_out_PointerTowprt__NUpPagesPerSheetType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__NUpPagesPerSheetType(struct soap *soap, const char *tag, int id, struct wprt__NUpPagesPerSheetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__NUpPagesPerSheetType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__NUpPagesPerSheetType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__NUpPagesPerSheetType ** SOAP_FMAC4 soap_get_PointerTowprt__NUpPagesPerSheetType(struct soap *soap, struct wprt__NUpPagesPerSheetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__NUpPagesPerSheetType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__NUpPagesPerSheetType ** SOAP_FMAC4 soap_in_PointerTowprt__NUpPagesPerSheetType(struct soap *soap, const char *tag, struct wprt__NUpPagesPerSheetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__NUpPagesPerSheetType **)soap_malloc(soap, sizeof(struct wprt__NUpPagesPerSheetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__NUpPagesPerSheetType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__NUpPagesPerSheetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__NUpPagesPerSheetType, sizeof(struct wprt__NUpPagesPerSheetType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__SidesType(struct soap *soap, struct wprt__SidesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__SidesType))
		soap_serialize_wprt__SidesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__SidesType(struct soap *soap, struct wprt__SidesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__SidesType);
	if (soap_out_PointerTowprt__SidesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__SidesType(struct soap *soap, const char *tag, int id, struct wprt__SidesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__SidesType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__SidesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__SidesType ** SOAP_FMAC4 soap_get_PointerTowprt__SidesType(struct soap *soap, struct wprt__SidesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__SidesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__SidesType ** SOAP_FMAC4 soap_in_PointerTowprt__SidesType(struct soap *soap, const char *tag, struct wprt__SidesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__SidesType **)soap_malloc(soap, sizeof(struct wprt__SidesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__SidesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__SidesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__SidesType, sizeof(struct wprt__SidesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrintQualityType(struct soap *soap, struct wprt__PrintQualityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrintQualityType))
		soap_serialize_wprt__PrintQualityType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrintQualityType(struct soap *soap, struct wprt__PrintQualityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrintQualityType);
	if (soap_out_PointerTowprt__PrintQualityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrintQualityType(struct soap *soap, const char *tag, int id, struct wprt__PrintQualityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrintQualityType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrintQualityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrintQualityType ** SOAP_FMAC4 soap_get_PointerTowprt__PrintQualityType(struct soap *soap, struct wprt__PrintQualityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrintQualityType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrintQualityType ** SOAP_FMAC4 soap_in_PointerTowprt__PrintQualityType(struct soap *soap, const char *tag, struct wprt__PrintQualityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrintQualityType **)soap_malloc(soap, sizeof(struct wprt__PrintQualityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrintQualityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrintQualityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrintQualityType, sizeof(struct wprt__PrintQualityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ResolutionType(struct soap *soap, struct wprt__ResolutionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ResolutionType))
		soap_serialize_wprt__ResolutionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ResolutionType(struct soap *soap, struct wprt__ResolutionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ResolutionType);
	if (soap_out_PointerTowprt__ResolutionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ResolutionType(struct soap *soap, const char *tag, int id, struct wprt__ResolutionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ResolutionType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ResolutionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ResolutionType ** SOAP_FMAC4 soap_get_PointerTowprt__ResolutionType(struct soap *soap, struct wprt__ResolutionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ResolutionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ResolutionType ** SOAP_FMAC4 soap_in_PointerTowprt__ResolutionType(struct soap *soap, const char *tag, struct wprt__ResolutionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ResolutionType **)soap_malloc(soap, sizeof(struct wprt__ResolutionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ResolutionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ResolutionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ResolutionType, sizeof(struct wprt__ResolutionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__OrientationType(struct soap *soap, struct wprt__OrientationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__OrientationType))
		soap_serialize_wprt__OrientationType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__OrientationType(struct soap *soap, struct wprt__OrientationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__OrientationType);
	if (soap_out_PointerTowprt__OrientationType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__OrientationType(struct soap *soap, const char *tag, int id, struct wprt__OrientationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__OrientationType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__OrientationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__OrientationType ** SOAP_FMAC4 soap_get_PointerTowprt__OrientationType(struct soap *soap, struct wprt__OrientationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__OrientationType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__OrientationType ** SOAP_FMAC4 soap_in_PointerTowprt__OrientationType(struct soap *soap, const char *tag, struct wprt__OrientationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__OrientationType **)soap_malloc(soap, sizeof(struct wprt__OrientationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__OrientationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__OrientationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__OrientationType, sizeof(struct wprt__OrientationType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__NumberUpType(struct soap *soap, struct wprt__NumberUpType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__NumberUpType))
		soap_serialize_wprt__NumberUpType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__NumberUpType(struct soap *soap, struct wprt__NumberUpType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__NumberUpType);
	if (soap_out_PointerTowprt__NumberUpType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__NumberUpType(struct soap *soap, const char *tag, int id, struct wprt__NumberUpType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__NumberUpType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__NumberUpType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__NumberUpType ** SOAP_FMAC4 soap_get_PointerTowprt__NumberUpType(struct soap *soap, struct wprt__NumberUpType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__NumberUpType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__NumberUpType ** SOAP_FMAC4 soap_in_PointerTowprt__NumberUpType(struct soap *soap, const char *tag, struct wprt__NumberUpType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__NumberUpType **)soap_malloc(soap, sizeof(struct wprt__NumberUpType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__NumberUpType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__NumberUpType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__NumberUpType, sizeof(struct wprt__NumberUpType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__MediaColorType(struct soap *soap, struct wprt__MediaColorType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__MediaColorType))
		soap_serialize_wprt__MediaColorType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__MediaColorType(struct soap *soap, struct wprt__MediaColorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__MediaColorType);
	if (soap_out_PointerTowprt__MediaColorType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__MediaColorType(struct soap *soap, const char *tag, int id, struct wprt__MediaColorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__MediaColorType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__MediaColorType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__MediaColorType ** SOAP_FMAC4 soap_get_PointerTowprt__MediaColorType(struct soap *soap, struct wprt__MediaColorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__MediaColorType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__MediaColorType ** SOAP_FMAC4 soap_in_PointerTowprt__MediaColorType(struct soap *soap, const char *tag, struct wprt__MediaColorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__MediaColorType **)soap_malloc(soap, sizeof(struct wprt__MediaColorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__MediaColorType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__MediaColorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__MediaColorType, sizeof(struct wprt__MediaColorType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__MediaTypeBaseType(struct soap *soap, struct wprt__MediaTypeBaseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__MediaTypeBaseType))
		soap_serialize_wprt__MediaTypeBaseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__MediaTypeBaseType(struct soap *soap, struct wprt__MediaTypeBaseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__MediaTypeBaseType);
	if (soap_out_PointerTowprt__MediaTypeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__MediaTypeBaseType(struct soap *soap, const char *tag, int id, struct wprt__MediaTypeBaseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__MediaTypeBaseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__MediaTypeBaseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__MediaTypeBaseType ** SOAP_FMAC4 soap_get_PointerTowprt__MediaTypeBaseType(struct soap *soap, struct wprt__MediaTypeBaseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__MediaTypeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__MediaTypeBaseType ** SOAP_FMAC4 soap_in_PointerTowprt__MediaTypeBaseType(struct soap *soap, const char *tag, struct wprt__MediaTypeBaseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__MediaTypeBaseType **)soap_malloc(soap, sizeof(struct wprt__MediaTypeBaseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__MediaTypeBaseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__MediaTypeBaseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__MediaTypeBaseType, sizeof(struct wprt__MediaTypeBaseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__MediaSizeNameType(struct soap *soap, struct wprt__MediaSizeNameType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__MediaSizeNameType))
		soap_serialize_wprt__MediaSizeNameType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__MediaSizeNameType(struct soap *soap, struct wprt__MediaSizeNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__MediaSizeNameType);
	if (soap_out_PointerTowprt__MediaSizeNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__MediaSizeNameType(struct soap *soap, const char *tag, int id, struct wprt__MediaSizeNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__MediaSizeNameType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__MediaSizeNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__MediaSizeNameType ** SOAP_FMAC4 soap_get_PointerTowprt__MediaSizeNameType(struct soap *soap, struct wprt__MediaSizeNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__MediaSizeNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__MediaSizeNameType ** SOAP_FMAC4 soap_in_PointerTowprt__MediaSizeNameType(struct soap *soap, const char *tag, struct wprt__MediaSizeNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__MediaSizeNameType **)soap_malloc(soap, sizeof(struct wprt__MediaSizeNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__MediaSizeNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__MediaSizeNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__MediaSizeNameType, sizeof(struct wprt__MediaSizeNameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DocumentFormatType(struct soap *soap, struct wprt__DocumentFormatType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DocumentFormatType))
		soap_serialize_wprt__DocumentFormatType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DocumentFormatType(struct soap *soap, struct wprt__DocumentFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DocumentFormatType);
	if (soap_out_PointerTowprt__DocumentFormatType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DocumentFormatType(struct soap *soap, const char *tag, int id, struct wprt__DocumentFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DocumentFormatType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DocumentFormatType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DocumentFormatType ** SOAP_FMAC4 soap_get_PointerTowprt__DocumentFormatType(struct soap *soap, struct wprt__DocumentFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DocumentFormatType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentFormatType ** SOAP_FMAC4 soap_in_PointerTowprt__DocumentFormatType(struct soap *soap, const char *tag, struct wprt__DocumentFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DocumentFormatType **)soap_malloc(soap, sizeof(struct wprt__DocumentFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DocumentFormatType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DocumentFormatType, sizeof(struct wprt__DocumentFormatType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__CompressionType(struct soap *soap, struct wprt__CompressionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__CompressionType))
		soap_serialize_wprt__CompressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__CompressionType(struct soap *soap, struct wprt__CompressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__CompressionType);
	if (soap_out_PointerTowprt__CompressionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__CompressionType(struct soap *soap, const char *tag, int id, struct wprt__CompressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__CompressionType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__CompressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__CompressionType ** SOAP_FMAC4 soap_get_PointerTowprt__CompressionType(struct soap *soap, struct wprt__CompressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__CompressionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CompressionType ** SOAP_FMAC4 soap_in_PointerTowprt__CompressionType(struct soap *soap, const char *tag, struct wprt__CompressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__CompressionType **)soap_malloc(soap, sizeof(struct wprt__CompressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__CompressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__CompressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__CompressionType, sizeof(struct wprt__CompressionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DocumentType(struct soap *soap, struct wprt__DocumentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DocumentType))
		soap_serialize_wprt__DocumentType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DocumentType(struct soap *soap, struct wprt__DocumentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DocumentType);
	if (soap_out_PointerTowprt__DocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DocumentType(struct soap *soap, const char *tag, int id, struct wprt__DocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DocumentType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DocumentType ** SOAP_FMAC4 soap_get_PointerTowprt__DocumentType(struct soap *soap, struct wprt__DocumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DocumentType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentType ** SOAP_FMAC4 soap_in_PointerTowprt__DocumentType(struct soap *soap, const char *tag, struct wprt__DocumentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DocumentType **)soap_malloc(soap, sizeof(struct wprt__DocumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DocumentType, sizeof(struct wprt__DocumentType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__CapacityBaseType(struct soap *soap, struct wprt__CapacityBaseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__CapacityBaseType))
		soap_serialize_wprt__CapacityBaseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__CapacityBaseType(struct soap *soap, struct wprt__CapacityBaseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__CapacityBaseType);
	if (soap_out_PointerTowprt__CapacityBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__CapacityBaseType(struct soap *soap, const char *tag, int id, struct wprt__CapacityBaseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__CapacityBaseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__CapacityBaseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__CapacityBaseType ** SOAP_FMAC4 soap_get_PointerTowprt__CapacityBaseType(struct soap *soap, struct wprt__CapacityBaseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__CapacityBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__CapacityBaseType ** SOAP_FMAC4 soap_in_PointerTowprt__CapacityBaseType(struct soap *soap, const char *tag, struct wprt__CapacityBaseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__CapacityBaseType **)soap_malloc(soap, sizeof(struct wprt__CapacityBaseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__CapacityBaseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__CapacityBaseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__CapacityBaseType, sizeof(struct wprt__CapacityBaseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__InputBinMediaColorType(struct soap *soap, struct wprt__InputBinMediaColorType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__InputBinMediaColorType))
		soap_serialize_wprt__InputBinMediaColorType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__InputBinMediaColorType(struct soap *soap, struct wprt__InputBinMediaColorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__InputBinMediaColorType);
	if (soap_out_PointerTowprt__InputBinMediaColorType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__InputBinMediaColorType(struct soap *soap, const char *tag, int id, struct wprt__InputBinMediaColorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__InputBinMediaColorType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__InputBinMediaColorType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__InputBinMediaColorType ** SOAP_FMAC4 soap_get_PointerTowprt__InputBinMediaColorType(struct soap *soap, struct wprt__InputBinMediaColorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__InputBinMediaColorType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinMediaColorType ** SOAP_FMAC4 soap_in_PointerTowprt__InputBinMediaColorType(struct soap *soap, const char *tag, struct wprt__InputBinMediaColorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__InputBinMediaColorType **)soap_malloc(soap, sizeof(struct wprt__InputBinMediaColorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__InputBinMediaColorType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__InputBinMediaColorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__InputBinMediaColorType, sizeof(struct wprt__InputBinMediaColorType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__InputBinMediaTypeBaseType(struct soap *soap, struct wprt__InputBinMediaTypeBaseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__InputBinMediaTypeBaseType))
		soap_serialize_wprt__InputBinMediaTypeBaseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__InputBinMediaTypeBaseType(struct soap *soap, struct wprt__InputBinMediaTypeBaseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__InputBinMediaTypeBaseType);
	if (soap_out_PointerTowprt__InputBinMediaTypeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__InputBinMediaTypeBaseType(struct soap *soap, const char *tag, int id, struct wprt__InputBinMediaTypeBaseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__InputBinMediaTypeBaseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__InputBinMediaTypeBaseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__InputBinMediaTypeBaseType ** SOAP_FMAC4 soap_get_PointerTowprt__InputBinMediaTypeBaseType(struct soap *soap, struct wprt__InputBinMediaTypeBaseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__InputBinMediaTypeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinMediaTypeBaseType ** SOAP_FMAC4 soap_in_PointerTowprt__InputBinMediaTypeBaseType(struct soap *soap, const char *tag, struct wprt__InputBinMediaTypeBaseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__InputBinMediaTypeBaseType **)soap_malloc(soap, sizeof(struct wprt__InputBinMediaTypeBaseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__InputBinMediaTypeBaseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__InputBinMediaTypeBaseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__InputBinMediaTypeBaseType, sizeof(struct wprt__InputBinMediaTypeBaseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__InputBinMediaSizeType(struct soap *soap, struct wprt__InputBinMediaSizeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__InputBinMediaSizeType))
		soap_serialize_wprt__InputBinMediaSizeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__InputBinMediaSizeType(struct soap *soap, struct wprt__InputBinMediaSizeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__InputBinMediaSizeType);
	if (soap_out_PointerTowprt__InputBinMediaSizeType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__InputBinMediaSizeType(struct soap *soap, const char *tag, int id, struct wprt__InputBinMediaSizeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__InputBinMediaSizeType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__InputBinMediaSizeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__InputBinMediaSizeType ** SOAP_FMAC4 soap_get_PointerTowprt__InputBinMediaSizeType(struct soap *soap, struct wprt__InputBinMediaSizeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__InputBinMediaSizeType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinMediaSizeType ** SOAP_FMAC4 soap_in_PointerTowprt__InputBinMediaSizeType(struct soap *soap, const char *tag, struct wprt__InputBinMediaSizeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__InputBinMediaSizeType **)soap_malloc(soap, sizeof(struct wprt__InputBinMediaSizeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__InputBinMediaSizeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__InputBinMediaSizeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__InputBinMediaSizeType, sizeof(struct wprt__InputBinMediaSizeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__InputBinFeedDirectionType(struct soap *soap, struct wprt__InputBinFeedDirectionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__InputBinFeedDirectionType))
		soap_serialize_wprt__InputBinFeedDirectionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__InputBinFeedDirectionType(struct soap *soap, struct wprt__InputBinFeedDirectionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__InputBinFeedDirectionType);
	if (soap_out_PointerTowprt__InputBinFeedDirectionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__InputBinFeedDirectionType(struct soap *soap, const char *tag, int id, struct wprt__InputBinFeedDirectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__InputBinFeedDirectionType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__InputBinFeedDirectionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__InputBinFeedDirectionType ** SOAP_FMAC4 soap_get_PointerTowprt__InputBinFeedDirectionType(struct soap *soap, struct wprt__InputBinFeedDirectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__InputBinFeedDirectionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__InputBinFeedDirectionType ** SOAP_FMAC4 soap_in_PointerTowprt__InputBinFeedDirectionType(struct soap *soap, const char *tag, struct wprt__InputBinFeedDirectionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__InputBinFeedDirectionType **)soap_malloc(soap, sizeof(struct wprt__InputBinFeedDirectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__InputBinFeedDirectionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__InputBinFeedDirectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__InputBinFeedDirectionType, sizeof(struct wprt__InputBinFeedDirectionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__String255ExtType(struct soap *soap, struct wprt__String255ExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__String255ExtType))
		soap_serialize_wprt__String255ExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__String255ExtType(struct soap *soap, struct wprt__String255ExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__String255ExtType);
	if (soap_out_PointerTowprt__String255ExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__String255ExtType(struct soap *soap, const char *tag, int id, struct wprt__String255ExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__String255ExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__String255ExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__String255ExtType ** SOAP_FMAC4 soap_get_PointerTowprt__String255ExtType(struct soap *soap, struct wprt__String255ExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__String255ExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__String255ExtType ** SOAP_FMAC4 soap_in_PointerTowprt__String255ExtType(struct soap *soap, const char *tag, struct wprt__String255ExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__String255ExtType **)soap_malloc(soap, sizeof(struct wprt__String255ExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__String255ExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__String255ExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__String255ExtType, sizeof(struct wprt__String255ExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ConsumableColorType(struct soap *soap, struct wprt__ConsumableColorType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ConsumableColorType))
		soap_serialize_wprt__ConsumableColorType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ConsumableColorType(struct soap *soap, struct wprt__ConsumableColorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ConsumableColorType);
	if (soap_out_PointerTowprt__ConsumableColorType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ConsumableColorType(struct soap *soap, const char *tag, int id, struct wprt__ConsumableColorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ConsumableColorType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ConsumableColorType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ConsumableColorType ** SOAP_FMAC4 soap_get_PointerTowprt__ConsumableColorType(struct soap *soap, struct wprt__ConsumableColorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ConsumableColorType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConsumableColorType ** SOAP_FMAC4 soap_in_PointerTowprt__ConsumableColorType(struct soap *soap, const char *tag, struct wprt__ConsumableColorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ConsumableColorType **)soap_malloc(soap, sizeof(struct wprt__ConsumableColorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ConsumableColorType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ConsumableColorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ConsumableColorType, sizeof(struct wprt__ConsumableColorType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ConsumableTypeBaseType(struct soap *soap, struct wprt__ConsumableTypeBaseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ConsumableTypeBaseType))
		soap_serialize_wprt__ConsumableTypeBaseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ConsumableTypeBaseType(struct soap *soap, struct wprt__ConsumableTypeBaseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ConsumableTypeBaseType);
	if (soap_out_PointerTowprt__ConsumableTypeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ConsumableTypeBaseType(struct soap *soap, const char *tag, int id, struct wprt__ConsumableTypeBaseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ConsumableTypeBaseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ConsumableTypeBaseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ConsumableTypeBaseType ** SOAP_FMAC4 soap_get_PointerTowprt__ConsumableTypeBaseType(struct soap *soap, struct wprt__ConsumableTypeBaseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ConsumableTypeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ConsumableTypeBaseType ** SOAP_FMAC4 soap_in_PointerTowprt__ConsumableTypeBaseType(struct soap *soap, const char *tag, struct wprt__ConsumableTypeBaseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ConsumableTypeBaseType **)soap_malloc(soap, sizeof(struct wprt__ConsumableTypeBaseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ConsumableTypeBaseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ConsumableTypeBaseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ConsumableTypeBaseType, sizeof(struct wprt__ConsumableTypeBaseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__LevelFreeBaseType(struct soap *soap, struct wprt__LevelFreeBaseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__LevelFreeBaseType))
		soap_serialize_wprt__LevelFreeBaseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__LevelFreeBaseType(struct soap *soap, struct wprt__LevelFreeBaseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__LevelFreeBaseType);
	if (soap_out_PointerTowprt__LevelFreeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__LevelFreeBaseType(struct soap *soap, const char *tag, int id, struct wprt__LevelFreeBaseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__LevelFreeBaseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__LevelFreeBaseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__LevelFreeBaseType ** SOAP_FMAC4 soap_get_PointerTowprt__LevelFreeBaseType(struct soap *soap, struct wprt__LevelFreeBaseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__LevelFreeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__LevelFreeBaseType ** SOAP_FMAC4 soap_in_PointerTowprt__LevelFreeBaseType(struct soap *soap, const char *tag, struct wprt__LevelFreeBaseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__LevelFreeBaseType **)soap_malloc(soap, sizeof(struct wprt__LevelFreeBaseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__LevelFreeBaseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__LevelFreeBaseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__LevelFreeBaseType, sizeof(struct wprt__LevelFreeBaseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__IntOneExtType(struct soap *soap, struct wprt__IntOneExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__IntOneExtType))
		soap_serialize_wprt__IntOneExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__IntOneExtType(struct soap *soap, struct wprt__IntOneExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__IntOneExtType);
	if (soap_out_PointerTowprt__IntOneExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__IntOneExtType(struct soap *soap, const char *tag, int id, struct wprt__IntOneExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__IntOneExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__IntOneExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__IntOneExtType ** SOAP_FMAC4 soap_get_PointerTowprt__IntOneExtType(struct soap *soap, struct wprt__IntOneExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__IntOneExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__IntOneExtType ** SOAP_FMAC4 soap_in_PointerTowprt__IntOneExtType(struct soap *soap, const char *tag, struct wprt__IntOneExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__IntOneExtType **)soap_malloc(soap, sizeof(struct wprt__IntOneExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__IntOneExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__IntOneExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__IntOneExtType, sizeof(struct wprt__IntOneExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__StorageTypeBaseType(struct soap *soap, struct wprt__StorageTypeBaseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__StorageTypeBaseType))
		soap_serialize_wprt__StorageTypeBaseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__StorageTypeBaseType(struct soap *soap, struct wprt__StorageTypeBaseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__StorageTypeBaseType);
	if (soap_out_PointerTowprt__StorageTypeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__StorageTypeBaseType(struct soap *soap, const char *tag, int id, struct wprt__StorageTypeBaseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__StorageTypeBaseType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__StorageTypeBaseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__StorageTypeBaseType ** SOAP_FMAC4 soap_get_PointerTowprt__StorageTypeBaseType(struct soap *soap, struct wprt__StorageTypeBaseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__StorageTypeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StorageTypeBaseType ** SOAP_FMAC4 soap_in_PointerTowprt__StorageTypeBaseType(struct soap *soap, const char *tag, struct wprt__StorageTypeBaseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__StorageTypeBaseType **)soap_malloc(soap, sizeof(struct wprt__StorageTypeBaseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__StorageTypeBaseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__StorageTypeBaseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__StorageTypeBaseType, sizeof(struct wprt__StorageTypeBaseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__IntExtType(struct soap *soap, struct wprt__IntExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__IntExtType))
		soap_serialize_wprt__IntExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__IntExtType(struct soap *soap, struct wprt__IntExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__IntExtType);
	if (soap_out_PointerTowprt__IntExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__IntExtType(struct soap *soap, const char *tag, int id, struct wprt__IntExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__IntExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__IntExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__IntExtType ** SOAP_FMAC4 soap_get_PointerTowprt__IntExtType(struct soap *soap, struct wprt__IntExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__IntExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__IntExtType ** SOAP_FMAC4 soap_in_PointerTowprt__IntExtType(struct soap *soap, const char *tag, struct wprt__IntExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__IntExtType **)soap_malloc(soap, sizeof(struct wprt__IntExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__IntExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__IntExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__IntExtType, sizeof(struct wprt__IntExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__NMTOKENSExtType(struct soap *soap, struct wprt__NMTOKENSExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__NMTOKENSExtType))
		soap_serialize_wprt__NMTOKENSExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__NMTOKENSExtType(struct soap *soap, struct wprt__NMTOKENSExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__NMTOKENSExtType);
	if (soap_out_PointerTowprt__NMTOKENSExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__NMTOKENSExtType(struct soap *soap, const char *tag, int id, struct wprt__NMTOKENSExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__NMTOKENSExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__NMTOKENSExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__NMTOKENSExtType ** SOAP_FMAC4 soap_get_PointerTowprt__NMTOKENSExtType(struct soap *soap, struct wprt__NMTOKENSExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__NMTOKENSExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__NMTOKENSExtType ** SOAP_FMAC4 soap_in_PointerTowprt__NMTOKENSExtType(struct soap *soap, const char *tag, struct wprt__NMTOKENSExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__NMTOKENSExtType **)soap_malloc(soap, sizeof(struct wprt__NMTOKENSExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__NMTOKENSExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__NMTOKENSExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__NMTOKENSExtType, sizeof(struct wprt__NMTOKENSExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobEndStateType(struct soap *soap, struct wprt__JobEndStateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobEndStateType))
		soap_serialize_wprt__JobEndStateType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobEndStateType(struct soap *soap, struct wprt__JobEndStateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobEndStateType);
	if (soap_out_PointerTowprt__JobEndStateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobEndStateType(struct soap *soap, const char *tag, int id, struct wprt__JobEndStateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobEndStateType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobEndStateType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobEndStateType ** SOAP_FMAC4 soap_get_PointerTowprt__JobEndStateType(struct soap *soap, struct wprt__JobEndStateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobEndStateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobEndStateType ** SOAP_FMAC4 soap_in_PointerTowprt__JobEndStateType(struct soap *soap, const char *tag, struct wprt__JobEndStateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobEndStateType **)soap_malloc(soap, sizeof(struct wprt__JobEndStateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobEndStateType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobEndStateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobEndStateType, sizeof(struct wprt__JobEndStateType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__IntZeroExtType(struct soap *soap, struct wprt__IntZeroExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__IntZeroExtType))
		soap_serialize_wprt__IntZeroExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__IntZeroExtType(struct soap *soap, struct wprt__IntZeroExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__IntZeroExtType);
	if (soap_out_PointerTowprt__IntZeroExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__IntZeroExtType(struct soap *soap, const char *tag, int id, struct wprt__IntZeroExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__IntZeroExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__IntZeroExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__IntZeroExtType ** SOAP_FMAC4 soap_get_PointerTowprt__IntZeroExtType(struct soap *soap, struct wprt__IntZeroExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__IntZeroExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__IntZeroExtType ** SOAP_FMAC4 soap_in_PointerTowprt__IntZeroExtType(struct soap *soap, const char *tag, struct wprt__IntZeroExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__IntZeroExtType **)soap_malloc(soap, sizeof(struct wprt__IntZeroExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__IntZeroExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__IntZeroExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__IntZeroExtType, sizeof(struct wprt__IntZeroExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobOriginatingUserNameType(struct soap *soap, struct wprt__JobOriginatingUserNameType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobOriginatingUserNameType))
		soap_serialize_wprt__JobOriginatingUserNameType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobOriginatingUserNameType(struct soap *soap, struct wprt__JobOriginatingUserNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobOriginatingUserNameType);
	if (soap_out_PointerTowprt__JobOriginatingUserNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobOriginatingUserNameType(struct soap *soap, const char *tag, int id, struct wprt__JobOriginatingUserNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobOriginatingUserNameType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobOriginatingUserNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobOriginatingUserNameType ** SOAP_FMAC4 soap_get_PointerTowprt__JobOriginatingUserNameType(struct soap *soap, struct wprt__JobOriginatingUserNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobOriginatingUserNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobOriginatingUserNameType ** SOAP_FMAC4 soap_in_PointerTowprt__JobOriginatingUserNameType(struct soap *soap, const char *tag, struct wprt__JobOriginatingUserNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobOriginatingUserNameType **)soap_malloc(soap, sizeof(struct wprt__JobOriginatingUserNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobOriginatingUserNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobOriginatingUserNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobOriginatingUserNameType, sizeof(struct wprt__JobOriginatingUserNameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobNameType(struct soap *soap, struct wprt__JobNameType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobNameType))
		soap_serialize_wprt__JobNameType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobNameType(struct soap *soap, struct wprt__JobNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobNameType);
	if (soap_out_PointerTowprt__JobNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobNameType(struct soap *soap, const char *tag, int id, struct wprt__JobNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobNameType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobNameType ** SOAP_FMAC4 soap_get_PointerTowprt__JobNameType(struct soap *soap, struct wprt__JobNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobNameType ** SOAP_FMAC4 soap_in_PointerTowprt__JobNameType(struct soap *soap, const char *tag, struct wprt__JobNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobNameType **)soap_malloc(soap, sizeof(struct wprt__JobNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobNameType, sizeof(struct wprt__JobNameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobStateReasonsType(struct soap *soap, struct wprt__JobStateReasonsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobStateReasonsType))
		soap_serialize_wprt__JobStateReasonsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobStateReasonsType(struct soap *soap, struct wprt__JobStateReasonsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobStateReasonsType);
	if (soap_out_PointerTowprt__JobStateReasonsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobStateReasonsType(struct soap *soap, const char *tag, int id, struct wprt__JobStateReasonsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobStateReasonsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobStateReasonsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobStateReasonsType ** SOAP_FMAC4 soap_get_PointerTowprt__JobStateReasonsType(struct soap *soap, struct wprt__JobStateReasonsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobStateReasonsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStateReasonsType ** SOAP_FMAC4 soap_in_PointerTowprt__JobStateReasonsType(struct soap *soap, const char *tag, struct wprt__JobStateReasonsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobStateReasonsType **)soap_malloc(soap, sizeof(struct wprt__JobStateReasonsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobStateReasonsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobStateReasonsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobStateReasonsType, sizeof(struct wprt__JobStateReasonsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobStateType(struct soap *soap, struct wprt__JobStateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobStateType))
		soap_serialize_wprt__JobStateType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobStateType(struct soap *soap, struct wprt__JobStateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobStateType);
	if (soap_out_PointerTowprt__JobStateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobStateType(struct soap *soap, const char *tag, int id, struct wprt__JobStateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobStateType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobStateType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobStateType ** SOAP_FMAC4 soap_get_PointerTowprt__JobStateType(struct soap *soap, struct wprt__JobStateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobStateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStateType ** SOAP_FMAC4 soap_in_PointerTowprt__JobStateType(struct soap *soap, const char *tag, struct wprt__JobStateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobStateType **)soap_malloc(soap, sizeof(struct wprt__JobStateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobStateType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobStateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobStateType, sizeof(struct wprt__JobStateType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobStatusType(struct soap *soap, struct wprt__JobStatusType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobStatusType))
		soap_serialize_wprt__JobStatusType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobStatusType(struct soap *soap, struct wprt__JobStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobStatusType);
	if (soap_out_PointerTowprt__JobStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobStatusType(struct soap *soap, const char *tag, int id, struct wprt__JobStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobStatusType ** SOAP_FMAC4 soap_get_PointerTowprt__JobStatusType(struct soap *soap, struct wprt__JobStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobStatusType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobStatusType ** SOAP_FMAC4 soap_in_PointerTowprt__JobStatusType(struct soap *soap, const char *tag, struct wprt__JobStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobStatusType **)soap_malloc(soap, sizeof(struct wprt__JobStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobStatusType, sizeof(struct wprt__JobStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DeviceConditionClearedType(struct soap *soap, struct wprt__DeviceConditionClearedType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DeviceConditionClearedType))
		soap_serialize_wprt__DeviceConditionClearedType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DeviceConditionClearedType(struct soap *soap, struct wprt__DeviceConditionClearedType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DeviceConditionClearedType);
	if (soap_out_PointerTowprt__DeviceConditionClearedType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DeviceConditionClearedType(struct soap *soap, const char *tag, int id, struct wprt__DeviceConditionClearedType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DeviceConditionClearedType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DeviceConditionClearedType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DeviceConditionClearedType ** SOAP_FMAC4 soap_get_PointerTowprt__DeviceConditionClearedType(struct soap *soap, struct wprt__DeviceConditionClearedType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DeviceConditionClearedType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DeviceConditionClearedType ** SOAP_FMAC4 soap_in_PointerTowprt__DeviceConditionClearedType(struct soap *soap, const char *tag, struct wprt__DeviceConditionClearedType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DeviceConditionClearedType **)soap_malloc(soap, sizeof(struct wprt__DeviceConditionClearedType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DeviceConditionClearedType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DeviceConditionClearedType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DeviceConditionClearedType, sizeof(struct wprt__DeviceConditionClearedType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DateTimeExtType(struct soap *soap, struct wprt__DateTimeExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DateTimeExtType))
		soap_serialize_wprt__DateTimeExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DateTimeExtType(struct soap *soap, struct wprt__DateTimeExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DateTimeExtType);
	if (soap_out_PointerTowprt__DateTimeExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DateTimeExtType(struct soap *soap, const char *tag, int id, struct wprt__DateTimeExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DateTimeExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DateTimeExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DateTimeExtType ** SOAP_FMAC4 soap_get_PointerTowprt__DateTimeExtType(struct soap *soap, struct wprt__DateTimeExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DateTimeExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DateTimeExtType ** SOAP_FMAC4 soap_in_PointerTowprt__DateTimeExtType(struct soap *soap, const char *tag, struct wprt__DateTimeExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DateTimeExtType **)soap_malloc(soap, sizeof(struct wprt__DateTimeExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DateTimeExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DateTimeExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DateTimeExtType, sizeof(struct wprt__DateTimeExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DeviceConditionType(struct soap *soap, struct wprt__DeviceConditionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DeviceConditionType))
		soap_serialize_wprt__DeviceConditionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DeviceConditionType(struct soap *soap, struct wprt__DeviceConditionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DeviceConditionType);
	if (soap_out_PointerTowprt__DeviceConditionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DeviceConditionType(struct soap *soap, const char *tag, int id, struct wprt__DeviceConditionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DeviceConditionType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DeviceConditionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DeviceConditionType ** SOAP_FMAC4 soap_get_PointerTowprt__DeviceConditionType(struct soap *soap, struct wprt__DeviceConditionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DeviceConditionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DeviceConditionType ** SOAP_FMAC4 soap_in_PointerTowprt__DeviceConditionType(struct soap *soap, const char *tag, struct wprt__DeviceConditionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DeviceConditionType **)soap_malloc(soap, sizeof(struct wprt__DeviceConditionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DeviceConditionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DeviceConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DeviceConditionType, sizeof(struct wprt__DeviceConditionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__StatusSummaryType(struct soap *soap, struct wprt__StatusSummaryType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__StatusSummaryType))
		soap_serialize_wprt__StatusSummaryType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__StatusSummaryType(struct soap *soap, struct wprt__StatusSummaryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__StatusSummaryType);
	if (soap_out_PointerTowprt__StatusSummaryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__StatusSummaryType(struct soap *soap, const char *tag, int id, struct wprt__StatusSummaryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__StatusSummaryType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__StatusSummaryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__StatusSummaryType ** SOAP_FMAC4 soap_get_PointerTowprt__StatusSummaryType(struct soap *soap, struct wprt__StatusSummaryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__StatusSummaryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__StatusSummaryType ** SOAP_FMAC4 soap_in_PointerTowprt__StatusSummaryType(struct soap *soap, const char *tag, struct wprt__StatusSummaryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__StatusSummaryType **)soap_malloc(soap, sizeof(struct wprt__StatusSummaryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__StatusSummaryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__StatusSummaryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__StatusSummaryType, sizeof(struct wprt__StatusSummaryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterStateReasonsType(struct soap *soap, struct wprt__PrinterStateReasonsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterStateReasonsType))
		soap_serialize_wprt__PrinterStateReasonsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterStateReasonsType(struct soap *soap, struct wprt__PrinterStateReasonsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterStateReasonsType);
	if (soap_out_PointerTowprt__PrinterStateReasonsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterStateReasonsType(struct soap *soap, const char *tag, int id, struct wprt__PrinterStateReasonsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterStateReasonsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterStateReasonsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterStateReasonsType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterStateReasonsType(struct soap *soap, struct wprt__PrinterStateReasonsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterStateReasonsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStateReasonsType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterStateReasonsType(struct soap *soap, const char *tag, struct wprt__PrinterStateReasonsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterStateReasonsType **)soap_malloc(soap, sizeof(struct wprt__PrinterStateReasonsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterStateReasonsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStateReasonsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterStateReasonsType, sizeof(struct wprt__PrinterStateReasonsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterStateReasonType(struct soap *soap, struct wprt__PrinterStateReasonType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterStateReasonType))
		soap_serialize_wprt__PrinterStateReasonType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterStateReasonType(struct soap *soap, struct wprt__PrinterStateReasonType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterStateReasonType);
	if (soap_out_PointerTowprt__PrinterStateReasonType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterStateReasonType(struct soap *soap, const char *tag, int id, struct wprt__PrinterStateReasonType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterStateReasonType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterStateReasonType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterStateReasonType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterStateReasonType(struct soap *soap, struct wprt__PrinterStateReasonType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterStateReasonType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStateReasonType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterStateReasonType(struct soap *soap, const char *tag, struct wprt__PrinterStateReasonType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterStateReasonType **)soap_malloc(soap, sizeof(struct wprt__PrinterStateReasonType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterStateReasonType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStateReasonType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterStateReasonType, sizeof(struct wprt__PrinterStateReasonType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterStateType(struct soap *soap, struct wprt__PrinterStateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterStateType))
		soap_serialize_wprt__PrinterStateType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterStateType(struct soap *soap, struct wprt__PrinterStateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterStateType);
	if (soap_out_PointerTowprt__PrinterStateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterStateType(struct soap *soap, const char *tag, int id, struct wprt__PrinterStateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterStateType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterStateType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterStateType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterStateType(struct soap *soap, struct wprt__PrinterStateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterStateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterStateType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterStateType(struct soap *soap, const char *tag, struct wprt__PrinterStateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterStateType **)soap_malloc(soap, sizeof(struct wprt__PrinterStateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterStateType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterStateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterStateType, sizeof(struct wprt__PrinterStateType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ElementChangesType(struct soap *soap, struct wprt__ElementChangesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ElementChangesType))
		soap_serialize_wprt__ElementChangesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ElementChangesType(struct soap *soap, struct wprt__ElementChangesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ElementChangesType);
	if (soap_out_PointerTowprt__ElementChangesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ElementChangesType(struct soap *soap, const char *tag, int id, struct wprt__ElementChangesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ElementChangesType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ElementChangesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ElementChangesType ** SOAP_FMAC4 soap_get_PointerTowprt__ElementChangesType(struct soap *soap, struct wprt__ElementChangesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ElementChangesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ElementChangesType ** SOAP_FMAC4 soap_in_PointerTowprt__ElementChangesType(struct soap *soap, const char *tag, struct wprt__ElementChangesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ElementChangesType **)soap_malloc(soap, sizeof(struct wprt__ElementChangesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ElementChangesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ElementChangesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ElementChangesType, sizeof(struct wprt__ElementChangesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterCapabilitiesType(struct soap *soap, struct wprt__PrinterCapabilitiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterCapabilitiesType))
		soap_serialize_wprt__PrinterCapabilitiesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterCapabilitiesType(struct soap *soap, struct wprt__PrinterCapabilitiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterCapabilitiesType);
	if (soap_out_PointerTowprt__PrinterCapabilitiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterCapabilitiesType(struct soap *soap, const char *tag, int id, struct wprt__PrinterCapabilitiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterCapabilitiesType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterCapabilitiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterCapabilitiesType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterCapabilitiesType(struct soap *soap, struct wprt__PrinterCapabilitiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterCapabilitiesType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterCapabilitiesType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterCapabilitiesType(struct soap *soap, const char *tag, struct wprt__PrinterCapabilitiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterCapabilitiesType **)soap_malloc(soap, sizeof(struct wprt__PrinterCapabilitiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterCapabilitiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterCapabilitiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterCapabilitiesType, sizeof(struct wprt__PrinterCapabilitiesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterConfigurationType(struct soap *soap, struct wprt__PrinterConfigurationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterConfigurationType))
		soap_serialize_wprt__PrinterConfigurationType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterConfigurationType(struct soap *soap, struct wprt__PrinterConfigurationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterConfigurationType);
	if (soap_out_PointerTowprt__PrinterConfigurationType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterConfigurationType(struct soap *soap, const char *tag, int id, struct wprt__PrinterConfigurationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterConfigurationType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterConfigurationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterConfigurationType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterConfigurationType(struct soap *soap, struct wprt__PrinterConfigurationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterConfigurationType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterConfigurationType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterConfigurationType(struct soap *soap, const char *tag, struct wprt__PrinterConfigurationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterConfigurationType **)soap_malloc(soap, sizeof(struct wprt__PrinterConfigurationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterConfigurationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterConfigurationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterConfigurationType, sizeof(struct wprt__PrinterConfigurationType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterDescriptionType(struct soap *soap, struct wprt__PrinterDescriptionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterDescriptionType))
		soap_serialize_wprt__PrinterDescriptionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterDescriptionType(struct soap *soap, struct wprt__PrinterDescriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterDescriptionType);
	if (soap_out_PointerTowprt__PrinterDescriptionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterDescriptionType(struct soap *soap, const char *tag, int id, struct wprt__PrinterDescriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterDescriptionType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterDescriptionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterDescriptionType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterDescriptionType(struct soap *soap, struct wprt__PrinterDescriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterDescriptionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterDescriptionType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterDescriptionType(struct soap *soap, const char *tag, struct wprt__PrinterDescriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterDescriptionType **)soap_malloc(soap, sizeof(struct wprt__PrinterDescriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterDescriptionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterDescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterDescriptionType, sizeof(struct wprt__PrinterDescriptionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__EventRateType(struct soap *soap, struct wprt__EventRateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__EventRateType))
		soap_serialize_wprt__EventRateType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__EventRateType(struct soap *soap, struct wprt__EventRateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__EventRateType);
	if (soap_out_PointerTowprt__EventRateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__EventRateType(struct soap *soap, const char *tag, int id, struct wprt__EventRateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__EventRateType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__EventRateType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__EventRateType ** SOAP_FMAC4 soap_get_PointerTowprt__EventRateType(struct soap *soap, struct wprt__EventRateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__EventRateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__EventRateType ** SOAP_FMAC4 soap_in_PointerTowprt__EventRateType(struct soap *soap, const char *tag, struct wprt__EventRateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__EventRateType **)soap_malloc(soap, sizeof(struct wprt__EventRateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__EventRateType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__EventRateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__EventRateType, sizeof(struct wprt__EventRateType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__ListOfSummarysType(struct soap *soap, struct wprt__ListOfSummarysType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__ListOfSummarysType))
		soap_serialize_wprt__ListOfSummarysType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__ListOfSummarysType(struct soap *soap, struct wprt__ListOfSummarysType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__ListOfSummarysType);
	if (soap_out_PointerTowprt__ListOfSummarysType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__ListOfSummarysType(struct soap *soap, const char *tag, int id, struct wprt__ListOfSummarysType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__ListOfSummarysType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__ListOfSummarysType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__ListOfSummarysType ** SOAP_FMAC4 soap_get_PointerTowprt__ListOfSummarysType(struct soap *soap, struct wprt__ListOfSummarysType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__ListOfSummarysType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__ListOfSummarysType ** SOAP_FMAC4 soap_in_PointerTowprt__ListOfSummarysType(struct soap *soap, const char *tag, struct wprt__ListOfSummarysType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__ListOfSummarysType **)soap_malloc(soap, sizeof(struct wprt__ListOfSummarysType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__ListOfSummarysType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__ListOfSummarysType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__ListOfSummarysType, sizeof(struct wprt__ListOfSummarysType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobElementsType(struct soap *soap, struct wprt__JobElementsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobElementsType))
		soap_serialize_wprt__JobElementsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobElementsType(struct soap *soap, struct wprt__JobElementsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobElementsType);
	if (soap_out_PointerTowprt__JobElementsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobElementsType(struct soap *soap, const char *tag, int id, struct wprt__JobElementsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobElementsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobElementsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobElementsType ** SOAP_FMAC4 soap_get_PointerTowprt__JobElementsType(struct soap *soap, struct wprt__JobElementsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobElementsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobElementsType ** SOAP_FMAC4 soap_in_PointerTowprt__JobElementsType(struct soap *soap, const char *tag, struct wprt__JobElementsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobElementsType **)soap_malloc(soap, sizeof(struct wprt__JobElementsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobElementsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobElementsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobElementsType, sizeof(struct wprt__JobElementsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__RequestedJobElementsType(struct soap *soap, struct wprt__RequestedJobElementsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__RequestedJobElementsType))
		soap_serialize_wprt__RequestedJobElementsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__RequestedJobElementsType(struct soap *soap, struct wprt__RequestedJobElementsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__RequestedJobElementsType);
	if (soap_out_PointerTowprt__RequestedJobElementsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__RequestedJobElementsType(struct soap *soap, const char *tag, int id, struct wprt__RequestedJobElementsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__RequestedJobElementsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__RequestedJobElementsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__RequestedJobElementsType ** SOAP_FMAC4 soap_get_PointerTowprt__RequestedJobElementsType(struct soap *soap, struct wprt__RequestedJobElementsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__RequestedJobElementsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__RequestedJobElementsType ** SOAP_FMAC4 soap_in_PointerTowprt__RequestedJobElementsType(struct soap *soap, const char *tag, struct wprt__RequestedJobElementsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__RequestedJobElementsType **)soap_malloc(soap, sizeof(struct wprt__RequestedJobElementsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__RequestedJobElementsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__RequestedJobElementsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__RequestedJobElementsType, sizeof(struct wprt__RequestedJobElementsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrinterElementsType(struct soap *soap, struct wprt__PrinterElementsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrinterElementsType))
		soap_serialize_wprt__PrinterElementsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrinterElementsType(struct soap *soap, struct wprt__PrinterElementsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrinterElementsType);
	if (soap_out_PointerTowprt__PrinterElementsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrinterElementsType(struct soap *soap, const char *tag, int id, struct wprt__PrinterElementsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrinterElementsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrinterElementsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrinterElementsType ** SOAP_FMAC4 soap_get_PointerTowprt__PrinterElementsType(struct soap *soap, struct wprt__PrinterElementsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrinterElementsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrinterElementsType ** SOAP_FMAC4 soap_in_PointerTowprt__PrinterElementsType(struct soap *soap, const char *tag, struct wprt__PrinterElementsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrinterElementsType **)soap_malloc(soap, sizeof(struct wprt__PrinterElementsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrinterElementsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrinterElementsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrinterElementsType, sizeof(struct wprt__PrinterElementsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__RequestedPrinterElementsType(struct soap *soap, struct wprt__RequestedPrinterElementsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__RequestedPrinterElementsType))
		soap_serialize_wprt__RequestedPrinterElementsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__RequestedPrinterElementsType(struct soap *soap, struct wprt__RequestedPrinterElementsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__RequestedPrinterElementsType);
	if (soap_out_PointerTowprt__RequestedPrinterElementsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__RequestedPrinterElementsType(struct soap *soap, const char *tag, int id, struct wprt__RequestedPrinterElementsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__RequestedPrinterElementsType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__RequestedPrinterElementsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__RequestedPrinterElementsType ** SOAP_FMAC4 soap_get_PointerTowprt__RequestedPrinterElementsType(struct soap *soap, struct wprt__RequestedPrinterElementsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__RequestedPrinterElementsType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__RequestedPrinterElementsType ** SOAP_FMAC4 soap_in_PointerTowprt__RequestedPrinterElementsType(struct soap *soap, const char *tag, struct wprt__RequestedPrinterElementsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__RequestedPrinterElementsType **)soap_malloc(soap, sizeof(struct wprt__RequestedPrinterElementsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__RequestedPrinterElementsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__RequestedPrinterElementsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__RequestedPrinterElementsType, sizeof(struct wprt__RequestedPrinterElementsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__AnyURIExtType(struct soap *soap, struct wprt__AnyURIExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__AnyURIExtType))
		soap_serialize_wprt__AnyURIExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__AnyURIExtType(struct soap *soap, struct wprt__AnyURIExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__AnyURIExtType);
	if (soap_out_PointerTowprt__AnyURIExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__AnyURIExtType(struct soap *soap, const char *tag, int id, struct wprt__AnyURIExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__AnyURIExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__AnyURIExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__AnyURIExtType ** SOAP_FMAC4 soap_get_PointerTowprt__AnyURIExtType(struct soap *soap, struct wprt__AnyURIExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__AnyURIExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__AnyURIExtType ** SOAP_FMAC4 soap_in_PointerTowprt__AnyURIExtType(struct soap *soap, const char *tag, struct wprt__AnyURIExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__AnyURIExtType **)soap_malloc(soap, sizeof(struct wprt__AnyURIExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__AnyURIExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__AnyURIExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__AnyURIExtType, sizeof(struct wprt__AnyURIExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__BoolExtType(struct soap *soap, struct wprt__BoolExtType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__BoolExtType))
		soap_serialize_wprt__BoolExtType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__BoolExtType(struct soap *soap, struct wprt__BoolExtType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__BoolExtType);
	if (soap_out_PointerTowprt__BoolExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__BoolExtType(struct soap *soap, const char *tag, int id, struct wprt__BoolExtType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__BoolExtType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__BoolExtType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__BoolExtType ** SOAP_FMAC4 soap_get_PointerTowprt__BoolExtType(struct soap *soap, struct wprt__BoolExtType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__BoolExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__BoolExtType ** SOAP_FMAC4 soap_in_PointerTowprt__BoolExtType(struct soap *soap, const char *tag, struct wprt__BoolExtType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__BoolExtType **)soap_malloc(soap, sizeof(struct wprt__BoolExtType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__BoolExtType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__BoolExtType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__BoolExtType, sizeof(struct wprt__BoolExtType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DocumentProcessingType(struct soap *soap, struct wprt__DocumentProcessingType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DocumentProcessingType))
		soap_serialize_wprt__DocumentProcessingType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DocumentProcessingType(struct soap *soap, struct wprt__DocumentProcessingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DocumentProcessingType);
	if (soap_out_PointerTowprt__DocumentProcessingType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DocumentProcessingType(struct soap *soap, const char *tag, int id, struct wprt__DocumentProcessingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DocumentProcessingType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DocumentProcessingType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DocumentProcessingType ** SOAP_FMAC4 soap_get_PointerTowprt__DocumentProcessingType(struct soap *soap, struct wprt__DocumentProcessingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DocumentProcessingType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentProcessingType ** SOAP_FMAC4 soap_in_PointerTowprt__DocumentProcessingType(struct soap *soap, const char *tag, struct wprt__DocumentProcessingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DocumentProcessingType **)soap_malloc(soap, sizeof(struct wprt__DocumentProcessingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DocumentProcessingType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentProcessingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DocumentProcessingType, sizeof(struct wprt__DocumentProcessingType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__DocumentDescriptionType(struct soap *soap, struct wprt__DocumentDescriptionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__DocumentDescriptionType))
		soap_serialize_wprt__DocumentDescriptionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__DocumentDescriptionType(struct soap *soap, struct wprt__DocumentDescriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__DocumentDescriptionType);
	if (soap_out_PointerTowprt__DocumentDescriptionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__DocumentDescriptionType(struct soap *soap, const char *tag, int id, struct wprt__DocumentDescriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__DocumentDescriptionType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__DocumentDescriptionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__DocumentDescriptionType ** SOAP_FMAC4 soap_get_PointerTowprt__DocumentDescriptionType(struct soap *soap, struct wprt__DocumentDescriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__DocumentDescriptionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__DocumentDescriptionType ** SOAP_FMAC4 soap_in_PointerTowprt__DocumentDescriptionType(struct soap *soap, const char *tag, struct wprt__DocumentDescriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__DocumentDescriptionType **)soap_malloc(soap, sizeof(struct wprt__DocumentDescriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__DocumentDescriptionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__DocumentDescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__DocumentDescriptionType, sizeof(struct wprt__DocumentDescriptionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__JobIdType(struct soap *soap, struct wprt__JobIdType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__JobIdType))
		soap_serialize_wprt__JobIdType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__JobIdType(struct soap *soap, struct wprt__JobIdType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__JobIdType);
	if (soap_out_PointerTowprt__JobIdType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__JobIdType(struct soap *soap, const char *tag, int id, struct wprt__JobIdType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__JobIdType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__JobIdType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__JobIdType ** SOAP_FMAC4 soap_get_PointerTowprt__JobIdType(struct soap *soap, struct wprt__JobIdType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__JobIdType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__JobIdType ** SOAP_FMAC4 soap_in_PointerTowprt__JobIdType(struct soap *soap, const char *tag, struct wprt__JobIdType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__JobIdType **)soap_malloc(soap, sizeof(struct wprt__JobIdType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__JobIdType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__JobIdType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__JobIdType, sizeof(struct wprt__JobIdType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowprt__PrintTicketType(struct soap *soap, struct wprt__PrintTicketType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wprt__PrintTicketType))
		soap_serialize_wprt__PrintTicketType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowprt__PrintTicketType(struct soap *soap, struct wprt__PrintTicketType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowprt__PrintTicketType);
	if (soap_out_PointerTowprt__PrintTicketType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowprt__PrintTicketType(struct soap *soap, const char *tag, int id, struct wprt__PrintTicketType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wprt__PrintTicketType);
	if (id < 0)
		return soap->error;
	return soap_out_wprt__PrintTicketType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wprt__PrintTicketType ** SOAP_FMAC4 soap_get_PointerTowprt__PrintTicketType(struct soap *soap, struct wprt__PrintTicketType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowprt__PrintTicketType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wprt__PrintTicketType ** SOAP_FMAC4 soap_in_PointerTowprt__PrintTicketType(struct soap *soap, const char *tag, struct wprt__PrintTicketType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wprt__PrintTicketType **)soap_malloc(soap, sizeof(struct wprt__PrintTicketType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wprt__PrintTicketType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wprt__PrintTicketType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wprt__PrintTicketType, sizeof(struct wprt__PrintTicketType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ComponentNameBaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ComponentNameBaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ComponentNameBaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ComponentNameBaseType);
	if (soap_out_wprt__ComponentNameBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ComponentNameBaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__ComponentNameBaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__ComponentNameBaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ComponentNameBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__ComponentNameBaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__ComponentNameBaseType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__LocalizedStringRestrictType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__LocalizedStringRestrictType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__LocalizedStringRestrictType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__LocalizedStringRestrictType);
	if (soap_out_wprt__LocalizedStringRestrictType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__LocalizedStringRestrictType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__LocalizedStringRestrictType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__LocalizedStringRestrictType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__LocalizedStringRestrictType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__LocalizedStringRestrictType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__LocalizedStringRestrictType, 1, -1, 127);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DeviceIdBaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DeviceIdBaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DeviceIdBaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DeviceIdBaseType);
	if (soap_out_wprt__DeviceIdBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DeviceIdBaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__DeviceIdBaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__DeviceIdBaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DeviceIdBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__DeviceIdBaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__DeviceIdBaseType, 1, -1, 1023);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobOriginatingUserNameRestrictionType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobOriginatingUserNameRestrictionType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobOriginatingUserNameRestrictionType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobOriginatingUserNameRestrictionType);
	if (soap_out_wprt__JobOriginatingUserNameRestrictionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobOriginatingUserNameRestrictionType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__JobOriginatingUserNameRestrictionType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__JobOriginatingUserNameRestrictionType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobOriginatingUserNameRestrictionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__JobOriginatingUserNameRestrictionType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__JobOriginatingUserNameRestrictionType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobNameRestrictionType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobNameRestrictionType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobNameRestrictionType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobNameRestrictionType);
	if (soap_out_wprt__JobNameRestrictionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobNameRestrictionType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__JobNameRestrictionType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__JobNameRestrictionType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobNameRestrictionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__JobNameRestrictionType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__JobNameRestrictionType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StringNsExtensionPatternType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StringNsExtensionPatternType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StringNsExtensionPatternType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StringNsExtensionPatternType);
	if (soap_out_wprt__StringNsExtensionPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StringNsExtensionPatternType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__StringNsExtensionPatternType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__StringNsExtensionPatternType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StringNsExtensionPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__StringNsExtensionPatternType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__StringNsExtensionPatternType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__OutputBinExtensionPatternType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__OutputBinExtensionPatternType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__OutputBinExtensionPatternType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__OutputBinExtensionPatternType);
	if (soap_out_wprt__OutputBinExtensionPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__OutputBinExtensionPatternType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__OutputBinExtensionPatternType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__OutputBinExtensionPatternType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__OutputBinExtensionPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__OutputBinExtensionPatternType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__OutputBinExtensionPatternType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MimeExtensionPatternType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MimeExtensionPatternType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MimeExtensionPatternType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MimeExtensionPatternType);
	if (soap_out_wprt__MimeExtensionPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MimeExtensionPatternType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MimeExtensionPatternType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MimeExtensionPatternType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MimeExtensionPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MimeExtensionPatternType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MimeExtensionPatternType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__KeywordNsExtensionPatternType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__KeywordNsExtensionPatternType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__KeywordNsExtensionPatternType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__KeywordNsExtensionPatternType);
	if (soap_out_wprt__KeywordNsExtensionPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__KeywordNsExtensionPatternType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__KeywordNsExtensionPatternType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__KeywordNsExtensionPatternType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__KeywordNsExtensionPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__KeywordNsExtensionPatternType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__KeywordNsExtensionPatternType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinExtensionPatternType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinExtensionPatternType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinExtensionPatternType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinExtensionPatternType);
	if (soap_out_wprt__InputBinExtensionPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinExtensionPatternType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__InputBinExtensionPatternType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__InputBinExtensionPatternType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinExtensionPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__InputBinExtensionPatternType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__InputBinExtensionPatternType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaNsExtensionPatternType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaNsExtensionPatternType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaNsExtensionPatternType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaNsExtensionPatternType);
	if (soap_out_wprt__MediaNsExtensionPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaNsExtensionPatternType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MediaNsExtensionPatternType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MediaNsExtensionPatternType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaNsExtensionPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MediaNsExtensionPatternType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MediaNsExtensionPatternType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaColorExtensionPatternType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaColorExtensionPatternType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaColorExtensionPatternType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaColorExtensionPatternType);
	if (soap_out_wprt__MediaColorExtensionPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaColorExtensionPatternType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MediaColorExtensionPatternType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MediaColorExtensionPatternType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaColorExtensionPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MediaColorExtensionPatternType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MediaColorExtensionPatternType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaTypeExtensionPatternType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaTypeExtensionPatternType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaTypeExtensionPatternType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaTypeExtensionPatternType);
	if (soap_out_wprt__MediaTypeExtensionPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaTypeExtensionPatternType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MediaTypeExtensionPatternType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MediaTypeExtensionPatternType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaTypeExtensionPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MediaTypeExtensionPatternType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MediaTypeExtensionPatternType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaSizeNameExtensionPatternType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaSizeNameExtensionPatternType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaSizeNameExtensionPatternType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaSizeNameExtensionPatternType);
	if (soap_out_wprt__MediaSizeNameExtensionPatternType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaSizeNameExtensionPatternType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MediaSizeNameExtensionPatternType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MediaSizeNameExtensionPatternType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaSizeNameExtensionPatternType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MediaSizeNameExtensionPatternType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MediaSizeNameExtensionPatternType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinMediaColorBaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinMediaColorBaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinMediaColorBaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinMediaColorBaseType);
	if (soap_out_wprt__InputBinMediaColorBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinMediaColorBaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__InputBinMediaColorBaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__InputBinMediaColorBaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinMediaColorBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__InputBinMediaColorBaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__InputBinMediaColorBaseType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinMediaSizeBaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinMediaSizeBaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinMediaSizeBaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinMediaSizeBaseType);
	if (soap_out_wprt__InputBinMediaSizeBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinMediaSizeBaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__InputBinMediaSizeBaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__InputBinMediaSizeBaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinMediaSizeBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__InputBinMediaSizeBaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__InputBinMediaSizeBaseType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__String255BaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__String255BaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__String255BaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__String255BaseType);
	if (soap_out_wprt__String255BaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__String255BaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__String255BaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__String255BaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__String255BaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__String255BaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__String255BaseType, 1, -1, 255);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStateReasonBaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterStateReasonBaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStateReasonBaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStateReasonBaseType);
	if (soap_out_wprt__PrinterStateReasonBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStateReasonBaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__PrinterStateReasonBaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__PrinterStateReasonBaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStateReasonBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__PrinterStateReasonBaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__PrinterStateReasonBaseType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrinterStateBaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrinterStateBaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrinterStateBaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrinterStateBaseType);
	if (soap_out_wprt__PrinterStateBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrinterStateBaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__PrinterStateBaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__PrinterStateBaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrinterStateBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__PrinterStateBaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__PrinterStateBaseType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__HolePunchPatternExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__HolePunchPatternExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__HolePunchPatternExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__HolePunchPatternExtType);
	if (soap_out_wprt__HolePunchPatternExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__HolePunchPatternExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__HolePunchPatternExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__HolePunchPatternExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__HolePunchPatternExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__HolePunchPatternExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__HolePunchPatternExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__HolePunchEdgeExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__HolePunchEdgeExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__HolePunchEdgeExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__HolePunchEdgeExtType);
	if (soap_out_wprt__HolePunchEdgeExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__HolePunchEdgeExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__HolePunchEdgeExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__HolePunchEdgeExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__HolePunchEdgeExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__HolePunchEdgeExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__HolePunchEdgeExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StapleAngleExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StapleAngleExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StapleAngleExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StapleAngleExtType);
	if (soap_out_wprt__StapleAngleExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StapleAngleExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__StapleAngleExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__StapleAngleExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StapleAngleExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__StapleAngleExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__StapleAngleExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StapleLocationExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StapleLocationExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StapleLocationExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StapleLocationExtType);
	if (soap_out_wprt__StapleLocationExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StapleLocationExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__StapleLocationExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__StapleLocationExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StapleLocationExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__StapleLocationExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__StapleLocationExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobStateReasonExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobStateReasonExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobStateReasonExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobStateReasonExtType);
	if (soap_out_wprt__JobStateReasonExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobStateReasonExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__JobStateReasonExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__JobStateReasonExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobStateReasonExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__JobStateReasonExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__JobStateReasonExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__JobStateExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__JobStateExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__JobStateExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__JobStateExtType);
	if (soap_out_wprt__JobStateExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__JobStateExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__JobStateExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__JobStateExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__JobStateExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__JobStateExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__JobStateExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__SidesBaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__SidesBaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__SidesBaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__SidesBaseType);
	if (soap_out_wprt__SidesBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__SidesBaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__SidesBaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__SidesBaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__SidesBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__SidesBaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__SidesBaseType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__PrintQualityBaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__PrintQualityBaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__PrintQualityBaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__PrintQualityBaseType);
	if (soap_out_wprt__PrintQualityBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__PrintQualityBaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__PrintQualityBaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__PrintQualityBaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__PrintQualityBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__PrintQualityBaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__PrintQualityBaseType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__OrientationBaseType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__OrientationBaseType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__OrientationBaseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__OrientationBaseType);
	if (soap_out_wprt__OrientationBaseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__OrientationBaseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__OrientationBaseType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__OrientationBaseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__OrientationBaseType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__OrientationBaseType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__OrientationBaseType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaSizeNameWKVType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaSizeNameWKVType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaSizeNameWKVType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaSizeNameWKVType);
	if (soap_out_wprt__MediaSizeNameWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaSizeNameWKVType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MediaSizeNameWKVType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MediaSizeNameWKVType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaSizeNameWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MediaSizeNameWKVType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MediaSizeNameWKVType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaWKVType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaWKVType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaWKVType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaWKVType);
	if (soap_out_wprt__MediaWKVType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaWKVType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MediaWKVType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MediaWKVType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaWKVType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MediaWKVType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MediaWKVType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__OutputBinNameType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__OutputBinNameType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__OutputBinNameType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__OutputBinNameType);
	if (soap_out_wprt__OutputBinNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__OutputBinNameType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__OutputBinNameType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__OutputBinNameType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__OutputBinNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__OutputBinNameType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__OutputBinNameType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__InputBinNameType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__InputBinNameType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__InputBinNameType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__InputBinNameType);
	if (soap_out_wprt__InputBinNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__InputBinNameType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__InputBinNameType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__InputBinNameType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__InputBinNameType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__InputBinNameType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__InputBinNameType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConsumableColorExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConsumableColorExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConsumableColorExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConsumableColorExtType);
	if (soap_out_wprt__ConsumableColorExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConsumableColorExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__ConsumableColorExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__ConsumableColorExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConsumableColorExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__ConsumableColorExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__ConsumableColorExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__ConsumableTypeExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__ConsumableTypeExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__ConsumableTypeExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__ConsumableTypeExtType);
	if (soap_out_wprt__ConsumableTypeExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__ConsumableTypeExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__ConsumableTypeExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__ConsumableTypeExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__ConsumableTypeExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__ConsumableTypeExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__ConsumableTypeExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__StorageTypeExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__StorageTypeExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__StorageTypeExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__StorageTypeExtType);
	if (soap_out_wprt__StorageTypeExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__StorageTypeExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__StorageTypeExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__StorageTypeExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__StorageTypeExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__StorageTypeExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__StorageTypeExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaColorExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaColorExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaColorExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaColorExtType);
	if (soap_out_wprt__MediaColorExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaColorExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MediaColorExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MediaColorExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaColorExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MediaColorExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MediaColorExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaTypeExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaTypeExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaTypeExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaTypeExtType);
	if (soap_out_wprt__MediaTypeExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaTypeExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MediaTypeExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MediaTypeExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaTypeExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MediaTypeExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MediaTypeExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__MediaSizeNameExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__MediaSizeNameExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__MediaSizeNameExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__MediaSizeNameExtType);
	if (soap_out_wprt__MediaSizeNameExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__MediaSizeNameExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__MediaSizeNameExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__MediaSizeNameExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__MediaSizeNameExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__MediaSizeNameExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__MediaSizeNameExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__DocumentFormatExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__DocumentFormatExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__DocumentFormatExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__DocumentFormatExtType);
	if (soap_out_wprt__DocumentFormatExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__DocumentFormatExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__DocumentFormatExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__DocumentFormatExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__DocumentFormatExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__DocumentFormatExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__DocumentFormatExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wprt__CompressionExtType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wprt__CompressionExtType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wprt__CompressionExtType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wprt__CompressionExtType);
	if (soap_out_wprt__CompressionExtType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wprt__CompressionExtType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wprt__CompressionExtType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wprt__CompressionExtType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wprt__CompressionExtType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wprt__CompressionExtType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wprt__CompressionExtType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__NMTOKENS(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKENS(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKENS(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NMTOKENS);
	if (soap_out_xsd__NMTOKENS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKENS(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NMTOKENS);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NMTOKENS(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKENS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NMTOKENS(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NMTOKENS, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__NMTOKEN(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKEN(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKEN(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NMTOKEN);
	if (soap_out_xsd__NMTOKEN(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKEN(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NMTOKEN);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NMTOKEN(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKEN(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NMTOKEN(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NMTOKEN, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

#ifdef __cplusplus
}
#endif

/* End of wprtC.c */
