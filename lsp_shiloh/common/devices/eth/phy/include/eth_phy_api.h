/*
 * ============================================================================
 * Copyright (c) 2009-2013   Marvell International, Ltd. All Rights Reserved
 *
 *                         Marvell Confidential
 * ============================================================================
 */

/**
 * @file eth_phy_api.h
 * 
 * @brief Ethernet PHY device driver
 * 
 * Device driver for the standard PHY MII Management Interface as defined by IEEE 802.3-2008 clause
 * 22 (section 22.2.4).
 */

#ifndef ETH_PHY_API_H
#define ETH_PHY_API_H

#include <stdint.h>
#include <stdbool.h>
#include "error_types.h"
#ifdef HAVE_POWER_MGR
#include "pwr_mgr_api.h"
#endif // HAVE_POWER_MGR
#include "eth_mac_api.h"


/**
 * @name Ethernet PHY return codes
 * 
 * @note error code values 0 through -10 are reserved in error_types.h
 */

typedef int32_t eth_phy_rcode_t;

#define ETH_PHY_OK              OK
#define ETH_PHY_FAIL            FAIL
#define ETH_PHY_HW_ERR          -11 ///< Hardware error or device unresponsive.
#define ETH_PHY_BAD_PARAM       -12 ///< Invalid function parameter value.
#define ETH_PHY_NOT_SUPPORTED   -13 ///< Requested operation not supported by vendor-specific driver.
//@}

/**
 * @brief Ethernet PHY link configuration method
 * 
 * The method by which the Ethernet PHY will attempt to configure itself and acquire link status
 * (e.g. auto-negotiation vs. forced speed and duplex).
 * 
 * Use the ETH_PHY_LINK_CONFIG_X macros to access the bitfields of this uint32_t.
 */
typedef uint32_t eth_phy_link_config_t;

/**
 * @name Ethernet PHY link configuration method flags
 * 
 * Use these ETH_PHY_LINK_CONFIG_X macros to access the bitfields of eth_phy_link_config_t.
 */
#define ETH_PHY_LINK_CONFIG_AUTO            0x00000001 ///< Auto-negotiate speed/duplex
#define ETH_PHY_LINK_CONFIG_DUPLEX_HALF     0x00000010 ///< Force half duplex
#define ETH_PHY_LINK_CONFIG_DUPLEX_FULL     0x00000020 ///< Force full duplex
#define ETH_PHY_LINK_CONFIG_DUPLEX_MASK     0x000000F0 ///< Mask for accessing duplex bits
#define ETH_PHY_LINK_CONFIG_SPEED_10M       0x00000100 ///< Force speed to 10 Mbps
#define ETH_PHY_LINK_CONFIG_SPEED_100M      0x00000200 ///< Force speed to 100 Mbps
#define ETH_PHY_LINK_CONFIG_SPEED_1G        0x00000400 ///< Force speed to 1 Gbps
#define ETH_PHY_LINK_CONFIG_SPEED_MASK      0x00000F00 ///< Mask for accessing speed bits
//@}

/**
 * @brief Ethernet PHY link status
 * 
 * Current Ethernet PHY status including link up/down state and *resolved* PHY speed and duplex. Use
 * the ETH_PHY_LINK_STATUS_X macros to access the bitfields of this uint32_t.
 */
typedef uint32_t eth_phy_link_status_t;

/**
 * @name Ethernet PHY link status flags
 * 
 * Use these ETH_PHY_LINK_STATUS_X macros to access the bitfields of eth_phy_link_status_t. The
 * ETH_PHY_LINK_STATUS_UP flag indicates that a link has been established and the PHY can
 * communicate over the attached network at the speed and duplex mode indicated by the 
 * ETH_PHY_LINK_STATUS_SPEED_X and ETH_PHY_LINK_STATUS_DUPLEX_X flags, respectively.
 */
#define ETH_PHY_LINK_STATUS_UP              0x00000001 
#define ETH_PHY_LINK_STATUS_DUPLEX_HALF     0x00000010
#define ETH_PHY_LINK_STATUS_DUPLEX_FULL     0x00000020
#define ETH_PHY_LINK_STATUS_DUPLEX_MASK     0x000000F0
#define ETH_PHY_LINK_STATUS_SPEED_10M       0x00000100
#define ETH_PHY_LINK_STATUS_SPEED_100M      0x00000200
#define ETH_PHY_LINK_STATUS_SPEED_1G        0x00000400
#define ETH_PHY_LINK_STATUS_SPEED_MASK      0x00000F00
//@}

/**
 * @brief Ethernet PHY device handle
 *
 * Device handle generated by eth_phy_open() used to reference the physical Ethernet PHY device in
 * successive API calls.
 */
typedef struct eth_phy_context_s *eth_phy_handle_t;

/**
 * @brief MDIO read function pointer
 * 
 * @param phy_addr PHY address (0-31) indicating the physical PHY device targeted by the MDIO
 *                 operation.
 * @param reg_addr PHY register address (0-31) targeted by the MDIO operation.
 *  
 * @param data The 16-bit value read from the PHY register. 
 *  
 * @retval Ethernet MAC return code
 * 
 * Function pointer provided by the overlying Ethernet MAC driver used to read from a 16-bit PHY
 * register over the MDIO interface.
 */
typedef eth_mac_rcode_t (*eth_phy_mdio_read_func_t)(uint8_t phy_addr, uint8_t reg, uint16_t *data);

/**
 * @brief MDIO write function pointer
 * 
 * @param phy_addr PHY address (0-31) indicating the physical PHY device targeted by the MDIO
 *                 operation.
 * @param reg_addr PHY register address (0-31) targeted by the MDIO operation.
 * @param data The 16-bit value to be written to the PHY register.
 * 
 * Function pointer provided by the overlying Ethernet MAC driver used to write to a 16-bit PHY
 * register over the MDIO interface.
 */
typedef eth_mac_rcode_t (*eth_phy_mdio_write_func_t)(uint8_t phy_addr, uint8_t reg_addr, uint16_t data);

/**
 * @brief MDIO interface
 * 
 * Dispatch table populated by the overlying Ethernet MAC driver for accessing PHY management data
 * I/O (MDIO) registers as defined by IEEE 802.3-2008 clause 22 (section 22.2.4)
 */
typedef struct 
{
    eth_phy_mdio_read_func_t read; ///< MDIO read function pointer
    eth_phy_mdio_write_func_t write; ///< MDIO write function pointer
} eth_phy_mdio_t;

/**
 * @brief Link status notify function pointer
 *  
 * @param user_data The opaque user-defined data associated with this callback during the
 *                  call to eth_phy_register_link_notify().
 *  
 * This user-defined callback function is registered by the user via
 * eth_phy_register_link_notify() and is called by the PHY driver to notify the user
 * of a change in link status.  The callback may be called by the PHY driver from the 
 * context of an ISR, so processing from the callback must be kept to a minimum.
 * 
 * In response to this callback, the user will typically retrieve details about the link 
 * status change by calling eth_phy_get_link_status(). However this call must be made in a
 * separate thread context since the callback itself may be executing in an ISR context. 
 */
typedef void (*eth_phy_isr_link_notify_func_t)(void *user_data);

/**
 * @brief Initialize the Ethernet PHY device driver.
 * 
 * @param[in] mdio Pointer to a dispatch table that has been allocated and populated by the caller.
 *       Upon return, the caller may free the memory allocated for this table.
 * 
 * This routine should be called exactly once following a system startup. It registers the MDIO
 * interface callbacks and performs other initialization tasks.
 */
void eth_phy_init(const eth_phy_mdio_t *mdio);

/**
 * @brief Acquire resources for the Ethernet PHY device driver.
 * 
 * @param phy_addr PHY address (0-31) indicating the physical PHY device to be opened.
 * 
 * @param[out] hndl Pointer to storage allocated by caller used to pass back a device handle to be
 *       used in successive API calls to reference the PHY at the given phy_addr.
 * 
 * @retval ETH_PHY_OK success
 * @retval ETH_PHY_FAIL failure
 */
eth_phy_rcode_t eth_phy_open(uint8_t phy_addr, eth_phy_handle_t *hndl);

/**
 * @brief Register for link status change notification
 *  
 * @param notify_func User-defined callback function called by the PHY driver to notify 
 *                    the user of a change in link status. May be called from an ISR
 *                    context.
 *  
 * @param user_data Opaque user-defined data passed back to the user in the callback. 
 *  
 * @param hndl The device handle acquired via eth_phy_open(). 
 *  
 * @retval ETH_PHY_OK success   
 * @retval ETH_PHY_NOT_SUPPORTED The underlying vendor-specific driver does not support 
 *         link status change notification.
 *  
 * Not all PHY device drivers will support link status change notification. In that case, 
 * changes to link status must be detected at a higher layer e.g. via MAC driver ISR or a 
 * polling mechanism. 
 */
eth_phy_rcode_t eth_phy_register_link_notify(eth_phy_isr_link_notify_func_t notify_func, void *user_data,
                                             eth_phy_handle_t hndl);

/**
 * @brief Free device resources.
 * 
 * @param hndl The device handle acquired via eth_phy_open().
 */
void eth_phy_close(eth_phy_handle_t hndl);

/**
 * @brief Get current link status.
 * 
 * @param hndl The device handle acquired via eth_phy_open().
 * 
 * @param[out] status Pointer to storage allocated by caller used to pass back the current link
 *       status.
 * 
 * @retval ETH_PHY_OK success
 * @retval ETH_PHY_FAIL failure
 * @retval ETH_PHY_HW_ERR the PHY is unresponsive
 * 
 * Retrieve current Ethernet PHY status information including link up/down state and *resolved* PHY
 * speed and duplex.  Note the distinction between PHY link status retrieved using this routine vs.
 * the PHY link configuration method retrieved using eth_phy_get_link_config().
 */
eth_phy_rcode_t eth_phy_get_link_status(eth_phy_handle_t hndl, eth_phy_link_status_t *status);

/**
 * @brief Get the link configuration method.
 * 
 * @param hndl The device handle acquired via eth_phy_open().
 * 
 * @param[out] link_config Pointer to storage allocated by caller used to pass back the current link
 *       configuration method.
 * 
 * @retval ETH_PHY_OK success
 * @retval ETH_PHY_FAIL failure
 * @retval ETH_PHY_HW_ERR the PHY is unresponsive
 * 
 * Retrieve the method by which the Ethernet PHY will attempt to configure itself and acquire link
 * status (e.g. auto-negotiation vs. forced speed and duplex).  Note the distinction between
 * the link configuration method retrieved using this routine vs. link status retrieved using
 * eth_phy_get_link_status().
 */
eth_phy_rcode_t eth_phy_get_link_config(eth_phy_handle_t hndl, eth_phy_link_config_t *link_config);

/**
 * @brief Set the link configuration method.
 * 
 * @param hndl The device handle acquired via eth_phy_open().
 * 
 * @param[in] link_config Pointer to storage that has been populated by caller with the desired link
 *       configuration method.  Upon return, this storage may be freed by the caller.
 * 
 * @retval ETH_PHY_OK success
 * @retval ETH_PHY_FAIL failure
 * @retval ETH_PHY_HW_ERR the PHY is unresponsive
 * 
 * Updates the method by which the Ethernet PHY will attempt to configure itself and acquire link
 * status (e.g. auto-negotiation vs. forced speed and duplex).
 */
eth_phy_rcode_t eth_phy_set_link_config(eth_phy_handle_t hndl, const eth_phy_link_config_t *link_config);

#ifdef HAVE_POWER_MGR
/**
 * PHY power management
 */
bool eth_phy_power_save(eth_phy_handle_t hndl, pwr_mgr_level_t level, pwr_mgr_cmd_t cmd);
#endif // HAVE_POWER_MGR

#endif // ETH_PHY_API_H

//eof
