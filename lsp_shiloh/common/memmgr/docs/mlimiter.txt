/****************************************************************************** 
 * Copyright (c) 2009-2010  Marvell International, Ltd. All Rights Reserved
 *
 *                         Marvell Confidential
 *
 * @file mlimiter.txt
 ******************************************************************************/ 

A memory heap limiter is used to put an artificial cap on a heap such that
perceived heap size is less than actual physical heap size.  

Multiple limiters can be attached to a single heap, and the artificial caps
imposed by these limiters effectively create a set of virtual memory pools.
Whereas a heap is a pool of static, contiguous, physical blocks of memory,
limiters are virtual pools of memory physically interleaved with other limiters
attached to the same heap.

Limiters may be activated and deactivated via mlimiter_start() and mlimiter_stop(),
respectively. The size of each limiter's virtual memory pool is dynamic and will
fluctuate at run time as other limiters within the same heap are activated and
deactivated.  When a limiter is activated, the virtual memory pools of siblings
may need to be reduced to acquire memory for a new pool.  When a limiter is
deactivated, the virtual memory pools of siblings may increase.

A single limiter may not use more memory than the base heap has
available at limiter construction time.  If multiple limiters are
playing in the same heap it is possible that the sum of the limiters
highest_max's will be larger than the base heap's size.  Allocations 
will be limited by the base heap at all times but maybe limited by the 
limiter first.  

A null or 0 limiter will actually use the default sysLimiter attached
to the default sysHeap, MEM_MALLOC() does this.

Multiple heaps are only supported at system initialization time, the
second or third heap constructed will immediately allocate and free a
single large alloction of heap size.  Heaps cannot be freed.  The
embedded memory manager has no way to return memory to the system
there is no MMU and no page mapping so large allocations are by there
very nature capable of causing fragmentation.  It is much better to
make more smaller allocations than a single large allocation.  Strip
buffers are better than page buffers for instance.

A parent limiter is the base heap it's mlimiter->parent pointer will be null.
The mlimiter->lowest_max for a parent is the reserve that no child has access to.
A child limiter has a mlimiter->parent pointer that is not null.  The max 
memory available to any child will always leave room for the parents reserve.
The sum of the lowest_max sizes should be less than the total system/heap memory.

A limiter will never be given more than its highest_max, or less than its 
lowest_max. A limiter that is inactive can still have memory, normally this is 
memory that will be freed, new allocations are discouraged on inactive limiters.
Setting the highest_max and lowest_max to be the same implies a fixed allocation.


Relationships:
=============

All limiters must be assigned to a heap.  A singe heap may contain multiple limiters.  

Limiters have parent child relationships, but the tree can only be two levels deep.

Available memory for children equals parent "max" minus parent reserve, or "lowest_max",
minus current parent allocations.  This calculation is made any time a child limiter
is activated or deactivated.

Total of the "lowest_max" values for all *active* limiters in a heap must be <= total
heap memory (after deducting parent lowest_max and current allocations).  This
constraint must be achieved through user configuration and tuning.

The parent child relationship is with regard to the "max" values.  "max" values of
children are subsets of the "max" value of the parent.  This means that the parent
limiter's virtual memory pool encapsulates all child memory pools, and the parent
can consume memory that was assigned to a child (including a child's reserve or "l_max"
memory).  Ideally the parent should never exceed its reserve, or "lowest_max" value.


Serial Debug Parameters:
=======================

The following parameters are generated by the "memory limit" serial debug command:

"max" -- (i.e. temporal maximum) current size of the limiter's virtual memory pool, or
     the total memory currently available to the limiter.  This is the "artificial cap"
     referred to above.
"current" -- current amount of memory allocated by the limiter.  Total of all memory
     allocations for the limiter
"l_max" -- (i.e. lowest_max) minimum amount of memory guaranteed to be available to
     the limiter.  Set by user during limiter config.
"h_max" -- (i.e. highest_max) maximum amount of memory required by the limiter.  Set
     by user during limiter config.


Notes:
=====

In Unity, "sysLimiter" is the parent limiter attached to the default sysHeap, and
MEM_MALLOC() uses sysLimiter by default.

Rebalancing of availiable memory between active limiters happens when 
mlimiter_start or mlimiter_stop is called.  This will readjust the max limits based
on the following rules:

Always preserve the parents Reserve:
memory avail > sysLimiter->lowest_max + for 2-n limiters->max

Don't give a limiter less than its lowest_max
if active then limiters->max >= limiters->lowest_max

Don't give a limiter more than its highest_max
if active then limiters->max <= limiters->highest_max

for 1-n limiters->current is always equal to the 

An inactive limiter shouldn't allocate if it does it runs a 
high risk of running out of memory.  Inactive limiters give up 
the memory they arent using to active limiters on every rebalance.




Example three heap system with 4 limiters.

1) Uncached memory heap this memory is not cached and is intended to 
   be used for dma transfers.
2) jbig buffer pool.
3) Print and system memory pool.

1 and 2 have limiters set to the entire heap.
3 has the print limiter set to less than the entire heap.
The system limiter is set to 3's heap so that when print runs out of 
memory there is enough left.

All allocations from the print limiter are expected to tolerate a null 
return at any time.  An out of memory can trigger racing, or other 
strategies to free up memory so that print can continue.  

Allocations from 1), 2) and the system limiter are expected to successful,
failure often indicates a fatal error and that tuning needs to occur.

ASSERT( p = malloc() ) 
  verses 
while (0 == (p=malloc())) 
      find_memory_and_retry_strategy();


Example of a 1 heap system with 3 limiters:

1) Print and scan and system memory pool.

Print's max plus scan's max are always less than the system memory pool.
16meg heap, 2meg of system allows 14meg for print and scan limiters.

print_limiter->highest_max = 14;
print_limiter->lowest_max = 3;

scan_limiter->highest_max = 14;
scan_limiter->lowest_max = 8;

This allows print or scan to use all the memory if they are running alone 
but if print starts after scan then the limiters are readjusted.

scan_limiter->max = scan_limiter->highest_max;
print_limiter->max = 0; // isn't running right now and has no allocations.
....
print wants to start adjust both limiters.
scan_limiter->max = 10;
print_limiter->max = 4;

....
scan finishes
scan_limiter->max = 0;
print_limiter->max = print_limiter->highest_max;



Example mlimiter configuration:
     .highest_max = 0x10000,  // upper and lower limit are the same
     .lowest_max  = 0x10000,  
     .strategy = 0,           
This is a fixed amount of memory that the limiter should never exceed, .max will either be:
.max == .lowest_max 
or
.max == .current 
This second case occurs between mlimiter_stop and mlimiter_start calls as the limiter is inactive.
An inactive limiter shouldn't have new allocation requests on it.

