/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors (“Authorized Licensees”).N  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee’s proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below.N  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee’s product to their customers with or
 *  without such third party’s private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications.N  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein.N 
 *N 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *N 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *N 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */


/*
 * File: wfa_ca.c
 *       This is the main program for Control Agent.
 *
 * Revision History:
 *   2006/06/01 -- BETA Release by qhu
 *   2006/06/13 -- 00.02 Release by qhu
 *   2006/06/30 -- 00.10 Release by qhu
 *   2006/07/10 -- 01.00 Release by qhu
 *   2006/09/01 -- 01.05 Release by qhu
 *   2007/01/11 -- 01.10 released by qhu
 *   2007/02/15 -- WMM beta released by qhu, mkaroshi
 *   2007/03/21 -- 01.40 WPA2 and Official WMM Beta release by qhu
 *   2007/04/20 -- 02.00 WPA2 and Official WMM release by qhu
 *   2007/08/15 --  02.10 WMM-Power Save release by qhu
 *   2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *   2007/11/07 -- 02.30 Voice HSO -- qhu
 *      -- on the calls wfaCtrlSend(), the string len is replaced with strlen()
 *   2007/12/10 -- 02.32 update -- qhu
 *   2008/02/11 -- fix the BUG #5, instead of using done/break (suggested), 
 *                 continue is used here. 
 */

#include <stdlib.h>     /* for atoi()*/
#include <string.h>     /* for memset() */
#include "os_headers.h"
//#include "sys_init_api.h"

#include "wfa_debug.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_miscs.h"
#include "wfa_sock.h"
#include "wfa_ca.h"
#include "wfa_agtctrl.h"
#include "wfa_portall.h"
#include "trsocket.h"
#include "tx_api.h"
#include "sigma_interface.h"

extern int xcCmdProcGetVersion(unsigned char *parms);
extern dutCommandRespFuncPtr wfaCmdRespProcFuncTbl[];
extern typeNameStr_t nameStr[];
extern char gRespStr[];

int gSock = -1, tmsockfd, gCaSockfd = -1, xcSockfd; //btSockfd;
int gtgSend, gtgRecv, gtgTransac;
//char gnetIf[32] = "any";
tgStream_t    *theStreams;
long          itimeout = 0;

unsigned short wfa_defined_debug = WFA_DEBUG_ERR | WFA_DEBUG_WARNING | WFA_DEBUG_INFO;
unsigned short dfd_lvl = WFA_DEBUG_DEFAULT | WFA_DEBUG_ERR | WFA_DEBUG_INFO;

int wfa_sigma_ca_main(unsigned int unused)
{
    int nfds;
    struct sockaddr_in servAddr;
    unsigned short servPort, myport; 
    char *servIP=NULL;
    int bytesRcvd;                   
    fd_set sockSet;
    static char cmdName[WFA_BUFF_32];
    int i, isFound = 0, nbytes, tag, ret_status, slen;
    int tmsockfd, cmdLen = WFA_BUFF_1K;
    int maxfdn1;
    static BYTE xcCmdBuf[WFA_BUFF_4K];
    static BYTE caCmdBuf[WFA_BUFF_4K];
    static BYTE pcmdBuf[WFA_BUFF_1K];
    char *pcmdStr = NULL;
    static char respStr[WFA_BUFF_512];
    bool new_command = true;

    // Wait for the rest of the system (especially network)
    //SysWaitForInit();

    wSLEEP(10);

    myport = WFA_SIGMA_CA_PORT; 

    servIP = "127.0.0.1";   // Listen on loopback
    
    servPort = WFA_SIGMA_DUT_PORT;

    tmsockfd = wfaCreateTCPServSock(myport);

    maxfdn1 = tmsockfd + 1;

    FD_ZERO(&sockSet);
    if(gSock == -1)
    {
        if ((gSock = wSOCKET(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
        {
            DPRINT_ERR(WFA_ERR, "socket() failed:  %s", wSOCKET_ERR_TEXT(gSock));
            wEXIT(1);
        }

        wMEMSET(&servAddr, 0, sizeof(servAddr)); 
        servAddr.sin_family      = AF_INET;
        servAddr.sin_addr.s_addr = inet_addr(servIP);
        servAddr.sin_port        = htons(servPort);

        while (wCONNECT(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
        {
            wPRINTF("Sigma CA is waiting for DUT...\n");
            wSLEEP(2);
        }

    }

    for(;;)
    {
        FD_ZERO(&sockSet);
       
        maxfdn1 = 1;

        if(gSock != -1)
        {
            DPRINT_INFO(WFA_OUT, "Sigma CA: Socket with DUT is %x\n", gSock);
            FD_SET(gSock, &sockSet);
            if(maxfdn1 < gSock)
                maxfdn1 = gSock +1; 
        }
       
        if (new_command)
        {
            DPRINT_INFO(WFA_OUT, "Sigma CA now waiting for new command\n");
            gCaSockfd = wfaAcceptTCPConn(tmsockfd);
            DPRINT_INFO(WFA_OUT, "accept new connection from sigma_cmd_handler with socket %x\n", gCaSockfd);

            if(gCaSockfd != -1)
            {
                FD_SET(gCaSockfd, &sockSet);
                if(maxfdn1 < gCaSockfd)
                    maxfdn1 = gCaSockfd +1;
                new_command = false;     
            }
            else
                continue;
        }

        DPRINT_INFO(WFA_OUT, "Sigma CA: maxfdn1 is %x\n", maxfdn1);
        
        if((nfds = wSELECT(maxfdn1, &sockSet, NULL, NULL, NULL)) < 0)
        {
            if(wSOCKET_ERRNO(nfds) == TM_EINTR)
                continue;
            else
                DPRINT_WARNING(WFA_WNG, "select error %s", wSOCKET_ERR_TEXT(gSock));
        }
 
        DPRINT_INFO(WFA_OUT, "new event \n");
#if 0        
        if(FD_ISSET(tmsockfd, &sockSet))
        {
            gCaSockfd = wfaAcceptTCPConn(tmsockfd);
            DPRINT_INFO(WFA_OUT, "accept new connection\n");
            //wPRINTF("Sigma CA: accept new connection \n");
            continue;
        }
#endif   
        if(gCaSockfd > 0 && FD_ISSET(gCaSockfd, &sockSet))
        {
            wMEMSET(xcCmdBuf, 0, WFA_BUFF_4K);
            wMEMSET(gRespStr, 0, WFA_BUFF_512);

            nbytes = wfaCtrlRecv(gCaSockfd, xcCmdBuf); 
            if(nbytes <=0)
            {
                wSHUTDOWN(gCaSockfd, SHUT_WR);
                wCLOSE(gCaSockfd);
                gCaSockfd = -1;
                continue;
            }
    
            /*
             * send back to command line or TM.
             */
            //sleep(1); /* having this is for slowing down unexpected output result on CLI command sometimes */
            wMEMSET(respStr, 0, WFA_BUFF_128);
            wSPRINTF(respStr, "status,RUNNING\r\n");
            wfaCtrlSend(gCaSockfd, (BYTE *)respStr, wSTRLEN(respStr));

            DPRINT_INFO(WFA_OUT, "%s\n", respStr);
            DPRINT_INFO(WFA_OUT, "message %s %d\n", xcCmdBuf, nbytes);
            slen = (int )wSTRLEN((char *)xcCmdBuf);

            DPRINT_INFO(WFA_OUT, "last %x last-1  %x last-2 %x last-3 %x\n", cmdName[slen], cmdName[slen-1], cmdName[slen-2], cmdName[slen-3]);

            xcCmdBuf[slen-3] = '\0';

            if(gSock == -1)
            {
                if ((gSock = wSOCKET(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
                {
                    DPRINT_ERR(WFA_ERR, "socket() failed: %s", wSOCKET_ERR_TEXT(gSock));
                    wEXIT(1);
                }

                wMEMSET(&servAddr, 0, sizeof(servAddr)); 
                servAddr.sin_family      = AF_INET;
                servAddr.sin_addr.s_addr = inet_addr(servIP);
                servAddr.sin_port        = htons(servPort);

                while (wCONNECT(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
                {
                    wPRINTF("Sigma CA is waiting for DUT...\n");
                    wSLEEP(2);
                }
            }

            isFound = 0;
    
            wMEMCPY(cmdName, strtok_r((char *)xcCmdBuf, ",", (char **)&pcmdStr), 32);
            i = 0;
            while(nameStr[i].type != -1)
            {
                if(wSTRCMP(nameStr[i].name, cmdName) == 0)
                {
                    isFound = 1;
                    break;
                }
                i++;
            }

            DPRINT_INFO(WFA_OUT, "%s\n", cmdName);

            if(isFound == 0)
            {
                wSLEEP(1);
                //For commands that we (DUT) do not support, report back a "status,COMPLETE" to the UCC (Unified CAPI Console)
                //as opposed to a "status,INVALID". One eg. for such a command is "sta_preset_testparams" which we are NOT
                //required to support as a DUT. However, if we end up reporting an "invalid", it blocks the test because UCC does not like this 
                //response. Instead, just "lie" and say "status,COMPLETE" so that the test goes through. 

                //wSPRINTF(respStr, "status,INVALID\r\n");
                wSPRINTF(respStr, "status,COMPLETE\r\n");
                wfaCtrlSend(gCaSockfd, (BYTE *)respStr, wSTRLEN(respStr));
                DPRINT_WARNING(WFA_WNG, "Command not valid, check the name\n");
                new_command = true;
                continue;
            }

            wMEMSET(pcmdBuf, 0, WFA_BUFF_1K); 
            if(nameStr[i].cmdProcFunc(pcmdStr, pcmdBuf, &cmdLen)==WFA_FAILURE)
            {
                wSLEEP(1);
                wSPRINTF(respStr, "status,INVALID\r\n");
                wfaCtrlSend(gCaSockfd, (BYTE *)respStr, wSTRLEN(respStr));
                DPRINT_WARNING(WFA_WNG, "Incorrect command syntax\n");
                new_command = true;
                continue;
            }

            /*
             * send to DUT.
             */
            if(wSEND(gSock, pcmdBuf, cmdLen, 0) != cmdLen)
            {
                DPRINT_WARNING(WFA_WNG, "Incorrect sending ...\n");
                continue;
            }

            DPRINT_INFO(WFA_OUT, "sent to DUT\n");
            //sleep(1);
        } /* done with gCaSockfd */

        if(gSock > 0 && FD_ISSET(gSock, &sockSet))
        {
            DPRINT_INFO(WFA_OUT, "received from DUT\n");
            wSLEEP(1);
            wMEMSET(respStr, 0, WFA_BUFF_128);
            wMEMSET(caCmdBuf, 0, WFA_BUFF_4K);
            if ((bytesRcvd = wRECV(gSock, caCmdBuf, WFA_BUFF_4K, 0)) <= 0)
            {
                DPRINT_WARNING(WFA_WNG, "recv() failed or connection closed prematurely");
                continue;
            }
 
//            for(i = 0; i< bytesRcvd; i++)
//               printf("%x ", caCmdBuf[i]);
//               printf("\n");

            tag = ((wfaTLV *)caCmdBuf)->tag;     
          
            wMEMCPY(&ret_status, caCmdBuf+4, 4);
            DPRINT_INFO(WFA_OUT, "bytes=%d, %d,%d,%x %x %x %x \n", bytesRcvd, ((wfaTLV *)caCmdBuf)->tag,((wfaTLV *)caCmdBuf)->len, *(caCmdBuf+4), *(caCmdBuf+5), *(caCmdBuf+6), *(caCmdBuf+7));

            
            if((tag != 0 && tag > WFA_STA_NEW_COMMANDS_RESPONSE_START && tag < WFA_STA_NEW_COMMANDS_RESPONSE_END) && 
                    wfaCmdRespProcFuncTbl[tag - WFA_STA_NEW_COMMANDS_RESPONSE_START + (WFA_STA_COMMANDS_END -1 )] != NULL)
            {
                DPRINT_INFO(WFA_OUT, " Index for wfaCmdRespProcFuncTbl is %d\n", tag - WFA_STA_NEW_COMMANDS_RESPONSE_START + (WFA_STA_COMMANDS_END -1 ));
                wfaCmdRespProcFuncTbl[tag - WFA_STA_NEW_COMMANDS_RESPONSE_START + (WFA_STA_COMMANDS_END -1 )](caCmdBuf);
            } 
            else if((tag != 0 && tag < WFA_STA_RESPONSE_END) && wfaCmdRespProcFuncTbl[tag-WFA_STA_COMMANDS_END] != NULL)
            {
                DPRINT_INFO(WFA_OUT, " Index for wfaCmdRespProcFuncTbl is %d\n", tag-WFA_STA_COMMANDS_END);
                wfaCmdRespProcFuncTbl[tag-WFA_STA_COMMANDS_END](caCmdBuf);
            }
            else
                DPRINT_WARNING(WFA_WNG, "function not defined\n");

            //Close the client socket and wait for a new command
            wCLOSE(gCaSockfd);
            new_command = true;
        } 

    } /* for */

    wCLOSE(gSock);
    return 0;
}
