 
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors (“Authorized Licensees”).N  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee’s proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below.N  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee’s product to their customers with or
 *  without such third party’s private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications.N  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein.N 
 *N 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *N 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *N 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */

/* 
 *   File: wfa_cs.c -- configuration and setup
 *   This file contains all implementation for the dut setup and control 
 *   functions, such as network interfaces, ip address and wireless specific
 *   setup with its supplicant.
 *
 *   The current implementation is to show how these functions
 *   should be defined in order to support the Agent Control/Test Manager 
 *   control commands. To simplify the current work and avoid any GPL licenses,
 *   the functions mostly invoke shell commands by calling linux system call,
 *   system("<commands>"). 
 *
 *   It depends on the differnt device and platform, vendors can choice their
 *   own ways to interact its systems, supplicants and process these commands
 *   such as using the native APIs.
 *
 *   Revision History:
 *        2006/03/10  -- initially created by qhu
 *        2006/06/01  -- BETA Release by qhu
 *        2006/06/13  -- 00.02 Release by qhu
 *        2006/06/30  -- 00.10 Release by qhu
 *        2006/07/10  -- 01.00 Release by qhu
 *        2006/09/01  -- 01.05 Release by qhu
 *        2006/10/26  -- 01.06 Released by qhu
 *                       replace hardcoded buf size with macro
 *        2006/12/02  -- bugs: 1. fixes incorrect order of getipconfig.sh
 *                                input parameters reported by p.schwann
 *                             2. will add a new network for wap_cli command
 *                                in case the network id 0 not present,
 *                                recommended by c.benson
 *                                the solution is to reimplement with calling
 *                                native C API
 *        2007/01/11  -- 01.10 released by qhu
 *        2007/02/15  -- WMM Extension Beta released by qhu, mkaroshi
 *        2007/03/18  -- add file close statements
 *        2007/03/21  -- rename the file to avoid the confusion.
 *        2007/03/30  -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *        2007/04/20  -- 02.00 WPA2 and Official WMM Release by qhu
 *        2007/08/15 --  02.10 WMM-Power Save release by qhu
 *        2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *        2007/11/07 --  02.30 Voice HSO -- qhu
 *        2007/12/10 --  02.32 Add a function to upload test results.
 *        2008/01/03 --  02.34 Support the result upload command.
 *        2008/03/12 --  02.41 Bug #16, incorrect file descriptor used. Change 
 *                       the "tmpfile" to "tmpfd" and a few places. Make a macro
 *                       WFA_STAUT_IF in file "inc/wfa_cs.h" for WLAN interface
 *                       name in the function "wfaDeviceListIF()
 *                      
 *                       Not A Bug. Put back to the function from 
 *                       wfaSetEncryption1() to wfaSetEncryption() for 
 *                       supporting WEP. Porting could select which should be 
 *                       used according to WEP support or not.
 *                        
 *        
 */ 
#include <string.h>
#include <stdlib.h>


#include "wfa_portall.h"
#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_ca.h"
#include "wfa_tlv.h"
#include "wfa_sock.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_rsp.h"
#include "wfa_utils.h"
#ifdef WFA_WMM_PS_EXT
#include "wfa_wmmps.h"
#endif

#include "ATypes.h"
#include "wlanInterface.h"
#include "net_iface_vars.h"
#include "wifi_intf_vars.h"
#include "wifi_intf.h"
#include "trsocket.h"
#include "sigma_interface.h"
#include "wifi_intf_event_api.h"
#include "wifi_intf_link_api.h"
#include "platform.h" //for SYS_TICK_FREQ
#include "mlan_decl.h"
#include "wps_def.h"
#include "model_info.h"

#define CERTIFICATES_PATH    "/etc/wpa_supplicant"

/* Some device may only support UDP ECHO, activate this line */
//#define WFA_PING_UDP_ECHO_ONLY 1

extern unsigned short wfa_defined_debug;


/* Since the two definitions are used all over the CA function */
char gCmdStr[WFA_CMD_STR_SZ];
dutCmdResponse_t gGenericResp;
int wfaTGSetPrio(int sockfd, int tgClass);
void create_apts_msg(int msg, unsigned int txbuf[],int id);

//WPS Pin entered through sta_wps_enter_pin command is stored here
//static char *g_wps_pin = NULL;

extern char e2eResults[];
//extern char *e2eResults;
//FILE *e2efp = NULL;

#if 0
int chk_ret_status()
{
    char *ret = getenv(WFA_RET_ENV);

    if(*ret == '1')
       return WFA_SUCCESS;
    else
       return WFA_FAILURE;
}
#endif

/*
 * agtCmdProcGetVersion(): response "ca_get_version" command to controller
 *  input:  cmd --- not used
 *          valLen -- not used
 *  output: parms -- a buffer to store the version info response.
 */
int agtCmdProcGetVersion(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *getverResp = &gGenericResp;

    DPRINT_INFO(WFA_OUT, "entering agtCmdProcGetVersion ...\n");

    getverResp->status = STATUS_COMPLETE;
    wSTRNCPY(getverResp->cmdru.version, WFA_SYSTEM_VER, WFA_VERNAM_LEN);

    wfaEncodeTLV(WFA_GET_VERSION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getverResp, respBuf);

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return WFA_SUCCESS;
}

/*
 * wfaStaAssociate():
 *    The function is to force the station wireless I/F to associate 
 *    with the AP.
 */
int wfaStaAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *staAssocResp = &gGenericResp;
   dutCommand_t *ssid_info = (dutCommand_t *)caCmdBuf;
   caStaAssociate_t *info = &ssid_info->cmdsu.assoc;
#ifdef WFA_NEED_TO_PORT   
   char *wps_pin = NULL;
#endif
   DPRINT_INFO(WFA_OUT, "entering wfaStaAssociate ...\n");
   //wPRINTF("wfaStaAssociate: Attempting to associate with ssid: %s\n and info->wps is %d", info->ssid, info->wps);
   
   //TODO: Implement this portion, once we decide to go for P2P testing
   //For now, ignore the WPS flag

   //If the WPS flag is set, go ahead and associate with the AP through WPS
#ifdef WFA_NEED_TO_PORT   
   if (info->wps)
   {       
       if (g_wps_pin != NULL)
       {
           wPRINTF("wfaStaAssociate: Pin set by user as %s\n", g_wps_pin);
           //If user has previously entered a WPS pin using the "sta_wps_enter_pin" command, use that pin for the WPS connection           
           wifi_intf_start_wps((uint8_t *)info->ssid, wSTRLEN(info->ssid), (uint8_t *)g_wps_pin, wSTRLEN(g_wps_pin));
       }    
       else
       {
           //User has not set a WPS Pin. Generate a WPS and use that for the WPS connection
           wps_pin = generate_wps_pin();
           wPRINTF("wfaStaAssociate: Generated pin is: %s\n", wps_pin);   
           wifi_intf_start_wps((uint8_t *)info->ssid, wSTRLEN(info->ssid), (uint8_t *)wps_pin, wSTRLEN(wps_pin));
       }
       
       //WPS flag is not set. Attempt to associate with the AP normally i.e. set station ssid and enable the station      
       wifi_intf_set_var_ssid(WIFI_IFACE_ID_STATION, (uint8_t*)info->ssid, wSTRLEN(info->ssid) + 1);   
       wifi_intf_set_var_is_enabled(WIFI_IFACE_ID_STATION, true);       
   }    
   else
#endif       
   {       
       //WPS flag is not set. Attempt to associate with the AP normally i.e. set station ssid and enable the station      
       wifi_intf_set_var_ssid(WIFI_IFACE_ID_STATION, (uint8_t*)info->ssid, wSTRLEN(info->ssid) + 1);   
       wifi_intf_set_var_is_enabled(WIFI_IFACE_ID_STATION, true);
   }   

   staAssocResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS; 
}

/*
 * wfaStaReAssociate():
 *    The function is to force the station wireless I/F to reassociate 
 *    with the AP.
 */
int wfaStaReAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *staAssocResp = &gGenericResp;
   bool scanning;
   char scan_bssid[18];
   wifi_intf_scan_info_t *scan_info;
   int i;
   dutCommand_t *bssid_info = (dutCommand_t *)caCmdBuf;
   caStaAssociate_t *info = &bssid_info->cmdsu.assoc;
  
   DPRINT_INFO(WFA_OUT, "entering wfaStaReAssociate ...\n");
   //wPRINTF("wfaStaReAssociate: Attempting to re-associate with bssid: %s\n", info->bssid);

   wifi_intf_get_var_is_wireless_scanning(&scanning);
   while (scanning)
   {
        tx_thread_sleep(10);
        wifi_intf_get_var_is_wireless_scanning(&scanning);
   }

   scan_info = (wifi_intf_scan_info_t *) MEM_MALLOC(sizeof(wifi_intf_scan_info_t));

   if (scan_info != NULL)
   {
        wifi_intf_get_var_scan_info(scan_info);

        for (i=0; i<scan_info->NumSSID; i++)
        {
            wSPRINTF(scan_bssid, "%02x:%02x:%02x:%02x:%02x:%02x", 
                       scan_info->networks[i].BSSID[0],
                       scan_info->networks[i].BSSID[1],
                       scan_info->networks[i].BSSID[2],
                       scan_info->networks[i].BSSID[3],
                       scan_info->networks[i].BSSID[4],
                       scan_info->networks[i].BSSID[5]);

            if (0 == wSTRCMP(scan_bssid, info->bssid))
            {
                //Found an AP with matching BSSID. Set the station ssid to this AP. 
                wifi_intf_set_var_ssid(WIFI_IFACE_ID_STATION, (uint8_t*)scan_info->networks[i].SSIDNames, 
                        wSTRLEN((char *)scan_info->networks[i].SSIDNames) + 1);
                break;
            }            
        }
        MEM_FREE_AND_NULL(scan_info);
   }
    
   //disable and enable station, to associate
   wifi_intf_set_var_is_enabled(WIFI_IFACE_ID_STATION, false);
   wifi_intf_set_var_is_enabled(WIFI_IFACE_ID_STATION, true);

   staAssocResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;; 
}

/*
 * wfaStaIsConnected():
 *    The function is to check whether the station's wireless I/F has 
 *    already connected to an AP.
 */
int wfaStaIsConnected(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staConnectResp = &gGenericResp;
    //uint32_t ipAddrAsInt;
    //error_type_t  status;
    unsigned int if_index = if_nametoindex(NET_IFACE_INTERFACE_NAME);
    bool ipv4_configured = false;

    DPRINT_INFO(WFA_OUT, "Entering isConnected ...\n"); 
    
    // By default, not connected
    staConnectResp->cmdru.connected = 0;

    //During pre-certification for Sigma-11n (v2.0.25), seen cases wherein with certain test-bed APs, 
    //although the DUT associates and gets an IP address after a "sta_set_ipconfig", 
    //for some reason we do not a "Link_Connected" link status on the WLAN side until we 
    //have performed a ping (or force some form of an IP traffic between the DUT and the AP).
    //To deal with such cases, simply report back connected status as "TRUE" if IPv4 has been 
    //configured. During the test, the UCC forces a ping between the DUT and AP to verify if 
    //the connection is alive. At this point, WLAN gets configured correctly and we get a 
    //"Link Connected" state.
    //Observed results with old code: In cases where WLAN never reaches the link connected state, we keep responding
    //with "FALSE". The UCC keeps trying for atleast 6-7 times, before the test fails.  
    //Impact with this change: following the "sta_is_connected" command, the UCC performs a "sta_get_bssid", to which
    //we respond with a bunch of zeroes (since link is not yet connected on WLAN side). This, however,
    //does not break the test and the UCC simply ignores this response and carries on with the test. 

    net_iface_get_var_ipv4_configured(if_index, &ipv4_configured);

    if (ipv4_configured)
    {
        DPRINT_INFO(WFA_OUT, "IPv4 configured ...\n");
            
        // WLAN is reporting 'connected' and IPTask has an IP address -- we're set
        staConnectResp->cmdru.connected = 1;
    }    
    

#if 0    
    if (wifi_intf_sta_get_current_link_status() == Link_Connected )
    {
        status = net_iface_get_var_ipv4_addr(if_index, &ipAddrAsInt);
        ASSERT(status == OK);
        
        if (ipAddrAsInt)
        {
            DPRINT_INFO(WFA_OUT, "Connected and Got valid IP address ...\n");
            
            // WLAN is reporting 'connected' and IPTask has an IP address -- we're set
            staConnectResp->cmdru.connected = 1;
        }
    }
#endif
    
    /*
    * Report back the status: Complete or Failed.
    */
    staConnectResp->status = STATUS_COMPLETE;
    
    wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)staConnectResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
     

   return WFA_SUCCESS;
}

/*
 * wfaStaGetIpConfig():
 * This function is to retriev the ip info including
 *     1. dhcp enable
 *     2. ip address
 *     3. mask 
 *     4. primary-dns
 *     5. secondary-dns
 *
 *     The current implementation is to use a script to find these information
 *     and store them in a file. 
 */
int wfaStaGetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int slen;  
    dutCmdResponse_t *ipconfigResp = &gGenericResp; 
    caStaGetIpConfigResp_t *ifinfo = &ipconfigResp->cmdru.getIfconfig;
    net_iface_ipv4_config_options_t net_flags;
    uint32_t ipAddrAsInt, subnetMaskAsInt;
    unsigned int if_index = if_nametoindex(NET_IFACE_INTERFACE_NAME);
    error_type_t  status;

    /* find out the ip address */
    status = net_iface_get_var_ipv4_addr(if_index, &ipAddrAsInt);
    ASSERT(status == OK);

    if(ipAddrAsInt)
    {
       // convert to string
       tfInetToAscii(ipAddrAsInt, ifinfo->ipaddr);
    }
    else
    {    
       wSTRNCPY(ifinfo->ipaddr, "none", 15);
    }

    /* check dhcp enabled */
    status = net_iface_get_var_ipv4_config_options(if_index, &net_flags);
    ASSERT(status == OK);

    if(net_flags & NET_IFACE_IPV4_USE_DHCP)
       ifinfo->isDhcp = 1;
    else
       ifinfo->isDhcp = 0;

    /* check the mask */
    status = net_iface_get_var_ipv4_subnet_mask(if_index, &subnetMaskAsInt);
    ASSERT(status == OK);

    if(subnetMaskAsInt)
    {
        tfInetToAscii(subnetMaskAsInt, ifinfo->mask);
        slen = wSTRLEN(ifinfo->mask);
    }
    else
    {    
        wSTRCPY(ifinfo->mask, "none");
    }

    // Acquire the primary and secondary DNS servers
    wSTRCPY(ifinfo->dns[0], "none");
    wSTRCPY(ifinfo->dns[1], "none");
    net_iface_get_var_dns_server_addr(if_index, 0, &ipAddrAsInt);
    if (ipAddrAsInt != 0)
    {
        tfInetToAscii( ipAddrAsInt, ifinfo->dns[0] );
        net_iface_get_var_dns_server_addr(if_index, 1, &ipAddrAsInt);
        if (ipAddrAsInt != 0)
        {
            tfInetToAscii( ipAddrAsInt, ifinfo->dns[1] );
        }
    }    
    
    /*
     * Report back the results
     */
    ipconfigResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
    
    return WFA_SUCCESS;
}

/*
 * wfaStaSetIpConfig():
 *   The function is to set the ip configuration to a wireless I/F.
 *   1. IP address
 *   2. Mac address
 *   3. default gateway
 *   4. dns nameserver (pri and sec).  
 */
int wfaStaSetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *setIpConf = (dutCommand_t *)caCmdBuf;
    caStaSetIpConfig_t *ipconfig = &setIpConf->cmdsu.ipconfig;
    dutCmdResponse_t *staSetIpResp = &gGenericResp;
    unsigned int if_index = if_nametoindex(NET_IFACE_INTERFACE_NAME);
    net_iface_ipv4_config_options_t net_flags;

    DPRINT_INFO(WFA_OUT, "entering wfaStaSetIpConfig ...\n");

    if (ipconfig->isDhcp)
    {
        net_flags = NET_IFACE_IPV4_USE_DHCP;
    }
    else
    {
        uint32_t manual_addr;

        net_flags = NET_IFACE_IPV4_USE_MANUAL;

        //IP address
        manual_addr = inet_aton(ipconfig->ipaddr);
        net_iface_set_var_ipv4_manual_addr(if_index, &manual_addr);

        //Subnet mask
        manual_addr = inet_aton(ipconfig->mask);
        net_iface_set_var_ipv4_manual_subnet_mask(if_index, &manual_addr);

        //Default gateway
        manual_addr = inet_aton(ipconfig->defGateway);
        net_iface_set_var_ipv4_manual_gateway(if_index, &manual_addr);

        //Primary DNS
        manual_addr = inet_aton(ipconfig->pri_dns);
        net_iface_set_var_manual_dns_addr(if_index, 0, &manual_addr);

        //Seconday DNS
        manual_addr = inet_aton(ipconfig->sec_dns);
        net_iface_set_var_manual_dns_addr(if_index, 1, &manual_addr);
    }

    net_iface_set_var_ipv4_config_options(if_index, &net_flags);
   
    /*
     * report status
     */
    staSetIpResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

/**
 * \brief  callback for the ping response
 *
 */
static int pingSucceeded = FALSE;
static void sigma_ping_callback( int sock )
{
    pingSucceeded = TRUE;
}

/**
 * \brief  Send a ping using Treck TCP/IP stack's API.
 * 
 * This routine doesn't worry about statistics.  It just
 * verifies that a ping can go through.  Once it sees one
 * succeed, it quits
 * 
 */
int sigma_do_ping( char *host, int timeout )
{
    int sock;
    int retcode;
    char *errptr;

    wPRINTF("pinging \"%s\"\n", host );

    pingSucceeded = FALSE;

    sock = tfPingOpenStart( host, 0, 0, sigma_ping_callback );
    if( sock == TM_SOCKET_ERROR ) {
        retcode = tfGetSocketError( sock );
        errptr = tfStrError( retcode );
        wPRINTF("DBGNET: ping could not open socket : %s\n", errptr);
        return pingSucceeded;
    }

    // Block the calling task waiting for any responses
    if (timeout == 0)
    {
        timeout = 5;
    }
    wPRINTF("ping sleeping for up to %d seconds waiting for responses\n", timeout);
    while (!pingSucceeded && (timeout > 0))
    {
        // Wait for one second
        tx_thread_sleep( SYS_TICK_FREQ );
        timeout--;
    }

    wPRINTF("closing ping socket\n" );
    retcode = tfPingClose( sock );

    /* ignore error */
    return pingSucceeded;
}


/*
 * wfaStaVerifyIpConnection():
 * The function is to verify if the station has IP connection with an AP by
 * send ICMP/pings to the AP.
 */ 
int wfaStaVerifyIpConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *verip = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *verifyIpResp = &gGenericResp;

    if (sigma_do_ping(verip->cmdsu.verifyIp.dipaddr, verip->cmdsu.verifyIp.timeout))
        verifyIpResp->cmdru.connected = 1;
    else
        verifyIpResp->cmdru.connected = 0;

    verifyIpResp->status = STATUS_COMPLETE;

    wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)verifyIpResp, respBuf);   

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
    
   
#ifdef WFA_NEED_TO_PORT	
    dutCommand_t *verip = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *verifyIpResp = &gGenericResp;

#ifndef WFA_PING_UDP_ECHO_ONLY
    char strout[64], *pcnt;
    FILE *tmpfile;

    DPRINT_INFO(WFA_OUT, "Entering wfaStaVerifyIpConnection ...\n");

    /* set timeout value in case not set */
    if(verip->cmdsu.verifyIp.timeout <= 0)
    {
        verip->cmdsu.verifyIp.timeout = 10;
    }

    /* execute the ping command  and pipe the result to a tmp file */
    wSPRINTF(gCmdStr, "ping %s -c 3 -W %u | grep loss | cut -f3 -d, 1>& /tmp/pingout.txt", verip->cmdsu.verifyIp.dipaddr, verip->cmdsu.verifyIp.timeout);
    system(gCmdStr); 


    /* scan/check the output */
    tmpfile = fopen("/tmp/pingout.txt", "r+");
    if(tmpfile == NULL)
    {
        verifyIpResp->status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
        *respLen = WFA_TLV_HDR_LEN + 4;

        DPRINT_ERR(WFA_ERR, "file open failed\n");
        return WFA_FAILURE;
    }

    verifyIpResp->status = STATUS_COMPLETE;

    if(fscanf(tmpfile, "%s", strout) == EOF)
        verifyIpResp->cmdru.connected = 0;
    else
    {
        pcnt = strtok(strout, "%"); 

        /* if the loss rate is 100%, not able to connect */
        if(atoi(pcnt) == 100)
            verifyIpResp->cmdru.connected = 0;
        else
            verifyIpResp->cmdru.connected = 1;
    }

    fclose(tmpfile);
#else
    int btSockfd;
    struct pollfd fds[2];
    int timeout = 2000;
    char anyBuf[64];
    struct sockaddr_in toAddr;
    int done = 1, cnt = 0, ret, nbytes;

    verifyIpResp->status = STATUS_COMPLETE;
    verifyIpResp->cmdru.connected = 0;

    btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);

    if(btSockfd == -1)
    {
        verifyIpResp->status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
        *respLen = WFA_TLV_HDR_LEN + 4;
        return WFA_FAILURE;;
    }

    toAddr.sin_family = AF_INET;
    toAddr.sin_addr.s_addr = inet_addr(verip->cmdsu.verifyIp.dipaddr);
    toAddr.sin_port = htons(WFA_UDP_ECHO_PORT);

    while(done)
    {
        wfaTrafficSendTo(btSockfd, (char *)anyBuf, 64, (struct sockaddr *)&toAddr);
        cnt++;

        fds[0].fd = btSockfd;
        fds[0].events = POLLIN | POLLOUT; 

        ret = poll(fds, 1, timeout);
        switch(ret)
        {
            case 0:
                /* it is time out, count a packet lost*/
                break;
            case -1:
                /* it is an error */
            default:
                {
                    switch(fds[0].revents)
                    {
                        case POLLIN:
                        case POLLPRI:
                        case POLLOUT:
                            nbytes = wfaTrafficRecv(btSockfd, (char *)anyBuf, (struct sockaddr *)&toAddr);
                            if(nbytes != 0)
                                verifyIpResp->cmdru.connected = 1;
                            done = 0;
                            break;
                        default:
                            /* errors but not care */
                            ;
                    } 
                }
        } 
        if(cnt == 3)
        {
            done = 0;
        }
    }
#endif
    wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)verifyIpResp, respBuf);   

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
#endif   
    return WFA_SUCCESS;
}

/*
 * wfaStaGetMacAddress()
 *    This function is to retrieve the MAC address of a wireless I/F.
 */
int wfaStaGetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *getmacResp = &gGenericResp;
    uint8_t macOnBoard[MAC_ADDR_LENGTH];

    DPRINT_INFO(WFA_OUT, "Entering wfaStaGetMacAddress ...\n");

    wifi_intf_get_var_mac_addr(0, macOnBoard, MAC_ADDR_LENGTH);

    wSPRINTF(getmacResp->cmdru.mac, "%02X:%02X:%02X:%02X:%02X:%02X", macOnBoard[0], macOnBoard[1], 
                                                                     macOnBoard[2], macOnBoard[3], 
                                                                     macOnBoard[4], macOnBoard[5]);
    getmacResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getmacResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
  
    return WFA_SUCCESS;
}

/*
 * wfaStaGetStats():
 * The function is to retrieve the statistics of the I/F's layer 2 txFrames, 
 * rxFrames, txMulticast, rxMulticast, fcsErrors/crc, and txRetries.
 * Currently there is not definition how to use these info. 
 */
int wfaStaGetStats(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *statsResp = &gGenericResp;

    /* this is never used, you can skip this call */

    statsResp->status = STATUS_ERROR;
    wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)statsResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return WFA_SUCCESS;
}

/*
 * wfaSetEncryption():
 *   The function is to set the wireless interface with WEP or none.
 *
 *   Since WEP is optional test, current function is only used for 
 *   resetting the Security to NONE/Plaintext (OPEN). To test WEP, 
 *   this function should be replaced by the next one (wfaSetEncryption1())
 *
 *   Input parameters: 
 *     1. I/F
 *     2. ssid
 *     3. encpType - wep or none
 *     Optional:
 *     4. key1
 *     5. key2
 *     6. key3
 *     7. key4
 *     8. activeKey Index
 */

int wfaSetEncryption(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
    dutCmdResponse_t *setEncrypResp = &gGenericResp;
    wifi_intf_security_mode_t sec_mode;
    wifi_intf_wep_auth_mode_t auth_mode;
    int i; 
     
    DPRINT_INFO(WFA_OUT, "Entering wfaSetEncryption1 ...\n");

    //Set the ssid 
    wifi_intf_set_var_ssid(WIFI_IFACE_ID_STATION, (uint8_t*)setEncryp->ssid, wSTRLEN(setEncryp->ssid) + 1); 

    //Set Security
    if(setEncryp->encpType == ENCRYPT_WEP)
    {
        //Set security as WEP and authentication mode as open
        sec_mode = WEP;
        auth_mode = AUTH_OPEN;

        wifi_intf_set_var_sec_mode(WIFI_IFACE_ID_STATION, sec_mode);
        wifi_intf_set_var_wep_auth_mode(WIFI_IFACE_ID_STATION, auth_mode);

        //Set Wep current Key, activeKeyIdx is 1-based while we deal with 0-based indexes
        wifi_intf_set_var_wep_cur_key(WIFI_IFACE_ID_STATION, setEncryp->activeKeyIdx - 1);
        
        //Set Wep keys
        for(i=0; i<4; i++)
        {
            if(setEncryp->keys[i][0] != '\0')
            {
                wifi_intf_set_var_wep_key(WIFI_IFACE_ID_STATION, i, (uint8_t*)setEncryp->keys[i], wSTRLEN(setEncryp->keys[i]) + 1);
                wifi_intf_set_var_wep_key_len(WIFI_IFACE_ID_STATION, wSTRLEN(setEncryp->keys[i]));                 
            }
        }
    }
    else /* Open system */
    {
        sec_mode = OPEN_SYSTEM;
        wifi_intf_set_var_sec_mode(WIFI_IFACE_ID_STATION, sec_mode);
    }

    
    setEncrypResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    
    return WFA_SUCCESS;
}


int wfaStaSetSecurity(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int ret = WFA_SUCCESS;

    return ret;
}

/*
 * wfaStaSetEapTLS():
 *   This is to set
 *   1. ssid
 *   2. encrypType - tkip or aes-ccmp
 *   3. keyManagementType - wpa or wpa2
 *   4. trustedRootCA
 *   5. clientCertificate
 */
int wfaStaSetEapTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *setEapTlsResp = &gGenericResp;
#ifdef HAVE_WPA_ENTERPRISE	
    caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
    char *ifname = setTLS->intf;
   
    DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapTLS ...\n");

    /*
     * need to store the trustedROOTCA and clientCertificate into a file first.
     */
#ifdef WFA_NEW_CLI_FORMAT
    wSPRINTF(gCmdStr, "wfa_set_eaptls -i %s %s %s %s", ifname, setTLS->ssid, setTLS->trustedRootCA, setTLS->clientCertificate);
    system(gCmdStr);
#else

    wSPRINTF(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    system(gCmdStr);

    /* ssid */
    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTLS->ssid);
    system(gCmdStr);

    /* key management */
    if(wSTRCASECMP(setTLS->keyMgmtType, "wpa2-sha256") == 0)
    {
    }
    else if(wSTRCASECMP(setTLS->keyMgmtType, "wpa2-eap") == 0)
    {
    }
    else if(wSTRCASECMP(setTLS->keyMgmtType, "wpa2-ft") == 0)
    {

    }
    else if(wSTRCASECMP(setTLS->keyMgmtType, "wpa") == 0)
    {
        wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    }
    else if(wSTRCASECMP(setTLS->keyMgmtType, "wpa2") == 0)
    {
        // to take all and device to pick any one supported.
    }
    else
    {
        // ??
    }
    ////system(gCmdStr);

    /* protocol WPA */
    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 eap TLS", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s\"'", ifname, setTLS->trustedRootCA);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"wifi-user@wifilabs.local\"'", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 private_key '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTLS->clientCertificate);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 private_key_passwd '\"wifi\"'", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    system(gCmdStr);
#endif    
#endif
   
    //Note: We do not support WPA2-Enterprise. So if this command is issued, simply return a 
    // "STATUS_COMPLETE" TLV response
    setEapTlsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    
    return WFA_SUCCESS;
}

/*
 * The function is to set 
 *   1. ssid
 *   2. passPhrase
 *   3. keyMangementType - wpa/wpa2
 *   4. encrypType - tkip or aes-ccmp
 */
int wfaStaSetPSK(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
    dutCmdResponse_t *setPskResp = &gGenericResp;
    wifi_intf_security_mode_t sec_mode = OPEN_SYSTEM;
    wifi_intf_wpa_encryp_mode_t wpa_enc_mode;

    //Set station ssid
    wifi_intf_set_var_ssid(WIFI_IFACE_ID_STATION, (uint8_t*)setPSK->ssid, wSTRLEN(setPSK->ssid) + 1);
    
    //Set wpa passphrase
    wifi_intf_set_var_wpa_passphrase(WIFI_IFACE_ID_STATION, setPSK->passphrase, wSTRLEN((char *)setPSK->passphrase) + 1);

    //Set wpa encryption mode
    wpa_enc_mode = setPSK->encpType ? WPA_TKIP : WPA_AES;
    wifi_intf_set_var_wpa_encryp_mode (WIFI_IFACE_ID_STATION, wpa_enc_mode);

    /*Set the security mode*/
    if (wSTRCASECMP(setPSK->keyMgmtType, "wpa") == 0)
        sec_mode = WPA_PSK;
    else if (wSTRCASECMP(setPSK->keyMgmtType, "wpa2") == 0)    
        sec_mode = WPA2_PSK;
    
    wifi_intf_set_var_sec_mode(WIFI_IFACE_ID_STATION, sec_mode); 

    setPskResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;
    
    return WFA_SUCCESS; 
}

/*
 * wfaStaGetInfo(): 
 * Get vendor specific information in name/value pair by a wireless I/F.
 */
int wfaStaGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t infoResp;
    dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;

    /*
     * Normally this is called to retrieve the vendor information
     * from a interface, no implement yet
     */
    wSPRINTF(infoResp.cmdru.info, "interface,%s,vendor,XXX,cardtype,802.11a/b/g", getInfo->intf);

    infoResp.status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

    return WFA_SUCCESS;
}

/*
 * wfaStaSetEapTTLS():
 *   This is to set
 *   1. ssid
 *   2. username
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyManagementType - wpa or wpa2
 *   6. trustedRootCA
 */
int wfaStaSetEapTTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *setEapTtlsResp = &gGenericResp;
#ifdef HAVE_WPA_ENTERPRISE
    caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
    char *ifname = setTTLS->intf;
    
#ifdef WFA_NEW_CLI_FORMAT
    wSPRINTF(gCmdStr, "wfa_set_eapttls %s %s %s %s %s", ifname, setTTLS->ssid, setTTLS->username, setTTLS->passwd, setTTLS->trustedRootCA);
    system(gCmdStr);
#else

    wSPRINTF(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTTLS->ssid);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setTTLS->username);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setTTLS->passwd);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    system(gCmdStr);

    /* This may not need to set. if it is not set, default to take all */
    //   wSPRINTF(cmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"", ifname, setTTLS->encrptype);
    if(wSTRCASECMP(setTTLS->keyMgmtType, "wpa2-sha256") == 0)
    {
    }
    else if(wSTRCASECMP(setTTLS->keyMgmtType, "wpa2-eap") == 0)
    {
    }
    else if(wSTRCASECMP(setTTLS->keyMgmtType, "wpa2-ft") == 0)
    {

    }
    else if(wSTRCASECMP(setTTLS->keyMgmtType, "wpa") == 0)
    {

    }
    else if(wSTRCASECMP(setTTLS->keyMgmtType, "wpa2") == 0)
    {
        // to take all and device to pick one it supported
    }
    else
    {
        // ??
    }
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 eap TTLS", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTTLS->trustedRootCA);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
    system(gCmdStr);

    //   wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=MSCHAPV2\"'", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    system(gCmdStr);
#endif    
#endif

    //Note: We do not support WPA2-Enterprise. So if this command is issued, simply return a 
    // "STATUS_COMPLETE" TLV response
    setEapTtlsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;   
    
    return WFA_SUCCESS;
}

/*
 * wfaStaSetEapSIM():
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyMangementType - wpa or wpa2
 */
int wfaStaSetEapSIM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *setEapSimResp = &gGenericResp;
#ifdef HAVE_WPA_ENTERPRISE
    caStaSetEapSIM_t *setSIM = (caStaSetEapSIM_t *)caCmdBuf;
    char *ifname = setSIM->intf;
    
#ifdef WFA_NEW_CLI_FORMAT
    wSPRINTF(gCmdStr, "wfa_set_eapsim %s %s %s %s", ifname, setSIM->ssid, setSIM->username, setSIM->encrptype);
    system(gCmdStr);
#else

    wSPRINTF(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setSIM->ssid);
    system(gCmdStr);


    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setSIM->username);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setSIM->encrptype);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 eap SIM", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    system(gCmdStr);

    if(strcasecmp(setSIM->keyMgmtType, "wpa2-sha256") == 0)
    {
        wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-SHA256", ifname);
    }
    else if(strcasecmp(setSIM->keyMgmtType, "wpa2-eap") == 0)
    {
        wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    }
    else if(strcasecmp(setSIM->keyMgmtType, "wpa2-ft") == 0)
    {
        wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-FT", ifname);
    }
    else if(strcasecmp(setSIM->keyMgmtType, "wpa") == 0)
    {
        wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    }
    else if(strcasecmp(setSIM->keyMgmtType, "wpa2") == 0)
    {
        // take all and device to pick one which is supported.
    }
    else
    {
        // ??
    }
    system(gCmdStr);

#endif
#endif

    //Note: We do not support WPA2-Enterprise. So if this command is issued, simply return a 
    // "STATUS_COMPLETE" TLV response
    setEapSimResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;   
    
    return WFA_SUCCESS;
}

/*
 * wfaStaSetPEAP()
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */
int wfaStaSetPEAP(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *setPeapResp = &gGenericResp;
#ifdef HAVE_WPA_ENTERPRISE
    caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
    char *ifname = setPEAP->intf;
    
#ifdef WFA_NEW_CLI_FORMAT
    wSPRINTF(gCmdStr, "wfa_set_peap %s %s %s %s %s %s %d %s", ifname, setPEAP->ssid, setPEAP->username, 
            setPEAP->passwd, setPEAP->trustedRootCA,
            setPEAP->encrptype, setPEAP->peapVersion,
            setPEAP->innerEAP);
    system(gCmdStr);
#else

    wSPRINTF(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setPEAP->ssid);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 eap PEAP", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"' ", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setPEAP->username);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setPEAP->passwd);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setPEAP->trustedRootCA);
    system(gCmdStr);

    /* if this not set, default to set support all */
    //wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setPEAP->encrptype);
    system(gCmdStr);

    if(strcasecmp(setPEAP->keyMgmtType, "wpa2-sha256") == 0)
    {
        wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-SHA256", ifname);
    }
    else if(strcasecmp(setPEAP->keyMgmtType, "wpa2-eap") == 0)
    {
        wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    }
    else if(strcasecmp(setPEAP->keyMgmtType, "wpa2-ft") == 0)
    {
        wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-FT", ifname);
    }
    else if(strcasecmp(setPEAP->keyMgmtType, "wpa") == 0)
    {
        wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    }
    else if(strcasecmp(setPEAP->keyMgmtType, "wpa2") == 0)
    {
        // take all and device to pick one which is supported.
    }
    else
    {
        // ??
    }
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 phase1 '\"peaplabel=%d\"'", ifname, setPEAP->peapVersion);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=%s\"'", ifname, setPEAP->innerEAP);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    system(gCmdStr);
#endif
#endif

    //Note: We do not support WPA2-Enterprise. So if this command is issued, simply return a 
    // "STATUS_COMPLETE" TLV response
    setPeapResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    
    return WFA_SUCCESS;
}

/*
 * wfaStaSetUAPSD()
 *    This is to set
 *    1. acBE
 *    2. acBK
 *    3. acVI
 *    4. acVO
 */
int wfaStaSetUAPSD(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *setUAPSDResp = &gGenericResp;
#ifdef WFA_NEED_TO_PORT    
#if 0 /* used for only one specific device, need to update to reflect yours */
    caStaSetUAPSD_t *setUAPSD = (caStaSetUAPSD_t *)caCmdBuf;
    char *ifname = setUAPSD->intf;
    char tmpStr[10];
    char line[100];
    char *pathl="/etc/Wireless/RT61STA";
    BYTE acBE=1;
    BYTE acBK=1;
    BYTE acVO=1;
    BYTE acVI=1;
    BYTE APSDCapable;
    FILE *pipe;

    /*
     * A series of setting need to be done before doing WMM-PS
     * Additional steps of configuration may be needed.
     */

    /*
     * bring down the interface
     */
    wSPRINTF(gCmdStr, "ifconfig %s down",ifname);
    //system(gCmdStr);
    /*
     * Unload the Driver
     */
    wSPRINTF(gCmdStr, "rmmod rt61");
    //system(gCmdStr);
#ifndef WFA_WMM_AC
    if(setUAPSD->acBE != 1)
        acBE=setUAPSD->acBE = 0;
    if(setUAPSD->acBK != 1)
        acBK=setUAPSD->acBK = 0;
    if(setUAPSD->acVO != 1)
        acVO=setUAPSD->acVO = 0;
    if(setUAPSD->acVI != 1)
        acVI=setUAPSD->acVI = 0;
#else
    acBE=setUAPSD->acBE;
    acBK=setUAPSD->acBK;
    acVO=setUAPSD->acVO;
    acVI=setUAPSD->acVI;
#endif

    APSDCapable = acBE||acBK||acVO||acVI;
    /*
     * set other AC parameters
     */

    wSPRINTF(tmpStr,"%d;%d;%d;%d",setUAPSD->acBE,setUAPSD->acBK,setUAPSD->acVI,setUAPSD->acVO);
    wSPRINTF(gCmdStr, "sed -e \"s/APSDCapable=.*/APSDCapable=%d/g\" -e \"s/APSDAC=.*/APSDAC=%s/g\" %s/rt61sta.dat >/tmp/wfa_tmp",APSDCapable,tmpStr,pathl);
    //system(gCmdStr);

    wSPRINTF(gCmdStr, "mv /tmp/wfa_tmp %s/rt61sta.dat",pathl);
    //system(gCmdStr);
    pipe = popen("uname -r", "r");
    /* Read into line the output of uname*/
    fscanf(pipe,"%s",line);
    pclose(pipe);

    /*
     * load the Driver
     */
    wSPRINTF(gCmdStr, "insmod /lib/modules/%s/extra/rt61.ko",line);
    //system(gCmdStr);

    wSPRINTF(gCmdStr, "ifconfig %s up",ifname);
    //system(gCmdStr);
#endif
#endif

    //Note: As per Sigma CAPI Specification v7.0.0, this command is currently optional 
    //the 11n and WPA2 test plans. So for now, simply return a "STATUS_COMPLETE" TLV response.
    setUAPSDResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_UAPSD_RESP_TLV, 4, (BYTE *)setUAPSDResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}

int wfaDeviceGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *dutCmd = (dutCommand_t *)caCmdBuf;
    caDevInfo_t *devInfo = &dutCmd->cmdsu.dev;
    dutCmdResponse_t *infoResp = &gGenericResp;

#ifdef WFA_NEED_TO_PORT    
    /*a vendor can fill in the proper info or anything non-disclosure */
    caDeviceGetInfoResp_t dinfo = {"WFA Lab", "DemoUnit", WFA_SYSTEM_VER};
#endif

    DPRINT_INFO(WFA_OUT, "Entering wfaDeviceGetInfo ...\n");
    dbg_printf("wfaDeviceGetInfo: devinfo->fw is %d\n", devInfo->fw); 
    
#ifdef WFA_NEED_TO_PORT    
    if(devInfo->fw == 0)
        wMEMCPY(&infoResp->cmdru.devInfo, &dinfo, sizeof(caDeviceGetInfoResp_t));
    else
    {
        // Call internal API to pull the version ID */
        wMEMCPY(infoResp->cmdru.devInfo.firmware, "NOVERSION", 15);
    }
#endif

    //NOTE: Sigma-11n requires that we report something for version number. For now, report MLAN_RELEASE_VERSION
    //as provided in the module firmware.
    wMEMCPY(infoResp->cmdru.devInfo.firmware, MLAN_RELEASE_VERSION, 15);
    
    infoResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return WFA_SUCCESS;

}

/*
 * This funciton is to retrieve a list of interfaces and return
 * the list back to Agent control.
 * ********************************************************************
 * Note: We intend to make this WLAN interface name as a hardcode name.
 * Therefore, for a particular device, you should know and change the name
 * for that device while doing porting. The MACRO "WFA_STAUT_IF" is defined in 
 * the file "inc/wfa_ca.h". If the device OS is not linux-like, this most 
 * likely is hardcoded just for CAPI command responses.
 * *******************************************************************
 * 
 */
int wfaDeviceListIF(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *infoResp = &gGenericResp;
    dutCommand_t *ifList = (dutCommand_t *)caCmdBuf;
    caDeviceListIFResp_t *ifListResp = &infoResp->cmdru.ifList;

    DPRINT_INFO(WFA_OUT, "Entering wfaDeviceListIF ...\n");

    switch(ifList->cmdsu.iftype)
    {
        case IF_80211:
            infoResp->status = STATUS_COMPLETE;
            ifListResp->iftype = IF_80211; 
            strcpy(ifListResp->ifs[0], WFA_STAUT_IF);
            strcpy(ifListResp->ifs[1], "NULL");
            strcpy(ifListResp->ifs[2], "NULL");
            break;
        case IF_ETH:
            infoResp->status = STATUS_COMPLETE;
            ifListResp->iftype = IF_ETH; 
            strcpy(ifListResp->ifs[0], "eth0");
            strcpy(ifListResp->ifs[1], "NULL");
            strcpy(ifListResp->ifs[2], "NULL");
            break;
        default:
            {
                infoResp->status = STATUS_ERROR;
                wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, 4, (BYTE *)infoResp, respBuf);   
                *respLen = WFA_TLV_HDR_LEN + 4;

                return WFA_SUCCESS; 
            }
    }

    wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return WFA_SUCCESS;
}

int wfaStaDebugSet(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *debugResp = &gGenericResp;
    dutCommand_t *debugSet = (dutCommand_t *)caCmdBuf;

    DPRINT_INFO(WFA_OUT, "Entering wfaStaDebugSet ...\n");

    if(debugSet->cmdsu.dbg.state == 1) /* enable */
        wfa_defined_debug |= debugSet->cmdsu.dbg.level;
    else
        wfa_defined_debug = (~debugSet->cmdsu.dbg.level & wfa_defined_debug);

    debugResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)debugResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


    return WFA_SUCCESS;
}


/*
 *   wfaStaGetBSSID():
 *     This function is to retrieve BSSID of a specific wireless I/F.
 */ 
int wfaStaGetBSSID(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *bssidResp = &gGenericResp;
    char sta_bssid[ETH_ALEN];

    DPRINT_INFO(WFA_OUT, "Entering wfaStaGetBSSID ...\n");
    
    memset(sta_bssid, 0, ETH_ALEN);
    if (wifi_intf_sta_get_current_link_status() == Link_Connected )
    {
        WlanGetBssid(sta_bssid);
    }    
    
    minSprintf(bssidResp->cmdru.bssid, "%02X:%02X:%02X:%02X:%02X:%02X", sta_bssid[0], sta_bssid[1], sta_bssid[2], sta_bssid[3], sta_bssid[4], sta_bssid[5]);

    bssidResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)bssidResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
 
    return WFA_SUCCESS;
}

/*
 * wfaStaSetIBSS()
 *    This is to set
 *    1. ssid
 *    2. channel
 *    3. encrypType - none or wep
 *    optional
 *    4. key1
 *    5. key2
 *    6. key3
 *    7. key4
 *    8. activeIndex - 1, 2, 3, or 4
 */
int wfaStaSetIBSS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *setIbssResp = &gGenericResp;
#ifdef WFA_NEED_TO_PORT    
    caStaSetIBSS_t *setIBSS = (caStaSetIBSS_t *)caCmdBuf;
    
    int i; 

    //Set the ssid 
    wifi_intf_set_var_ssid(WIFI_IFACE_ID_STATION, (uint8_t*)setIBSS->ssid, wSTRLEN(setIBSS->ssid) + 1);   

    //Set the channel info
    wifi_intf_set_var_channel(WIFI_IFACE_ID_STATION, setIBSS->channel);
   
    if(setIBSS->encpType == ENCRYPT_WEP)
    {
        //Set security as WEP and authentication mode as open        
        wifi_intf_set_var_sec_mode(WIFI_IFACE_ID_STATION, WEP);
        wifi_intf_set_var_wep_auth_mode(WIFI_IFACE_ID_STATION, AUTH_OPEN);

        //Set Wep current Key, activeKeyIdx is 1-based while we deal with 0-based indexes
        wifi_intf_set_var_wep_cur_key(WIFI_IFACE_ID_STATION, setIBSS->activeKeyIdx - 1);
        
        //Set Wep keys
        for(i=0; i<4; i++)
        {
            if(setIBSS->keys[i][0] != '\0')
            {
                wifi_intf_set_var_wep_key(WIFI_IFACE_ID_STATION, i, (uint8_t*)setIBSS->keys[i], wSTRLEN(setIBSS->keys[i]) + 1);                
            }
        }
    }
    else /* Open system */
    {
        wifi_intf_set_var_sec_mode(WIFI_IFACE_ID_STATION, OPEN_SYSTEM);
    }
#endif

    //Note: We currently do not support IBSS (Ad-Hoc mode). 
    setIbssResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);   
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

/*
 *  wfaSetMode():
 *  The function is to set the wireless interface with a given mode (possible 
 *  adhoc)
 *  Input parameters:
 *    1. I/F
 *    2. ssid
 *    3. mode adhoc or managed
 *    4. encType
 *    5. channel
 *    6. key(s)
 *    7. active  key
 */ 
int wfaStaSetMode(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetMode_t *setmode = (caStaSetMode_t *)caCmdBuf;
    dutCmdResponse_t *SetModeResp = &gGenericResp;
    int i; 
    wifi_intf_comm_mode_t comm_mode;    
   
    //Set the ssid 
    wifi_intf_set_var_ssid(WIFI_IFACE_ID_STATION, (uint8_t*)setmode->ssid, wSTRLEN(setmode->ssid) + 1);

    //Set Communication Mode
    if(setmode->mode == 1)
    {
        comm_mode = AD_HOC;
        if(setmode->channel)
        {            
            wifi_intf_set_var_channel(WIFI_IFACE_ID_STATION, setmode->channel);
        }
    }
    else
    {
        comm_mode = INFRASTRUCTURE;
    }

    wifi_intf_set_var_comm_mode(WIFI_IFACE_ID_STATION, comm_mode);

    //Set Security
    if(setmode->encpType == ENCRYPT_WEP)
    {
        //Set security as WEP and authentication mode as open        
        wifi_intf_set_var_sec_mode(WIFI_IFACE_ID_STATION, WEP);
        wifi_intf_set_var_wep_auth_mode(WIFI_IFACE_ID_STATION, AUTH_OPEN);

        //Set Wep current Key, activeKeyIdx is 1-based while we deal with 0-based indexes
        wifi_intf_set_var_wep_cur_key(WIFI_IFACE_ID_STATION, setmode->activeKeyIdx - 1);
        
        //Set Wep keys
        for(i=0; i<4; i++)
        {
            if(setmode->keys[i][0] != '\0')
            {
                wifi_intf_set_var_wep_key(WIFI_IFACE_ID_STATION, i, (uint8_t*)setmode->keys[i], wSTRLEN(setmode->keys[i]) + 1);                
            }
        }
    }
    else /* Open system */
    {
        wifi_intf_set_var_sec_mode(WIFI_IFACE_ID_STATION, OPEN_SYSTEM);
    }

    SetModeResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}

int wfaStaSetPwrSave(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *SetPSResp = &gGenericResp;
    
#ifdef WFA_NEED_TO_PORT	
    caStaSetPwrSave_t *setps = (caStaSetPwrSave_t *)caCmdBuf;    
    wSPRINTF(gCmdStr, "iwconfig %s power %s", setps->intf, setps->mode);
    system(gCmdStr);    
#endif
    
    //Note: This command is not listed as "Mandatory" as per the Appendix J: CAPI Program Matrix
    //of the Sigma CAPI Specification v7.0.0, for the 11n and WPA2 test plans. For now, ignore this
    //command 
    SetPSResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_PWRSAVE_RESP_TLV, 4, (BYTE *)SetPSResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    
    return WFA_SUCCESS;
}

int wfaStaUpload(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{    
    dutCmdResponse_t *upLoadResp = &gGenericResp;    
#ifdef WFA_NEED_TO_PORT	
    caStaUpload_t *upload = &((dutCommand_t *)caCmdBuf)->cmdsu.upload;
    caStaUploadResp_t *upld = &upLoadResp->cmdru.uld;
    if(upload->type == WFA_UPLOAD_VHSO_RPT)
    {
        //int rbytes;
        /*
         * if asked for the first packet, always to open the file
         */

        if(upload->next == 1)
        {
            if(e2efp != NULL)
            {
                fclose(e2efp);
                e2efp = NULL;
            }

            e2efp = fopen(e2eResults, "r");
        }

        if(e2efp == NULL)
        {
            upLoadResp->status = STATUS_ERROR;
            wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + 4;
            return WFA_FAILURE;
        }

        rbytes = fread(upld->bytes, 1, 256, e2efp); 

        if(rbytes < 256)  
        {
            /* 
             * this means no more bytes after this read
             */
            upld->seqnum = 0;
            fclose(e2efp);
            e2efp=NULL;
        }
        else
        { 
            upld->seqnum = upload->next;
        }

        upld->nbytes = rbytes;
        upLoadResp->status = STATUS_COMPLETE;
        wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)upLoadResp, respBuf);
        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
    }
    else
    {
        upLoadResp->status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
        *respLen = WFA_TLV_HDR_LEN + 4;
    }
#endif
    
    //Note: As per the Sigma CAPI Specification v7.0.0, this command is listed as Optional for the 
    //WPA2 and 11n test plans. Hence, just ignoring this command for now and returning a "STATUS_COMPLETE"
    //TLV response
    upLoadResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)upLoadResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
    
    return WFA_SUCCESS;
}
/*
 * wfaStaSetWMM()
 *  TO be ported on a specific plaform for the DUT
 *  This is to set the WMM related parameters at the DUT.
 *  Currently the function is used for GROUPS WMM-AC and WMM general configuration for setting RTS Threshhold, Fragmentation threshold and wmm (ON/OFF)
 *  It is expected that this function will set all the WMM related parametrs for a particular GROUP .
 */
int wfaStaSetWMM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{    
    dutCmdResponse_t *setwmmResp = &gGenericResp;    
#ifdef WFA_NEED_TO_PORT
#ifdef WFA_WMM_AC    
    caStaSetWMM_t *setwmm = (caStaSetWMM_t *)caCmdBuf;
    char *ifname = setwmm->intf;    
    //IEEEtypes_WMM_TSPEC_t tspec;

    switch(setwmm->group)
    {
        case GROUP_WMMAC:
            if (setwmm->send_trig)
            {
                int Sockfd;
                struct sockaddr_in psToAddr;
                unsigned int TxMsg[512];

                Sockfd = wfaCreateUDPSock(setwmm->dipaddr, 12346);
                wMEMSET(&psToAddr, 0, sizeof(psToAddr));
                psToAddr.sin_family = AF_INET;
                psToAddr.sin_addr.s_addr = inet_addr(setwmm->dipaddr);
                psToAddr.sin_port = htons(12346);


                switch (setwmm->trig_ac)
                {
                    case WMMAC_AC_VO:
                        wfaTGSetPrio(Sockfd, 7);
                        create_apts_msg(APTS_CK_VO, TxMsg, 0);
                        wPRINTF("\r\nSending AC_VO trigger packet\n");
                        break;

                    case WMMAC_AC_VI:
                        wfaTGSetPrio(Sockfd, 5);
                        create_apts_msg(APTS_CK_VI, TxMsg, 0);
                        wPRINTF("\r\nSending AC_VI trigger packet\n");
                        break;

                    case WMMAC_AC_BK:
                        wfaTGSetPrio(Sockfd, 2);
                        create_apts_msg(APTS_CK_BK, TxMsg, 0);
                        wPRINTF("\r\nSending AC_BK trigger packet\n");
                        break;

                    default:
                    case WMMAC_AC_BE:
                        wfaTGSetPrio(Sockfd, 0);
                        create_apts_msg(APTS_CK_BE, TxMsg, 0);
                        wPRINTF("\r\nSending AC_BE trigger packet\n");
                        break;
                }

                sendto(Sockfd, TxMsg, 256, 0, (struct sockaddr *)&psToAddr,
                        sizeof(struct sockaddr));
                close(Sockfd);
                usleep(1000000);
            } 
            else if (setwmm->action == WMMAC_ADDTS)
            {
                //wmmtspec_t* pCmdTspec = &(setwmm->actions.addts.tspec);
                 wPRINTF("ADDTS AC PARAMS: dialog id: %d, TID: %d, "
	                "DIRECTION: %d, PSB: %d, UP: %d, "
                        "Fixed %d, MSDU Size: %d, Max MSDU Size %d, "
                        "MIN SERVICE INTERVAL: %d, MAX SERVICE INTERVAL: %d, "
                        "INACTIVITY: %d, SUSPENSION %d, SERVICE START TIME: %d, "
                        "MIN DATARATE: %d, MEAN DATA RATE: %d, PEAK DATA RATE: %d, "
                        "BURSTSIZE or MSDU Aggreg: %d, DELAY BOUND: %d, PHYRATE: %d, SPLUSBW: %f, "
                        "MEDIUM TIME: %d, ACCESSCAT: %d\n",
                        setwmm->actions.addts.dialog_token,
                        setwmm->actions.addts.tspec.tsinfo.TID,
                        setwmm->actions.addts.tspec.tsinfo.direction,
                        setwmm->actions.addts.tspec.tsinfo.PSB,
                        setwmm->actions.addts.tspec.tsinfo.UP,
                        setwmm->actions.addts.tspec.Fixed,
                        setwmm->actions.addts.tspec.size,
                        setwmm->actions.addts.tspec.maxsize,
                        setwmm->actions.addts.tspec.min_srvc,
                        setwmm->actions.addts.tspec.max_srvc,
                        setwmm->actions.addts.tspec.inactivity,
                        setwmm->actions.addts.tspec.suspension,
                        setwmm->actions.addts.tspec.srvc_strt_tim,
                        setwmm->actions.addts.tspec.mindatarate,
                        setwmm->actions.addts.tspec.meandatarate,
                        setwmm->actions.addts.tspec.peakdatarate,
                        setwmm->actions.addts.tspec.burstsize,
                        setwmm->actions.addts.tspec.delaybound,
                        setwmm->actions.addts.tspec.PHYrate,
                        setwmm->actions.addts.tspec.sba,
                        setwmm->actions.addts.tspec.medium_time,
                        setwmm->actions.addts.accesscat);

                // you should set your tspec here.

                //system(gCmdStr);
            }
            else if (setwmm->action == WMMAC_DELTS)
            {
                // send del tspec 
            }

            setwmmResp->status = STATUS_COMPLETE;
            break;

        case GROUP_WMMCONF:
            wSPRINTF(gCmdStr, "iwconfig %s rts %d",
                    ifname,setwmm->actions.config.rts_thr);

            system(gCmdStr);
            wSPRINTF(gCmdStr, "iwconfig %s frag %d",
                    ifname,setwmm->actions.config.frag_thr);

            system(gCmdStr);
            wSPRINTF(gCmdStr, "iwpriv %s wmmcfg %d",
                    ifname, setwmm->actions.config.wmm);

            system(gCmdStr);
            setwmmResp->status = STATUS_COMPLETE;
            break;

        default:
            DPRINT_ERR(WFA_ERR, "The group %d is not supported\n",setwmm->group);
            setwmmResp->status = STATUS_ERROR;
            break;

    }

    wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
#endif
#endif

    wPRINTF("Exiting wfaStaSetWMM..\n");

    //Note: As per the Sigma CAPI Specification v7.0.0, this command is listed as Optional for the 
    //WPA2 and 11n test plans. Hence, just ignoring this command for now and returning a "STATUS_ERROR"
    //TLV response
    setwmmResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}

int wfaStaSendNeigReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    //dutCommand_t *sendNeigReq = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *sendNeigReqResp = &gGenericResp;

    /*
     *  run your device to send NEIGREQ
     */

    //Note: This command is not listed in the Sigma CAPI Specification v7.0.0!
    //Simply ignore for now
    sendNeigReqResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SEND_NEIGREQ_RESP_TLV, 4, (BYTE *)sendNeigReqResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

int wfaStaSetEapFAST(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *setEapFastResp = &gGenericResp;
#ifdef HAVE_WPA_ENTERPRISE	
    caStaSetEapFAST_t *setFAST= (caStaSetEapFAST_t *)caCmdBuf;
    char *ifname = setFAST->intf;
    
#ifdef WFA_NEW_CLI_FORMAT
    wSPRINTF(gCmdStr, "wfa_set_eapfast %s %s %s %s %s %s", ifname, setFAST->ssid, setFAST->username,
            setFAST->passwd, setFAST->pacFileName,
            setFAST->innerEAP);
    system(gCmdStr);
#else

    wSPRINTF(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setFAST->ssid);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setFAST->username);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setFAST->passwd);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 eap FAST", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 pac_file '\"%s/%s\"'", ifname, CERTIFICATES_PATH,     setFAST->pacFileName);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 phase1 '\"fast_provisioning=1\"'", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=%s\"'", ifname,setFAST->innerEAP);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    system(gCmdStr);
#endif    
#endif

    //Note: We do not support WPA2-Enterprise
    setEapFastResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}

int wfaStaSetEapAKA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *setEapAkaResp = &gGenericResp;
#ifdef HAVE_WPA_ENTERPRISE	
    caStaSetEapAKA_t *setAKA= (caStaSetEapAKA_t *)caCmdBuf;
    char *ifname = setAKA->intf;
    
#ifdef WFA_NEW_CLI_FORMAT
    wSPRINTF(gCmdStr, "wfa_set_eapaka %s %s %s %s", ifname, setAKA->ssid, setAKA->username, setAKA->passwd);
    system(gCmdStr);
#else

    wSPRINTF(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setAKA->ssid);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA2", ifname);
    system(gCmdStr);
    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 proto CCMP", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 eap AKA", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 phase1 \"result_ind=1\"", ifname);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setAKA->username);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setAKA->passwd);
    system(gCmdStr);

    wSPRINTF(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    system(gCmdStr);
#endif    
#endif

    //Note: We do not support WPA2-Enterprise
    setEapAkaResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return WFA_SUCCESS;
}

int wfaStaSetSystime(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    //caStaSetSystime_t *systime = (caStaSetSystime_t *)caCmdBuf;
    dutCmdResponse_t *setSystimeResp = &gGenericResp;
    
    DPRINT_INFO(WFA_OUT, "Entering wfaStaSetSystime ...\n");

#ifdef WFA_NEED_TO_PORT
#endif

    //NOTE: As per Sigma Installation Guide v7.0.0, this command is applicable to only 
    //"Windows" based category 2 and 3 DUT implementations. Category 1 DUTs should ignore this
    //command. For this purpose, we simply return a "STATUS_COMPLETE" TLV response
    setSystimeResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_SYSTIME_RESP_TLV, 4, (BYTE *)setSystimeResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

#ifdef WFA_STA_TB
int wfaStaPresetParams(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *PresetParamsResp = &gGenericResp;
    caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;

#ifdef WFA_NEED_TO_PORT	    
    int ret;
    char *intfname = presetParams->intf;
    BYTE presetDone = 1;
    int st = 0;

    DPRINT_INFO(WFA_OUT, "Inside wfaStaPresetParameters function ...\n");

    if(presetParams->wmmFlag)
    {
        st = wfaExecuteCLI(gCmdStr);
        switch(st)
        {
            case 0:
                presetDone = 1;
                break;
            case 1:
                presetDone = 0;
                break;
            case 2:
                presetDone = 0;
                break;
        }
    }

    if(presetParams->modeFlag != 0)
    {
        switch(presetParams->wirelessMode)
        {
            default:
                wPRINTF("other mode does not need to support\n");
        }

        st = wfaExecuteCLI(gCmdStr);
        switch(st)
        {
            case 0:
                presetDone = 1;
                break;
            case 1:
                presetDone = 0;
            case 2:
                presetDone = 0;
                break;
        }
    }


    if(presetParams->psFlag)
    {

        wPRINTF("%s\n", gCmdStr);
        system(gCmdStr);
    }

    /************the followings are used for Voice Enterprise **************/
    if(presetParams->ftoa == eEnable)
    {
        // enable Fast BSS Transition Over the Air
    }
    else
    {
        // disable Fast BSS Transition Over the Air

    }

    if(presetParams->ftds == eEnable)
    {
        // enable Fast BSS Transition Over the DS 

    }
    else
    {
        // disable Fast BSS Transition Over the DS 

    }

    if(presetParams->activescan == eEnable)
    {
        // Enable Active Scan on STA 

    }
    else
    {
        // disable Active Scan on STA 

    }


    if (presetDone)
    {
        PresetParamsResp->status = STATUS_COMPLETE;
    }
    else
    {
        PresetParamsResp->status = STATUS_INVALID;
    }

    wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
#endif

    //NOTE: As per Sigma Installation Guide v7.0.0, this command is applicable to only 
    //"Windows" based category 2 and 3 DUT implementations. Category 1 DUTs should ignore this
    //command. For this purpose, we simply return a "STATUS_COMPLETE" TLV response
    PresetParamsResp->status = STATUS_COMPLETE; 
    wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

int wfaStaSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{    
    dutCmdResponse_t *v11nParamsResp = &gGenericResp;

#ifdef WFA_NEED_TO_PORT
#endif

    //NOTE: Not sure if we need to implement this command for DUT. It appears that this
    //command is only meant for Test bed STAs. For now, simply return a "STATUS_COMPLETE" 
    //TLV response
    v11nParamsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, 4, (BYTE *)v11nParamsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    
    return WFA_SUCCESS;
}

int wfaStaSetWireless(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{   
    dutCmdResponse_t *staWirelessResp = &gGenericResp;

#ifdef WFA_NEED_TO_PORT 
#endif

    //NOTE: Not sure if we need to implement this command for DUT. It appears that this
    //command is only meant for Test bed STAs. For now, simply return a "STATUS_COMPLETE" 
    //TLV response
    staWirelessResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_WIRELESS_RESP_TLV, 4, (BYTE *)staWirelessResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    
    return WFA_SUCCESS;
}

int wfaStaSendADDBA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{   
    dutCmdResponse_t *staSendADDBAResp = &gGenericResp;

#ifdef WFA_NEED_TO_PORT 
#endif

    //NOTE: Not sure if we need to implement this command for DUT. It appears that this
    //command is only meant for Test bed STAs. For now, simply return a "STATUS_COMPLETE" 
    //TLV response
    staSendADDBAResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_SEND_ADDBA_RESP_TLV, 4, (BYTE *)staSendADDBAResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    
    return WFA_SUCCESS;
}

int wfaStaSetRIFS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{    
    dutCmdResponse_t *staSetRIFSResp = &gGenericResp;

#ifdef WFA_NEED_TO_PORT
#endif

    //NOTE: Not sure if we need to implement this command for DUT. It appears that this
    //command is only meant for Test bed STAs. For now, simply return a "STATUS_COMPLETE" 
    //TLV response
    staSetRIFSResp->status = STATUS_COMPLETE;    
    wfaEncodeTLV(WFA_STA_SET_RIFS_TEST_RESP_TLV, 4, (BYTE *)staSetRIFSResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    
    return WFA_SUCCESS;
}

int wfaStaSendCoExistMGMT(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{    
    dutCmdResponse_t *staSendMGMTResp = &gGenericResp;

#ifdef WFA_NEED_TO_PORT
#endif    
    
    //NOTE: Not sure if we need to implement this command for DUT. It appears that this
    //command is only meant for Test bed STAs. For now, simply return a "STATUS_COMPLETE" 
    //TLV response
    staSendMGMTResp->status = STATUS_COMPLETE; 
    wfaEncodeTLV(WFA_STA_SEND_COEXIST_MGMT_RESP_TLV, 4, (BYTE *)staSendMGMTResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

//NOTE: Not sure if we need to implement this command for DUT. It appears that this
//command is only meant for Test bed STAs. For now, simply return a "STATUS_COMPLETE" 
//TLV response and perform a STA restore defaults.
int wfaStaResetDefault(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    //caStaResetDefault_t *reset = (caStaResetDefault_t *)caCmdBuf;
    dutCmdResponse_t *ResetResp = &gGenericResp;
    
    wifi_intf_var_restore_defaults(WIFI_IFACE_ID_STATION, WIFI_INTF_VAR_ALL);
    notify_wifi_sta_vars_changed();
   
    ResetResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_RESET_DEFAULT_RESP_TLV, 4, (BYTE *)ResetResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

#else
int wfaStaTestBedCmd(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staCmdResp = &gGenericResp;

    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}
#endif

int wfaStaDisconnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staDiscResp = &gGenericResp; 

    wPRINTF("Entering wfaStaDisconnect....\n");

    //disable station
    wifi_intf_set_var_is_enabled(WIFI_IFACE_ID_STATION, false);
   
    // stop the supplicant
    staDiscResp->status = STATUS_COMPLETE;

    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staDiscResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return WFA_SUCCESS;
}

//NOTE: Already implemented ping using Treck's TCP/IP stack APIs, Check sigma_do_ping()
/* Supporting Functions */

void wfaSendPing(tgPingStart_t *staPing, float *interval, int streamid)
{
#ifdef WFA_NEED_TO_PORT	
    int totalpkts;
    char cmdStr[128];
    //   char *addr = staPing->dipaddr;
#ifdef WFA_PC_CONSOLE
    char addr[20];
    char bflag[] = "-b";
    char *tmpstr;
    int inum=0;
#else
    char bflag[] = "  ";
#endif
    totalpkts = staPing->duration * staPing->frameRate;
#ifdef WFA_PC_CONSOLE

    wPRINTF("\nCS : The Stream ID is %d",streamid);
    wPRINTF("\nCS :the addr is %s ",addr);
    strcpy(addr,staPing->dipaddr);
    wPRINTF("\nCS :Inside the WFA_PC_CONSLE BLOCK");
    wPRINTF("\nCS :the addr is %s ",addr);
    tmpstr = strtok(addr, ".");

    inum = atoi(tmpstr);

    wPRINTF("interval %f\n", *interval);

    if(inum >= 224 && inum <= 239) // multicast
    {
    }
    else // if not MC, check if it is BC address
    {
        wPRINTF("\nCS :Inside the BC address BLOCK");
        wPRINTF("\nCS :the inum %d",inum);
        strtok(NULL, ".");
        //strtok(NULL, ".");
        tmpstr = strtok(NULL, ".");
        wPRINTF("tmpstr %s\n", tmpstr);
        inum = atoi(tmpstr);
        wPRINTF("\nCS : The string is %s",tmpstr);
        if(inum != 255)
            wMEMSET(bflag, 0, strlen(bflag));
    }
#endif
    wPRINTF("\nCS : The Stream ID is %d",streamid);

    wSPRINTF(cmdStr, "echo streamid=%d > /tmp/spout_%d.txt;wfaping.sh %s %s -i %f -c %d -s %d -q >> /tmp/spout_%d.txt 2>/dev/null",
            streamid,streamid,bflag, staPing->dipaddr, *interval, totalpkts, staPing->frameSize,streamid);
    system(cmdStr);
    wPRINTF("\nCS : The command string is %s",cmdStr);

    wSPRINTF(cmdStr, "updatepid.sh /tmp/spout_%d.txt",streamid);
    system(cmdStr);
    wPRINTF("\nCS : The command string is %s",cmdStr);
#endif
}

int wfaStopPing(dutCmdResponse_t *stpResp, int streamid)
{
#ifdef WFA_NEED_TO_PORT
    char strout[256];
    FILE *tmpfile = NULL;
    char cmdStr[128];
    wPRINTF("Ping stop id %d\n", streamid);
    wSPRINTF(cmdStr, "getpid.sh /tmp/spout_%d.txt /tmp/pid.txt",streamid);
    system(cmdStr);

    wPRINTF("\nCS : The command string is %s",cmdStr);

    system("stoping.sh /tmp/pid.txt ; sleep 2");

    wSPRINTF(cmdStr, "getpstats.sh /tmp/spout_%d.txt",streamid);
    system(cmdStr);

    wPRINTF("\nCS : The command string is %s",cmdStr);

    tmpfile = fopen("/tmp/stpsta.txt", "r+");

    if(tmpfile == NULL)
    {
        return WFA_FAILURE;
    }

    if(fscanf(tmpfile, "%s", strout) != EOF)
    {
        if(*strout == '\0')
        {
            stpResp->cmdru.pingStp.sendCnt = 0;
        }

        else
            stpResp->cmdru.pingStp.sendCnt = atoi(strout);
    }

    wPRINTF("after scan sent count %d\n", stpResp->cmdru.pingStp.sendCnt);


    if(fscanf(tmpfile, "%s", strout) != EOF)
    {
        if(*strout == '\0')
        {
            stpResp->cmdru.pingStp.repliedCnt = 0;
        }
        else
            stpResp->cmdru.pingStp.repliedCnt = atoi(strout);
    }
    wPRINTF("after scan replied count %d\n", stpResp->cmdru.pingStp.repliedCnt);

    fclose(tmpfile);
#endif    

    return WFA_SUCCESS;
}



