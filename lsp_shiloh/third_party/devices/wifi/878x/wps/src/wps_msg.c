/** @file wps_msg.c
 *  @brief This file contains WPS Messages processing functions.
 *  
 *  Copyright (C) 2003-2012, Marvell International Ltd.
 *  All Rights Reserved
 */

#include <string.h>
#include <stdlib.h>
//#include <stdio.h>
//#include <time.h>
#include <stddef.h>   /* for size_t */
//#include <netinet/in.h>
#include "tx_api.h"

#include "wps_msg.h"
#include "wps_eapol.h"
#include "wps_util.h"
#include "wps_def.h"
#include "wps_wlan.h"
#include "wps_os.h"

#include "encrypt.h"
#include "wifi_intf_api.h"
#include "trsocket.h"
#include "common.h"
#include "wlanInterface.h"
#include "wifi_intf.h"
#include "logger.h"

/** WPS global */
extern WPS_DATA wps_global;

/** IE index*/
extern short ie_index;
/** IE buffer index */
extern short ap_assocresp_ie_index;
/********************************************************
        Local Variables
********************************************************/
/** Enrollee identity */
const char wps_enrollee_identity[] = "WFA-SimpleConfig-Enrollee-1-0";
/** Registrar identity */
const char wps_registrar_identity[] = "WFA-SimpleConfig-Registrar-1-0";
/** WPS vendor ID */
static u8 wps_vendor_id[3] = { 0x00, 0x37, 0x2A };

/** WPS vendor type */
static u8 wps_vendor_type[4] = { 0x00, 0x00, 0x00, 0x01 };

/** WPS OUI */
static u8 wps_wifi_oui[4] = { 0x00, 0x50, 0xF2, 0x04 };

/** Prime value in Diffie-Hellman Exchange */
static u8 DH_PRIME_1536[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,
    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,
    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,
    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,
    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,
    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,
    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,
    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,
    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,
    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x23, 0x73, 0x27,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

/** Generator in Diffie-Hellman Exchange */
static u8 GEN = 0x2;
/** Key generated by Diffie-Hellman Exchange */
static u8 DHKey[SHA256_DIGEST_SIZE];

/** Key derived by EnrolleeMAC and Nonce */
static u8 KDK[SHA256_DIGEST_SIZE];

/** Key wrapped authenticator */
static u8 KWA[SHA256_DIGEST_SIZE];

/** Additional Key : AuthKey(32B)+KeyWrapKey(16B)+EMSK(32B) */
#define AUTH_KEY_LEN    256/8
#define KWK_LEN         128/8
#define EMSK_LEN        256/8
#define PSK_LEN         128/8

static u8 AKE_Key[AUTH_KEY_LEN + KWK_LEN + EMSK_LEN];
static u32 AKE_KeyBits = 640;   /* (AUTH_KEY_LEN+KWK_LEN+EMSK_LEN)x8 */

/** First 128 bits of hashed 1st/2nd half of device password */
static u8 PSK1[PSK_LEN], PSK2[PSK_LEN];

static u8 HashArgu[416];        /* ES1(16B)+PSK1(16B)+PKE(192B)+PKR(192B) =
                                   416B */
static u8 HashKdkIn[38];        /* N1(16B)+MAC(6B)+N2(16B) = 38B */
static u8 EncryData[0x200];
static u8 EncryAesOutput[0x200];        /* Output buffer for AEC-CBC Encryption 
                                         */

#define WPS_VENDOR_EXT_ID_LEN   (3)
static const char wfa_vendor_ext_id[WPS_VENDOR_EXT_ID_LEN] =
    { 0x00, 0x37, 0x2A };

static int num_cred = 1;

#define WPS_SAVE_PKT(i, f, l) do{                  \
    memcpy(i->last_message.message, f, l);         \
    i->last_message.length = l;                    \
}while(0)

#define WPS_EAPOL_TX_AND_SAVE(r, i, d, b, s) do{  \
    if(i->frag_thres < s){                        \
        r = wps_setup_tx_frag(i, d, b, s);        \
    }else{                                        \
        r = wps_eapol_txPacket((u8 *)b, s);       \
        if(r>=0){                                 \
            WPS_SAVE_PKT(i, (u8*) (((PEAP_FRAME_HEADER)(b))+1), \
                    s-SZ_EAP_WPS_FRAME_HEADER);   \
        }                                         \
    }                                             \
}while(0)

static int wps_authenticator_generate(PWPS_INFO pwps_info,
                                      u8 * prev_msg, u16 prev_msg_len,
                                      u8 * curr_msg, u16 curr_msg_len,
                                      u8 * hmac_out);
short wps_selected_registrar_config_method_prepare(PWPS_INFO pwps_info);
void wps_check_for_ap_setup_locked_scenario(PWPS_INFO pwps_info);
int wps_config_read(PWPS_INFO pwps_info, WPS_DATA * wps_s);
void wps_generate_uuid_using_mac_addr(const u8 * mac_addr, u8 * uuid);

/********************************************************
        Global Variables
********************************************************/

/********************************************************
        Local Functions
********************************************************/

/** 
 *  @brief  Prepare for EAP message header
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param code         EAP_RESPONSE or EAP_REQUEST
 *  @param id           Frame identifier
 *  @param wps_msg      EAP packet Op-Code
 *  @return             Length of EAP message header
 */
//static 
int
wps_eap_message_header_prepare(PWPS_INFO wps_info, u8 code, u8 id, u8 wps_msg)
{
    PEAP_FRAME_HEADER peap_wps_frame;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) wps_info->buffer;
    peap_wps_frame->code = code;
    peap_wps_frame->identifier = id;
    peap_wps_frame->type = EAP_TYPE_WPS;        /* 254 */
    peap_wps_frame->length = SZ_EAP_WPS_FRAME_HEADER;
    memcpy(peap_wps_frame->vendor_id, wps_vendor_id, sizeof(wps_vendor_id));
    memcpy(peap_wps_frame->vendor_type, wps_vendor_type,
           sizeof(wps_vendor_type));
    peap_wps_frame->op_code = wps_msg;
    peap_wps_frame->flags = 0;

    LEAVE();
    return SZ_EAP_WPS_FRAME_HEADER;
}

/** 
 *  @brief  Prepare for WPS2 Dummy Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_attribute_dummy_prepare(PWPS_INFO pwps_info, u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    int offset = 0;
    ENTER();

    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Dummy_Attribute);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    *ptr = 0xAA;
    ptr += ptlv->length;
    offset = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS Version Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_attribute_version_prepare(PWPS_INFO pwps_info, u8 * ptr)
{
    /* The Version attr is deprecated in WSC2.0, so hardcode a value of 0x10
       for backward compatibility */
    u8 version = WPS_VERSION_1DOT0;
    PTLV_DATA_HEADER ptlv;
    int offset;
    ENTER();

    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Version);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;

    memcpy(ptr, &version, ptlv->length);

    ptr += ptlv->length;
    offset = SZ_TLV_HEADER + ptlv->length;

    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS Version2 Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_subele_version2_prepare(PWPS_INFO pwps_info, u8 * ptr)
{
    PSUBELE_DATA_HEADER pele;
    int offset;

    ENTER();

    pele = (PSUBELE_DATA_HEADER) ptr;
    pele->type = SC_Version2;
    pele->length = SZ_VERSION2;
    ptr += SZ_SUBELE_HEADER;

    if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info))
        ) {

        wps_printf(DEBUG_WLAN, "Sending Version2 as 0x%x!\n",
                   pwps_info->enrollee.version);
        memcpy(ptr, &pwps_info->enrollee.version, pele->length);
    } else if (pwps_info->role == WPS_REGISTRAR
               || (IS_DISCOVERY_REGISTRAR(pwps_info))
        ) {
        memcpy(ptr, &pwps_info->registrar.version, pele->length);
    }

    offset = SZ_SUBELE_HEADER + pele->length;

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS Authorized MACs Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_subele_authorized_mac_prepare(PWPS_INFO pwps_info, u8 * ptr)
{
    PSUBELE_DATA_HEADER pele;
    int offset;
    u8 wps_zero_mac[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    u8 wps_broadcast_mac[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
    u8 auth_enrollee_count = 0, authorized_enrollee_present =
        0, authorized_enrollee_present_count = 0;
    ENTER();

    pele = (PSUBELE_DATA_HEADER) ptr;
    pele->type = SC_AuthorizedMACs;
    pele->length = 0;
    ptr += SZ_SUBELE_HEADER;
    authorized_enrollee_present = WPS_CANCEL;
    while (auth_enrollee_count < MAX_AUTH_ENROLLEE_COUNT) {
        if (memcmp
            (&pwps_info->auth_enrollee_mac_addr[auth_enrollee_count * ETH_ALEN],
             wps_zero_mac, ETH_ALEN)) {
            memcpy(ptr,
                   &pwps_info->auth_enrollee_mac_addr[auth_enrollee_count *
                                                      ETH_ALEN], ETH_ALEN);
            wps_hexdump(DEBUG_WLAN, "Authorized Enrollee Mac address: ",
                        &pwps_info->auth_enrollee_mac_addr[auth_enrollee_count *
                                                           ETH_ALEN], ETH_ALEN);
            wps_printf(DEBUG_WLAN, "Count %d \n", auth_enrollee_count);
            pele->length += ETH_ALEN;
            ptr += ETH_ALEN;
            authorized_enrollee_present = WPS_SET;
            authorized_enrollee_present_count++;
        }
        auth_enrollee_count++;
    }
    if (authorized_enrollee_present == WPS_CANCEL) {

        memcpy(ptr, wps_broadcast_mac, ETH_ALEN);
        pele->length += ETH_ALEN;
    }
    offset = SZ_SUBELE_HEADER + pele->length;

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS Vendor extension Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_attribute_vendor_ext_prepare(PWPS_INFO pwps_info, u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;

    ENTER();

    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Vendor_Extension);
    ptlv->length = 0;
    ptr += SZ_TLV_HEADER;

    LEAVE();
    return (SZ_TLV_HEADER);
}

/** 
 *  @brief  Prepare for WPS Message type Attribute
 *
 *  @param ptr          A pointer to buffer which store this attribute
 *  @param msg_id       WPS Message Type
 *  @return             Length of Attribute TLV
 */
static int
wps_attribute_message_type_prepare(u8 * ptr, u8 msg_id)
{
    PTLV_DATA_HEADER ptlv;
    int offset;

    ENTER();

    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Message_Type);
    ptlv->length = 1;

    ptr += SZ_TLV_HEADER;
    *ptr = msg_id;
    offset = SZ_TLV_HEADER + ptlv->length;

    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS UUID Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_attribute_uuid_prepare(PWPS_INFO pwps_info, u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    int offset;

    ENTER();

    ptlv = (PTLV_DATA_HEADER) ptr;

    if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info))
        ) {
        ptlv->type = htons(SC_UUID_E);
        ptlv->length = pwps_info->enrollee.wps_uuid_length;
        ptr += SZ_TLV_HEADER;
        memcpy(ptr, pwps_info->enrollee.wps_uuid, ptlv->length);
    } else if (pwps_info->role == WPS_REGISTRAR
               || (IS_DISCOVERY_REGISTRAR(pwps_info))
        ) {
        ptlv->type = htons(SC_UUID_R);
        ptlv->length = pwps_info->registrar.wps_uuid_length;
        ptr += SZ_TLV_HEADER;
        memcpy(ptr, pwps_info->registrar.wps_uuid, ptlv->length);
    }

    offset = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS MAC Address Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_attribute_mac_address_prepare(PWPS_INFO wps_info, u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    int offset;

    ENTER();

    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_MAC_Address);
    ptlv->length = sizeof(wps_info->enrollee.mac_address);
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, wps_info->enrollee.mac_address, ptlv->length);

    offset = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS Nonce Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param type         WPS_ENROLLEE or WPS_REGISTRAR
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_attribute_nonce_prepare(PWPS_INFO pwps_info, u8 type, u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    int offset;
    u8 *nonce;

    ENTER();

    ptlv = (PTLV_DATA_HEADER) ptr;

    if (type == WPS_ENROLLEE) {
        ptlv->type = htons(SC_Enrollee_Nonce);
        nonce = pwps_info->enrollee.nonce;
    } else {
        ptlv->type = htons(SC_Registrar_Nonce);
        nonce = pwps_info->registrar.nonce;
    }

    ptlv->length = WPS_NONCE_SIZE;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, nonce, ptlv->length);
    offset = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS Public Key Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param type         WPS_ENROLLEE or WPS_REGISTRAR
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_attribute_public_key_prepare(PWPS_INFO pwps_info, u8 type, u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    int offset;
    DH_PG_PARAMS params;

    ENTER();

    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Public_Key);
    ptlv->length = SZ_PUBLIC_KEY;

    /* Get Fiffie-Hellman Public Key */
    params.generator = &GEN;
    params.generatorLen = 1;
    params.prime = DH_PRIME_1536;
    params.primeLen = sizeof(DH_PRIME_1536);

    if (type == WPS_ENROLLEE) {
        memset(pwps_info->enrollee.public_key, 0, SZ_PUBLIC_KEY);
        memset(pwps_info->enrollee.private_key, 0, SZ_PRIVATE_KEY);
        MrvDH_Setup(pwps_info->enrollee.public_key,
                    SZ_PUBLIC_KEY,
                    pwps_info->enrollee.private_key, SZ_PRIVATE_KEY, &params);
        ptr += SZ_TLV_HEADER;
        memcpy(ptr, pwps_info->enrollee.public_key, ptlv->length);
    } else if (type == WPS_REGISTRAR) {
        memset(pwps_info->registrar.public_key, 0, SZ_PUBLIC_KEY);
        memset(pwps_info->registrar.private_key, 0, SZ_PRIVATE_KEY);
        MrvDH_Setup(pwps_info->registrar.public_key,
                    SZ_PUBLIC_KEY,
                    pwps_info->registrar.private_key, SZ_PRIVATE_KEY, &params);
        ptr += SZ_TLV_HEADER;
        memcpy(ptr, pwps_info->registrar.public_key, ptlv->length);
    }

    offset = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS Primary Device Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static int
wps_attribute_primary_device_type_prepare(PWPS_INFO pwps_info, u8 * ptr)
{
    PRIMARY_DEVICE_TYPE_MSG *primary_dev;
    int offset;

    ENTER();

    primary_dev = (PRIMARY_DEVICE_TYPE_MSG *) ptr;
    primary_dev->type = htons(SC_Primary_Device_Type);
    primary_dev->length = SZ_PRIMARY_DEVICE_TYPE;
    primary_dev->category_id = htons(pwps_info->primary_dev_category);
    primary_dev->sub_category_id = htons(pwps_info->primary_dev_subcategory);
    memcpy(primary_dev->oui_id, wps_wifi_oui, sizeof(wps_wifi_oui));

    offset = SZ_TLV_HEADER + primary_dev->length;
    primary_dev->length = htons(primary_dev->length);

    LEAVE();
    return offset;
}

/** 
 *  @brief  Prepare for WPS Attribute including Version, Message Type, Nonce
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param id           Frame identifier
 *  @param code         EAP_RESPONSE or EAP_REQUEST
 *  @param opCode       EAP packet Op-Code
 *  @param message_type WPS Message Type
 *  @return             Length of Attribute TLV
 */
static int
wps_message_common_attribute_prepare(PWPS_INFO pwps_info, u8 id, u8 code,
                                     u8 opCode, u8 message_type)
{
    int offset = 0;
    PEAP_FRAME_HEADER peap_wps_frame;
    u8 *ptr;
    u16 message_length;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;

    offset = wps_eap_message_header_prepare(pwps_info, code, id, opCode);
    message_length = 0;

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, message_type);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    offset = wps_attribute_nonce_prepare(pwps_info, WPS_ENROLLEE, ptr);
    message_length += offset;

    /* Registrar Nonce */
    ptr += offset;
    offset = wps_attribute_nonce_prepare(pwps_info, WPS_REGISTRAR, ptr);
    message_length += offset;

    peap_wps_frame->length += message_length;
    message_length = peap_wps_frame->length;
    peap_wps_frame->length = htons(message_length);

    LEAVE();
    return message_length;
}

/** 
 *  @brief  Prepare for WPS Authenticator Attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param message_len  Length before authenticator
 *  @param ptr          A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
static u16
wps_attribute_authenticator_prepare(PWPS_INFO pwps_info, u16 message_len,
                                    u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    u16 offset = 0;
    u8 hmacOut[32];

    ENTER();

    /* Generate 32-byte Authenticator */
    wps_authenticator_generate(pwps_info,
                               pwps_info->last_message.message,
                               pwps_info->last_message.length,
                               pwps_info->buffer + SZ_EAP_WPS_FRAME_HEADER,
                               message_len, hmacOut);

    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Authenticator);
    ptlv->length = SZ_AUTHENTICATOR;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, hmacOut, SZ_AUTHENTICATOR);
    offset = SZ_TLV_HEADER + SZ_AUTHENTICATOR;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return offset;
}

/** 
 *  @brief  Generate WPS Authenticator
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param prev_msg     A pointer to previous WPS message
 *  @param prev_msg_len Length of previous WPS message
 *  @param curr_msg     A pointer to current WPS message
 *  @param curr_msg_len Length of current WPS message
 *  @param hmac_out     A pointer to buffer which stores authenticator
 *  @return             WPS_STATUS_SUCCESS--success, WPS_STATUS_FAIL--fail
 */
static int
wps_authenticator_generate(PWPS_INFO pwps_info,
                           u8 * prev_msg, u16 prev_msg_len, u8 * curr_msg,
                           u16 curr_msg_len, u8 * hmac_out)
{
    u8 *hmacIn;
    u16 hmacLen = 0;

    ENTER();

    if ((prev_msg_len + curr_msg_len) > 2048) {
        wps_printf(MSG_ERROR, "ERROR : mac buffer is small!\n");
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    hmacIn = (u8 *) malloc(2048);
    if (hmacIn == NULL) {
        wps_printf(MSG_ERROR, "ERROR : malloc failed !\n");
        LEAVE();
        return WPS_STATUS_FAIL;
    }
    memset(hmacIn, 0, 2048);

    hmacLen = prev_msg_len;
    memcpy(hmacIn, prev_msg, prev_msg_len);
    memcpy((u8 *) (hmacIn + prev_msg_len), curr_msg, curr_msg_len);
    hmacLen += curr_msg_len;
    MrvHMAC_SHA256(pwps_info->auth_key, SZ_AUTH_KEY,
                   hmacIn, hmacLen, hmac_out, SHA256_DIGEST_SIZE);

    free(hmacIn);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Write Network Credential to output file
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param stream       File pointer to be write to
 *  @param index        Index of credential array
 *  @param nCred        Credential number for mixed mode security
 *  @return             WPS_STATUS_SUCCESS--success, WPS_STATUS_FAIL--fail
 */
#if 0
static int
output_supp_config(PWPS_INFO pwps_info, FILE * stream, int index, int nCred)
{
    CREDENTIAL_DATA *pCredential;
    int ret = WPS_STATUS_SUCCESS;
    int i = 0;
    char quotation_mark = '\"';
    int psk_written = 0, eap_written = 0;
    int wpa_written = 0, rsn_written = 0;
    u16 auth;
    u16 encry;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = NULL;

    ENTER();

    if ((wps_s->bss_type == BSS_TYPE_STA) &&
        (pwps_info->read_ap_config_only == WPS_SET)) {
        pCredential = (CREDENTIAL_DATA *)
            & pwps_info->enrollee.cred_data[index];
        en_reg = &pwps_info->enrollee;
    } else {
        pCredential = (CREDENTIAL_DATA *)
            & pwps_info->registrar.cred_data[index];
        en_reg = &pwps_info->registrar;
    }

    wps_printf(DEBUG_POST_RUN, "Create config file for wpa_supplicant");
    wps_printf(DEBUG_POST_RUN, "Auth Type: %x, Encryption Type: %x",
               pCredential->auth_type, pCredential->encry_type);

    if (pCredential->auth_type == AUTHENTICATION_TYPE_WPAPSK ||
        pCredential->auth_type == AUTHENTICATION_TYPE_WPA ||
        pCredential->auth_type == AUTHENTICATION_TYPE_WPA2 ||
        pCredential->auth_type == AUTHENTICATION_TYPE_WPA_MIXED ||
        pCredential->auth_type == AUTHENTICATION_TYPE_WPA2PSK) {

        /* Checking incorrect combination for Auth/Encry pair */
        if ((pCredential->encry_type == ENCRYPTION_TYPE_NONE)
            || (pCredential->encry_type == ENCRYPTION_TYPE_WEP)) {

            if (wps_non_interactive)
                wps_write_status
                    ("ERROR: Fail to generate wps.conf due to unexpected "
                     "Auth Type (0x%x) and Encryption Type (0x%x)!\n",
                     pCredential->auth_type, pCredential->encry_type);
            else
                printf("ERROR: Fail to generate wps.conf due to unexpected "
                       "Auth Type (0x%x) and Encryption Type (0x%x)!\n",
                       pCredential->auth_type, pCredential->encry_type);
            LEAVE();
            return WPS_STATUS_FAIL;
        }
#ifndef WFD_SUPPORT
        if (pwps_info->role == WPS_ADHOC_EXTENTION)
#endif
        {
            fprintf(stream, "%s%s\n", "ctrl_interface=", WPAS_CTRL_PATH);
            fprintf(stream, "%s\n", "ap_scan=2");
        }

        fprintf(stream, "%s\n", "network={");
        /* ssid */
        fprintf(stream, "%s%c", "ssid=", quotation_mark);
        for (i = 0; i < pCredential->ssid_length; i++) {
            /* Avoid null character */
            if (pCredential->ssid[i] != 0)
                fprintf(stream, "%c", pCredential->ssid[i]);
        }
        fprintf(stream, "%c\n", quotation_mark);

        /* proto */
        fprintf(stream, "%s", "proto=");
        for (i = 0; i < nCred; i++) {
            if (nCred == 2)
                pCredential = (CREDENTIAL_DATA *) & en_reg->cred_data[i];
            else
                pCredential = (CREDENTIAL_DATA *) & en_reg->cred_data[index];

            auth = pCredential->auth_type;
            switch (auth) {
            case AUTHENTICATION_TYPE_WPAPSK:   /* 0x0002 */
            case AUTHENTICATION_TYPE_WPA:      /* 0x0008 */
                if (wpa_written)
                    break;
                fprintf(stream, "%s ", "WPA");
                wpa_written = 1;
                break;

            case AUTHENTICATION_TYPE_WPA2:     /* 0x0010 */
            case AUTHENTICATION_TYPE_WPA2PSK:  /* 0x0020 */
                if (rsn_written)
                    break;
                fprintf(stream, "%s ", "RSN");
                rsn_written = 1;
                break;
            case AUTHENTICATION_TYPE_WPA_MIXED:        /* 0x0022 */
                /* For Mixed mode, force WPA2 */
                if (rsn_written)
                    break;
                fprintf(stream, "%s ", "RSN");
                rsn_written = 1;
                break;
            default:
                fprintf(stream, " ");
                break;
            }
        }
        fprintf(stream, "\n");

        /* key_mgmt */
        fprintf(stream, "%s", "key_mgmt=");
        for (i = 0; i < nCred; i++) {
            if (nCred == 2)
                pCredential = (CREDENTIAL_DATA *) & en_reg->cred_data[i];
            else
                pCredential = (CREDENTIAL_DATA *) & en_reg->cred_data[index];

            auth = pCredential->auth_type;
            switch (auth) {
            case AUTHENTICATION_TYPE_WPAPSK:   /* 0x0002 */
            case AUTHENTICATION_TYPE_WPA2PSK:  /* 0x0020 */
            case AUTHENTICATION_TYPE_WPA_MIXED:        /* 0x0022 */
                if (psk_written)
                    break;
                if (pCredential->encry_type == ENCRYPTION_TYPE_NONE)
                    fprintf(stream, "%s", "WPA-NONE");
                else
                    fprintf(stream, "%s ", "WPA-PSK");
                psk_written = 1;
                break;

            case AUTHENTICATION_TYPE_WPA:      /* 0x0008 */
            case AUTHENTICATION_TYPE_WPA2:     /* 0x0010 */
                if (eap_written)
                    break;
                fprintf(stream, "%s ", "WPA-EAP");
                eap_written = 1;
                break;

            default:
                fprintf(stream, " ");
                break;
            }
        }
        fprintf(stream, "\n");

        /* pairwise */

        fprintf(stream, "%s", "pairwise=");
        for (i = 0; i < nCred; i++) {
            if (nCred == 2)
                pCredential = (CREDENTIAL_DATA *) & en_reg->cred_data[i];
            else
                pCredential = (CREDENTIAL_DATA *) & en_reg->cred_data[index];

            encry = pCredential->encry_type;
            switch (encry) {
            case ENCRYPTION_TYPE_WEP:  /* 0x0002 */
                fprintf(stream, "%s", "WEP40 WEP104 ");
                break;
            case ENCRYPTION_TYPE_TKIP: /* 0x0004 */
                fprintf(stream, "%s", "TKIP ");
                break;
            case ENCRYPTION_TYPE_AES:  /* 0x0008 */
                fprintf(stream, "%s", "CCMP ");
                break;
            case ENCRYPTION_TYPE_TKIP | ENCRYPTION_TYPE_AES:
                fprintf(stream, "%s", "TKIP CCMP ");
                break;
            case ENCRYPTION_TYPE_NONE:
                fprintf(stream, "%s", "NONE");
                break;
            default:
                fprintf(stream, " ");
                break;
            }
        }
        fprintf(stream, "\n");

        pCredential = (CREDENTIAL_DATA *) & en_reg->cred_data[index];

        /* psk */
        fprintf(stream, "%s", "psk=");
        /* 
         * If length of key equals to 64, data is HEX character.
         * Should ignore the quotation mark.
         */
        if (pCredential->network_key_len == 64) {
            for (i = 0; i < pCredential->network_key_len; i++) {
                /* Avoid null character */
                if (pCredential->network_key[i] != 0)
                    fprintf(stream, "%c", (char) pCredential->network_key[i]);
            }                   /* for */
            fprintf(stream, "\n");
        }
        /* Data is ASCII character, should add the quotation mark */
        else {
            fprintf(stream, "%c", quotation_mark);
            for (i = 0; i < pCredential->network_key_len; i++) {
                /* Avoid null character */
                if (pCredential->network_key[i] != 0)
                    fprintf(stream, "%c", (char) pCredential->network_key[i]);
            }
            fprintf(stream, "%c\n", quotation_mark);
        }

        fprintf(stream, "}\n");
    } else if (pCredential->auth_type == AUTHENTICATION_TYPE_OPEN ||
               pCredential->auth_type == AUTHENTICATION_TYPE_SHARED) {

        /* Checking incorrect combination for Auth/Encry pair */
        if (pCredential->encry_type == ENCRYPTION_TYPE_TKIP ||
            pCredential->encry_type == ENCRYPTION_TYPE_AES) {
            if (wps_non_interactive)
                wps_write_status
                    ("ERROR: Fail to generate wps.conf due to unexpected "
                     "Auth Type (0x%x) and Encryption Type (0x%x)!\n",
                     pCredential->auth_type, pCredential->encry_type);
            else
                printf("ERROR: Fail to generate wps.conf due to unexpected "
                       "Auth Type (0x%x) and Encryption Type (0x%x)!\n",
                       pCredential->auth_type, pCredential->encry_type);
            LEAVE();
            return WPS_STATUS_FAIL;
        }

        /* Auth Type is SHARED/OPEN */
        fprintf(stream, "%s\n", "network={");
        /* ssid */
        fprintf(stream, "%s%c", "ssid=", quotation_mark);
        for (i = 0; i < pCredential->ssid_length; i++) {
            /* Avoid null character */
            if (pCredential->ssid[i] != 0)
                fprintf(stream, "%c", pCredential->ssid[i]);
        }
        fprintf(stream, "%c\n", quotation_mark);

        /* key_mgmt */
        fprintf(stream, "%s\n", "key_mgmt=NONE");

        if (pCredential->encry_type == ENCRYPTION_TYPE_WEP) {
            /* WEP Key */
            /* 
             * Note : WEP Key Index of wpa_supplicant is "0" based index,
             *        but we use "1" based index here for Buffalo AP issue
             */
            /* 
             * If WEP transmit key is available, use it for configuration.
             */
            if (pCredential->wep_tx_key_index) {
                /* WEP Key Index of wpa_supplicant is "0" based index */
                fprintf(stream, "%s%d=", "wep_key",
                        pCredential->wep_tx_key_index - 1);
            } else if (pCredential->network_key_index) {
                /* WEP Key Index of wpa_supplicant is "0" based index */
                fprintf(stream, "%s%d=", "wep_key",
                        pCredential->network_key_index - 1);
            }

            /* 
             * Length of Key is 10 or 26 implies that data is HEX character.
             * Should ignore the quotation mark.
             */

            if (pCredential->network_key_len == 10 ||
                pCredential->network_key_len == 26) {
                for (i = 0; i < pCredential->network_key_len; i++) {
                    fprintf(stream, "%c", (char) pCredential->network_key[i]);
                }
                fprintf(stream, "\n");
            }
            /* Length of Key is 5 or 13 implies that data is ASCII character */
            /* 
             * Buffalo AP will send 5 bytes data (0x12-0x34-0x56-0x78-0x90)
             * in M8 message, but it's actually HEX Key value.
             * So we will convert 5 or 13 byte data to HEX and output it
             * like wep_key0=1234567890.
             */
            else if (pCredential->network_key_len == 5 ||
                     pCredential->network_key_len == 13) {
                for (i = 0; i < pCredential->network_key_len; i++) {
                    fprintf(stream, "%02x", pCredential->network_key[i]);
                }
                fprintf(stream, "\n");
            }

            /* Tx Key Index */
            if (pCredential->wep_tx_key_index) {
                /* Tx Key Index of wpa_supplicant is "0" based index */
                fprintf(stream, "%s%d\n", "wep_tx_keyidx=",
                        pCredential->wep_tx_key_index - 1);
            } else if (pCredential->network_key_index) {
                /* Tx Key Index of wpa_supplicant is "0" based index */
                fprintf(stream, "%s%d\n", "wep_tx_keyidx=",
                        pCredential->network_key_index - 1);
            }

            /* auth_alg */
            if (pCredential->auth_type == AUTHENTICATION_TYPE_SHARED) {
                fprintf(stream, "%s\n", "auth_alg=SHARED");
            }
        }

        fprintf(stream, "}\n");
    } else {
        printf("ERROR: Unexpected Auth Type !\n");
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return ret;
}
#endif

BOOL suggested_network_exists(CREDENTIAL_DATA *pCredential)
{
    bool scanning;
    bool ret = FALSE;
    wifi_intf_scan_info_t *pScanResults = 0;

    if ((pCredential->ssid_length > 0) && (pCredential->ssid_length <= MAX_SSID_NAME_LEN))
    {
        wirelessStartScan(pCredential->ssid);

        wifi_intf_get_var_is_wireless_scanning(&scanning);
        while(scanning)
        {
            tx_thread_sleep(5);
            wifi_intf_get_var_is_wireless_scanning(&scanning);
        }

        pScanResults = (wifi_intf_scan_info_t*)MEM_MALLOC(sizeof(wifi_intf_scan_info_t));

        wifi_intf_get_var_scan_info(pScanResults);

        if ((pScanResults->NumSSID > 0) && 
            (strcmp((char *)pCredential->ssid, (char *)pScanResults->networks[0].SSIDNames) == 0))
        {
            // Credential looks valid
            ret = TRUE;
        }

        MEM_FREE_AND_NULL(pScanResults);
    }

    return ret;
}

/** 
 *  @brief  Write Network Credential to output file
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS--success, WPS_STATUS_FAIL--fail
 */
int
wps_write_to_config_file(PWPS_INFO pwps_info)
{
    int    i = 0;
    CREDENTIAL_DATA *pCredential = NULL;
    BOOL isValid = TRUE;
    wifi_intf_comm_mode_t comm_mode;
    uint8_t ssid_buf[MAX_SSID_NAME_LEN];
    wifi_intf_security_mode_t sec_mode;
    wifi_intf_wpa_encryp_mode_t wpa_encryp_mode = WPA_TKIP_AND_AES;
    wifi_intf_input_key_t input_key;
    uint8_t passphrase[MAX_PASS_PHRASE];
    int ret = WPS_STATUS_SUCCESS;

    ENTER();

    // At this point, we want to become intentionally impatient.
    // We will try to send the "done" message nicely, but won't
    // wait around long to get the final ack
    pwps_info->wps_msg_max_retry = 2;
    pwps_info->wps_msg_timeout = 4000;

    DPRINTF((DBG_SOFT | DBG_OUTPUT), ("WPS succesfully retrieved %d network configuration option(s):\n", num_cred));
    for (i = 0; i < num_cred; i++)
    {
        DPRINTF((DBG_SOFT | DBG_OUTPUT), ("  %d: %s\n", i, pwps_info->registrar.cred_data[i].ssid));
    }
    for (i = 0; i < num_cred; i++)
    {
        // For WiFi certifcation, we need to be able to pass a test where they
        // hand us two credentials -- one of which (the second one) is valid, but
        // the other is not.  Scan to determine if they are really out there and
        // choose the one we can actually see.
        if (suggested_network_exists(&(pwps_info->registrar.cred_data[i])))
        {
            pCredential = &(pwps_info->registrar.cred_data[i]);
        }
    }
    if (pCredential == NULL)
    {
        // We weren't able to verify that the network is actually there.
        // This happens for a variety of reasons, but is most common when the
        // AP took the opportunity to change its SSID while running WPS.
        // Just trust them.
        pCredential = &(pwps_info->registrar.cred_data[0]);
    }

    wps_printf(DEBUG_POST_RUN, "Create config for wpa_supplicant\n");

    comm_mode = INFRASTRUCTURE;

    memcpy(ssid_buf, pCredential->ssid, pCredential->ssid_length);
    ssid_buf[pCredential->ssid_length] = '\0';

    // Check for WPA/WPA2
    if (pCredential->auth_type & AUTHENTICATION_TYPE_WPAPSK ||
        pCredential->auth_type & AUTHENTICATION_TYPE_WPA    ||
        pCredential->auth_type & AUTHENTICATION_TYPE_WPA2   ||
        pCredential->auth_type & AUTHENTICATION_TYPE_WPA2PSK)
    {
        // Check for WPA2 first
        if (pCredential->auth_type & AUTHENTICATION_TYPE_WPA2   ||
            pCredential->auth_type & AUTHENTICATION_TYPE_WPA2PSK)
        {
            // WPA2
            wps_printf(DEBUG_POST_RUN, "Authentication type is WPA2\n");
            
            sec_mode = WPA2_PSK;
            wpa_encryp_mode = WPA_AES;
        }
        else
        {
            // Must be WPA
            wps_printf(DEBUG_POST_RUN, "Authentication type is WPA\n");
            sec_mode = WPA_PSK;
            wpa_encryp_mode = WPA_TKIP_AND_AES;
        }

        /*
         * If length of key equals to 64, data is HEX character.
         */
        if (pCredential->network_key_len == 64)
        {
            input_key = HEXADECIMAL;
        }
        /* Data is ASCII character */
        else
        {
            input_key = ALPHANUMERIC;
        }

        if ((pCredential->network_key_len >= MIN_PASS_PHRASE) && (pCredential->network_key_len <= MAX_PASS_PHRASE))
        {
            memset(passphrase, 0, sizeof(passphrase));
            memcpy(passphrase, pCredential->network_key, pCredential->network_key_len);
            passphrase[pCredential->network_key_len] = '\0';
            wps_printf(MSG_INFO, "WPS determined PassPhrase: %s\n", passphrase);
        }
        else
        {
            isValid = FALSE;
        }
    }
    else if (pCredential->auth_type & AUTHENTICATION_TYPE_OPEN ||
             pCredential->auth_type & AUTHENTICATION_TYPE_SHARED)
    {  
        sec_mode = OPEN_SYSTEM;
    }
    else
    {
        isValid = FALSE;
    }

    if (isValid)
    {
        if (strcmp(wps_global.ifname, "wfd0") != 0)
        {
            // They ran WPS and succeeded -- assume they want the radio and station on now.
            //        wifi_hw_set_var_is_enabled(true);
            wifi_intf_set_var_is_enabled(WIFI_IFACE_ID_STATION, true);

            // Set the variables
            wifi_intf_set_var_ssid(WIFI_IFACE_ID_STATION, pCredential->ssid, pCredential->ssid_length);
            wifi_intf_set_var_comm_mode(WIFI_IFACE_ID_STATION, comm_mode);
            wifi_intf_set_var_sec_mode(WIFI_IFACE_ID_STATION, sec_mode);
            wifi_intf_set_var_wpa_encryp_mode(WIFI_IFACE_ID_STATION, wpa_encryp_mode);
            wifi_intf_set_var_wpa_passphrase(WIFI_IFACE_ID_STATION, passphrase, pCredential->network_key_len);
        } else {
            // They ran WPS and succeeded
            wifi_intf_set_var_is_enabled(WIFI_IFACE_ID_WFD, true);

            // Set the variables
            wifi_intf_set_var_ssid(WIFI_IFACE_ID_WFD, pCredential->ssid, pCredential->ssid_length);
            wifi_intf_set_var_comm_mode(WIFI_IFACE_ID_WFD, comm_mode);
            wifi_intf_set_var_sec_mode(WIFI_IFACE_ID_WFD, sec_mode);
            wifi_intf_set_var_wpa_encryp_mode(WIFI_IFACE_ID_WFD, wpa_encryp_mode);
            wifi_intf_set_var_wpa_passphrase(WIFI_IFACE_ID_WFD, passphrase, pCredential->network_key_len);
        }
        
        updateWPSOutcome(WPS_STATE_SUCCESS);

        pwps_info->wps_valid_data = WPS_SET;
    }
    else
    {
        DPRINTF((DBG_SOFT | DBG_OUTPUT), ("WPS Credentials INVALID!\n"));
        wps_printf(MSG_INFO, "WPS received invalid data from the AP\n");
    }

    LEAVE();
    return ret;
}

/** 
 *  @brief  Compute checksum value of PIN (8th digit of PIN)
 *
 *  @param PIN      PIN value
 *  @return         Checksum of PIN
 */
#if 0
static int
ComputeChecksum(unsigned long int PIN)
{
    u32 accum = 0;
    int digit;

    ENTER();

    PIN *= 10;
    accum += 3 * ((PIN / 10000000) % 10);
    accum += 1 * ((PIN / 1000000) % 10);
    accum += 3 * ((PIN / 100000) % 10);
    accum += 1 * ((PIN / 10000) % 10);
    accum += 3 * ((PIN / 1000) % 10);
    accum += 1 * ((PIN / 100) % 10);
    accum += 3 * ((PIN / 10) % 10);

    LEAVE();

    digit = (accum % 10);
    return (10 - digit) % 10;
}
#endif

/** 
 *  @brief  Process Encryption type flags
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             Bitmask result of Encryption flags
 */
static inline int
wps_process_encryption_type_flags(PWPS_INFO pwps_info)
{
    unsigned int encr_bit_mask = 0;
    encr_bit_mask =
        pwps_info->enrollee.encry_type_flag & pwps_info->registrar.
        encry_type_flag;
    return encr_bit_mask;
}

/** 
 *  @brief  Process Authentication type flags
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             Bitmask result of Authentication flags
 */
static inline int
wps_process_authentication_type_flags(PWPS_INFO pwps_info)
{
    unsigned int auth_bit_mask = 0;
    auth_bit_mask =
        pwps_info->enrollee.auth_type_flag & pwps_info->registrar.
        auth_type_flag;
    return auth_bit_mask;
}

#ifdef HAVE_WSD
static u16
wps_vertical_pair_vendor_extension(PWPS_INFO pwps_info, u8 *ptr)
{
    PTLV_DATA_HEADER ptlv, ptlv2;
    u16 message_length = 0;

    #define MICROSOFT_VENDOR_ID_1   0x00
    #define MICROSOFT_VENDOR_ID_2   0x01
    #define MICROSOFT_VENDOR_ID_3   0x37
    #define MICROSOFT_VENDOR_ID_LEN 0x3
    #define VPI_TVL                 0x1001
    #define VPI_TVL_LEN             0x2
    #define VPI_TRANSPORT           0x01
    #define VPI_PROFILE_REQUEST     0x01
    #define UUID_TVL                0x1002
    #define UUID_TVL_LEN            0x10

    /* Vendor Extension for Vertical Pairing */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Vendor_Extension);
    ptlv->length = 0;
    ptr += SZ_TLV_HEADER;

    /* Microsoft Vendor ID 0x000137 */
    *ptr++ = MICROSOFT_VENDOR_ID_1;
    *ptr++ = MICROSOFT_VENDOR_ID_2;
    *ptr++ = MICROSOFT_VENDOR_ID_3;
    ptlv->length += MICROSOFT_VENDOR_ID_LEN;

    /* VPI */
    ptlv2 = (PTLV_DATA_HEADER) ptr;
    ptlv2->type = htons(VPI_TVL);
    ptlv2->length = htons(VPI_TVL_LEN);
    ptr += SZ_TLV_HEADER;
    *ptr++ = VPI_TRANSPORT;
    *ptr++ = VPI_PROFILE_REQUEST;
    ptlv->length += SZ_TLV_HEADER + VPI_TVL_LEN;

    /* UUID (Enrollee) */
    ptlv2 = (PTLV_DATA_HEADER) ptr;
    ptlv2->type = htons(UUID_TVL);
    ptlv2->length = htons(pwps_info->enrollee.wps_uuid_length);
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.wps_uuid, pwps_info->enrollee.wps_uuid_length);

    ptlv->length += SZ_TLV_HEADER + pwps_info->enrollee.wps_uuid_length;
    message_length = SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    return( message_length );
}
#endif

/** 
 *  @brief  Modify R-HASH failure count and check for brute force attack.
 *  Update AP setup locked variable.
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             Bitmask result of Authentication flags
 */
void
wps_check_for_ap_setup_locked_scenario(PWPS_INFO pwps_info)
{

    u32 sec, usec;
    int ret;
    ENTER();

    if (pwps_info->wps_r_hash_failure_count == 0) {
        /* Start timer for R-Hash failure count */
        sec = WPS_R_HASH_TIMEOUT;
        usec = 0;
        wps_start_timer(sec, usec, wps_r_hash_failure_count_timer_handler,
                        pwps_info);
        pwps_info->set_timer = WPS_SET;
    }
    pwps_info->wps_r_hash_failure_count++;
    wps_printf(DEBUG_WPS_STATE, "Hash failure count %d\n",
               pwps_info->wps_r_hash_failure_count);
    if (pwps_info->wps_r_hash_failure_count >= MAX_R_HASH_FAILURE_COUNT) {
        wps_printf(DEBUG_WPS_STATE,
            "Max PIN failure count reached for AP configuration. AP setup is locked!!\n");
        pwps_info->wps_ap_setup_locked = WPS_SET;

        if (pwps_info->wps_session_active == WPS_SET
            && pwps_info->auto_enrollee_in_progress == WPS_CANCEL) {
            ret = wps_wlan_ie_config(SET_WPS_AP_SESSION_ACTIVE_IE, &ie_index);
            if (ret != WPS_STATUS_SUCCESS) {
                wps_printf(MSG_ERROR, "WPS Registrar failed to config\n");
            }
            if (pwps_info->enrollee.version >= WPS_VERSION_2DOT0) {
                ret =
                    wps_wlan_ie_config(SET_WPS_AP_SESSION_ACTIVE_AR_IE,
                                       &ap_assocresp_ie_index);
                if (ret != WPS_STATUS_SUCCESS) {
                    wps_printf(MSG_WARNING, "WPS IE configuration failure.\n");
                }
            }
        } else {

            ret = wps_wlan_ie_config(SET_WPS_AP_SESSION_INACTIVE_IE, &ie_index);
            if (ret != WPS_STATUS_SUCCESS) {
                wps_printf(MSG_ERROR, "WPS Registrar failed to config\n");
            }
            if (pwps_info->enrollee.version >= WPS_VERSION_2DOT0) {
                ret =
                    wps_wlan_ie_config(SET_WPS_AP_SESSION_INACTIVE_AR_IE,
                                       &ap_assocresp_ie_index);
                if (ret != WPS_STATUS_SUCCESS) {
                    wps_printf(MSG_WARNING, "WPS IE configuration failure.\n");
                }
            }
        }

        /* Cancel Hash failure counter Timer */
        wps_cancel_timer(wps_r_hash_failure_count_timer_handler, pwps_info);
        pwps_info->wps_r_hash_failure_count = 0;

        /* Start timer for AP Setup Locked time */
        sec = WPS_AP_SETUP_LOCKED_TIMEOUT;
        usec = 0;
        wps_start_timer(sec, usec, wps_ap_setup_locked_timer_handler,
                        pwps_info);
        pwps_info->set_timer = WPS_SET;

    }
    LEAVE();
}

/********************************************************
        Global Functions
********************************************************/
/** 
 *  @brief  Prepare and Send EAP Identity Frame for EAP_RESPONSE
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_response_identity_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    u8 *ptr;
    u16 length;
    int ret;
    const char *id_str = NULL;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    peap_wps_frame->code = EAP_RESPONSE;
    peap_wps_frame->identifier = pwps_info->peer_id;
    peap_wps_frame->type = EAP_TYPE_IDENTITY;
    peap_wps_frame->length = 5;
    ptr += peap_wps_frame->length;

    id_str = ((pwps_info->role == WPS_ENROLLEE)
              || (IS_DISCOVERY_ENROLLEE(pwps_info))
              ? wps_enrollee_identity : wps_registrar_identity);

    memcpy(ptr, id_str, strlen(id_str));
    peap_wps_frame->length += strlen((char *) id_str);

    length = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;

    pwps_info->restart_by_M2D = WPS_CANCEL;

    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process EAP Identity Frame for EAP_RESPONSE
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Length of EAP Identity frame
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_response_identity_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) buf;
    wps_printf(DEBUG_WPS_STATE,
               "peap_wps_frame->identifier=0x%x, pwps_info->id=0x%x\n",
               peap_wps_frame->identifier, pwps_info->id);

    if (peap_wps_frame->identifier > (pwps_info->id))
        return WPS_STATUS_FAIL;

    buf += 5;                   /* point to identity string */
    size = ntohs(size);
    size -= 5;

    pwps_info->role_switched = WPS_CANCEL;

    if (memcmp(buf, wps_registrar_identity,
               strlen((char *) wps_registrar_identity)) == 0) {
        wps_printf(DEBUG_WPS_MSG, "Peer device is Registrar\n");
        if ((wps_s->bss_type == BSS_TYPE_UAP &&
             pwps_info->role == WPS_REGISTRAR)) {

            wps_printf(DEBUG_WPS_MSG, "Switching Role to Enrollee...\n");
            memcpy(pwps_info->registrar.mac_address,
                   pwps_info->enrollee.mac_address, ETH_ALEN);
            memcpy(pwps_info->enrollee.mac_address, wps_s->my_mac_addr,
                   ETH_ALEN);

            wps_hexdump(DEBUG_WPS_MSG, "Enrollee Mac Address",
                        pwps_info->enrollee.mac_address, ETH_ALEN);
            wps_hexdump(DEBUG_WPS_MSG, "Registrar Mac Address",
                        pwps_info->registrar.mac_address, ETH_ALEN);

            /* Read Device info from config file & generate UUID */
            wps_update_device_info(pwps_info, wps_s, WPS_ENROLLEE);

            /* Do this after config_read to avoid overwrite */
            pwps_info->role = WPS_ENROLLEE;
            pwps_info->role_switched = WPS_SET;

        }
    } else if (memcmp(buf, wps_enrollee_identity,
                      strlen((char *) wps_enrollee_identity)) == 0) {
        wps_printf(DEBUG_WPS_MSG, "Peer device is Enrollee\n");
        if ((wps_s->bss_type == BSS_TYPE_UAP &&
             pwps_info->role == WPS_ENROLLEE)) {

            wps_printf(DEBUG_WPS_MSG, "Switching Role to Registrar...\n");

            memcpy(pwps_info->enrollee.mac_address,
                   pwps_info->registrar.mac_address, ETH_ALEN);
            memcpy(pwps_info->registrar.mac_address, wps_s->my_mac_addr,
                   ETH_ALEN);

            wps_hexdump(DEBUG_WPS_MSG, "Enrollee Mac Address",
                        pwps_info->enrollee.mac_address, ETH_ALEN);
            wps_hexdump(DEBUG_WPS_MSG, "Registrar Mac Address",
                        pwps_info->registrar.mac_address, ETH_ALEN);

            /* Read Device info from config file & generate UUID */
            wps_update_device_info(pwps_info, wps_s, WPS_REGISTRAR);

            /* Do this after config_read to avoid overwrite */
            pwps_info->role = WPS_REGISTRAR;
            pwps_info->role_switched = WPS_SET;

        }
    } else {
        wps_printf(DEBUG_WPS_MSG, "Unknown EAP Response Identity. Quitting\n");
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send EAP Identity Frame for EAP_REQUEST
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_request_identity_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    u8 *ptr;
    u16 length;
    int ret;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    peap_wps_frame->code = EAP_REQUEST;
    peap_wps_frame->identifier = pwps_info->id++;
    peap_wps_frame->type = EAP_TYPE_IDENTITY;
    peap_wps_frame->length = 5;
    ptr += peap_wps_frame->length;
    memcpy(ptr, wps_registrar_identity,
           strlen((char *) wps_registrar_identity));

    peap_wps_frame->length += strlen((char *) wps_registrar_identity);

    length = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;

    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process EAP Identity Frame for EAP_REQUEST
 *
 *  @param buf          A pointer to EAP frame
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_request_identity_process(u8 * buf)
{
    u8 *ptr;

    ENTER();

    ptr = (buf + 5);

    if (memcmp(ptr, wps_registrar_identity,
               strlen((char *) wps_registrar_identity)) != 0) {
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

#define EAP_FRAGMENTATION_START(winfo, buf, len) do{   \
    winfo->frag_tx_in_prog=1;                      \
    winfo->frag_msg_tot_len=len;                \
    winfo->frag_msg_cur_len=0;                  \
    memcpy(&winfo->frag_buf[0], buf, len);      \
}while(0)

#define EAP_FRAGMENTATION_END(winfo) do{\
    winfo->frag_tx_in_prog=0;           \
    winfo->frag_msg_tot_len=0;          \
    winfo->frag_msg_cur_len=0;          \
}while(0)

int
wps_send_next_fragment(PWPS_INFO pwps_info, WPS_DATA * wps_s)
{
    u8 *ptr;
    int plsize, ret = WPS_STATUS_SUCCESS, data_left;
    u16 be_tot_len;
    u16 len = 0;
    PEAP_FRAME_HEADER peap_wps_frame;

    if (!pwps_info->frag_tx_in_prog) {
        ret = WPS_STATUS_FAIL;
        goto done;
    }

    data_left = pwps_info->frag_msg_tot_len - pwps_info->frag_msg_cur_len;

    if (data_left <= 0) {
        ret = WPS_STATUS_FAIL;
        goto done;
    }

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    len = wps_eap_message_header_prepare(pwps_info,
                                         (wps_s->bss_type ==
                                          BSS_TYPE_UAP) ? EAP_REQUEST :
                                         EAP_RESPONSE, pwps_info->peer_id,
                                         WPS_Msg);
    ptr += len;

    if (data_left <= pwps_info->frag_thres) {
        plsize = data_left;
    } else {
        /* More frags to go */
        plsize = pwps_info->frag_thres;
        peap_wps_frame->flags |= (EAP_FLAGS_MORE_FRAG);
    }

    if (!pwps_info->frag_msg_cur_len) {
        be_tot_len = htons(pwps_info->frag_msg_tot_len);
        memcpy(ptr, &be_tot_len, sizeof(u16));
        ptr += sizeof(u16);
        len += sizeof(u16);
        peap_wps_frame->flags |= (EAP_FLAGS_LEN_FIELD);
    }

    memcpy(ptr, &pwps_info->frag_buf[pwps_info->frag_msg_cur_len], plsize);
    pwps_info->frag_msg_cur_len += plsize;
    len += plsize;
    ptr += plsize;

    peap_wps_frame->length = htons(len);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) len);

    if (ret < 0)
        ret = WPS_STATUS_FAIL;
    else
        ret = WPS_STATUS_SUCCESS;

    if (pwps_info->frag_msg_cur_len >= pwps_info->frag_msg_tot_len) {
        /* All Frags sent */
        wps_printf(DEBUG_WPS_MSG, "Tx Frag Complete\n");
        /* keep a copy of pkt for Auth check */
        WPS_SAVE_PKT(pwps_info, &pwps_info->frag_buf[0],
                     pwps_info->frag_msg_tot_len);
        EAP_FRAGMENTATION_END(pwps_info);
    }

  done:
    LEAVE();
    return ret;
}

int
wps_setup_tx_frag(PWPS_INFO pwps_info, WPS_DATA * wps_s, u8 * buffer, int len)
{
    wps_hexdump(DEBUG_VENDOR_TLV, "Unfrag TX Pkt", buffer, len);

    wps_printf(DEBUG_WPS_MSG, "Tx Frag Start\n");
    EAP_FRAGMENTATION_START(pwps_info, buffer + SZ_EAP_WPS_FRAME_HEADER,
                            len - SZ_EAP_WPS_FRAME_HEADER);

    return wps_send_next_fragment(pwps_info, wps_s);
}

/** 
 *  @brief  Prepare and Send WPS M1 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M1_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u16 msg_value_short, offset, message_length = 0;
    u32 msg_value_long;
    u8 *ptr;
    u8 msg_value_char;
    int ret;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info,
                                            (wps_s->bss_type ==
                                             BSS_TYPE_UAP) ? EAP_REQUEST :
                                            EAP_RESPONSE, pwps_info->peer_id,
                                            WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M1);
    message_length += offset;

    /* UUID-E */
    ptr += offset;
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    message_length += offset;

    /* MAC Address */
    ptr += offset;
    offset = wps_attribute_mac_address_prepare(pwps_info, ptr);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Public Key */
    offset = wps_attribute_public_key_prepare(pwps_info, WPS_ENROLLEE, ptr);
    message_length += offset;

    /* Authentication Type Flags */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Authentication_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.auth_type_flag);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encryption Type Flags */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Encryption_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.encry_type_flag);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Connection Type Flags */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Connection_Type_Flags);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = CONNECTION_TYPE_ESS;
    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.config_methods);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Simple Config State */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Simple_Config_State);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    /* PF3 Ralink FIX (Don't send config state as CONFIGURED for enrollee) */
    //msg_value_char = SC_NOT_CONFIGURED_STATE;
    msg_value_char = pwps_info->wps_device_state;

    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Manufacture */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Manufacturer);
    ptlv->length = pwps_info->enrollee.manufacture_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.manufacture, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Name */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Model_Name);
    ptlv->length = pwps_info->enrollee.model_name_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.model_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Number */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Model_Number);
    ptlv->length = pwps_info->enrollee.model_number_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.model_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Serial Number */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Serial_Number);
    ptlv->length = pwps_info->enrollee.serial_number_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.serial_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Name);
    ptlv->length = pwps_info->enrollee.device_name_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* RF Bands */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_RF_Band);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, &pwps_info->enrollee.rf_bands, ptlv->length);
    wps_printf(DEBUG_WPS_MSG, "Enrollee rf_bands = 0x%x\n", pwps_info->enrollee.rf_bands);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Association State */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Association_State);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(0x0001);
    memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Device Password ID */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Password_ID);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.updated_device_password_id);

    wps_printf(DEBUG_WPS_MSG, "Enrollee DevID = 0x%x\n", msg_value_short);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Configuration Error */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* OS Version */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_OS_Version);
    ptlv->length = SZ_OS_VERSION;
    ptr += SZ_TLV_HEADER;
    msg_value_long = htonl(pwps_info->enrollee.os_version);
    memcpy(ptr, &msg_value_long, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

#ifdef HAVE_WSD
    // Vendor Extenstion for vertical pairing
    offset = wps_vertical_pair_vendor_extension(pwps_info, ptr);
    message_length += offset;
    ptr += offset;
#endif

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    peap_wps_frame->length += message_length;
    offset = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, (size_t) offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Subfunctoin: Process received vendor extension attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param data         A pointer to attribute
 *  @param length       actual length
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
static int
wps_process_wfa_vendor_ext(PWPS_INFO pwps_info, u8 * data, u16 length)
{
    PSUBELE_DATA_HEADER pele;
    int ret = WPS_STATUS_SUCCESS;
    u8 wps_broadcast_mac[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
    u8 offset = 0, auth_tlv_len = 0;
    u8 *data_end = data + length;
    MESSAGE_ENROLLEE_REGISTRAR *enr_reg;

    WPS_DATA *wps_s = &wps_global;
    ENTER();
    pele = (SUBELE_DATA_HEADER *) data;
    if (pwps_info->role == WPS_REGISTRAR) {
        enr_reg = &pwps_info->enrollee;
    } else {
        enr_reg = &pwps_info->registrar;
    }

    while ((void *) data < (void *) data_end) {
        switch (data[0]) {
        case SC_Version2:
            memcpy(&enr_reg->version2, data + 2, SZ_VERSION2);
            wps_printf(DEBUG_WPS_MSG, "Version2 = 0x%x\n", enr_reg->version2);
            break;

        case SC_AuthorizedMACs:
            pele = (PSUBELE_DATA_HEADER) data;
            auth_tlv_len = pele->length;

            while (auth_tlv_len > 0) {

                if (memcmp(wps_s->my_mac_addr, &data[2] + offset, ETH_ALEN) == 0
                    || memcmp(wps_broadcast_mac, &data[2] + offset,
                              ETH_ALEN) == 0) {
                    pwps_info->enrollee_in_authorized_mac = WPS_SET;
                    wps_printf(DEBUG_WPS_MSG,
                               "Enrollee Mac address found in Authorized Mac address list of Registrar!\n");
                    goto done;
                }
                offset += ETH_ALEN;
                auth_tlv_len -= ETH_ALEN;
            }
            pwps_info->enrollee_in_authorized_mac = WPS_CANCEL;
            wps_printf(DEBUG_WPS_MSG,
                       "Enrollee Mac address not found in Authorized Mac address list of Registrar!\n");
            break;

        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown WFA Subele = 0x%x\n", data[0]);
            ret = WPS_STATUS_FAIL;
            goto done;
        }

        data += 2 + data[1];
    }

  done:
    LEAVE();
    return ret;
}

/** 
 *  @brief  Process received vendor extension attribute
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param data         A pointer to attribute
 *  @param tlv_length   Length of TLV
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_process_attrib_vendor_ext(PWPS_INFO pwps_info, u8 * data, u16 tlv_length)
{
    int ret = WPS_STATUS_SUCCESS;
    ENTER();
    if (tlv_length < WPS_VENDOR_EXT_ID_LEN) {
        ret = WPS_STATUS_FAIL;
        goto done;
    }
    if (!memcmp(data, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN)) {
        ret =
            wps_process_wfa_vendor_ext(pwps_info, data + WPS_VENDOR_EXT_ID_LEN,
                                       tlv_length - WPS_VENDOR_EXT_ID_LEN);
    }

  done:
    LEAVE();
    return ret;
}

/** 
 *  @brief  Process received WPS M1 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M1_frame_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length;

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER) buf;

    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02) {
        ptlv =
            (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER +
                                SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len =
            (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    } else {
        ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type) {
        case SC_Version:
            memcpy(&pwps_info->enrollee.version, data, tlv_length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
            if (pwps_info->enrollee.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(M1) Unknown WPS Version = 0x%x\n",
                           pwps_info->enrollee.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_M1)
                return WPS_STATUS_FAIL;
            break;
        case SC_UUID_E:
            memcpy(pwps_info->enrollee.wps_uuid, data, tlv_length);
            pwps_info->enrollee.wps_uuid_length = tlv_length;
            break;
        case SC_MAC_Address:
            if (memcmp(pwps_info->enrollee.mac_address, data, tlv_length) != 0) {
                wps_printf(MSG_WARNING,
                           "Warning : Enrollee MAC Address Not Matched !\n");
                wps_hexdump(DEBUG_WPS_MSG, "SC_MAC_Address", data, tlv_length);
                memcpy(pwps_info->enrollee.mac_address, data, tlv_length);
            } else {
                wps_printf(DEBUG_WPS_MSG,
                           "INFO : Enrollee MAC Address Matched !\n");
            }
            break;
        case SC_Enrollee_Nonce:
            memcpy(pwps_info->enrollee.nonce, data, tlv_length);
            break;
        case SC_Public_Key:
            memcpy(pwps_info->enrollee.public_key, data, tlv_length);
            break;
        case SC_Authentication_Type_Flags:
            memcpy(&pwps_info->enrollee.auth_type_flag, data, tlv_length);
            pwps_info->enrollee.auth_type_flag =
                ntohs(pwps_info->enrollee.auth_type_flag);
            if (!wps_process_authentication_type_flags(pwps_info)) {
                wps_printf(MSG_ERROR,
                           "Authentication type flag from Enrollee dont match with Registrar.\n");
            }
            break;
        case SC_Encryption_Type_Flags:
            memcpy(&pwps_info->enrollee.encry_type_flag, data, tlv_length);
            pwps_info->enrollee.encry_type_flag =
                ntohs(pwps_info->enrollee.encry_type_flag);
            if (!wps_process_encryption_type_flags(pwps_info)) {
                wps_printf(MSG_ERROR,
                           "Encryption type flag from Enrollee dont match with Registrar.\n");
            }
            break;
        case SC_Connection_Type_Flags:
            memcpy(&pwps_info->enrollee.connection_type_flag, data, tlv_length);
            break;
        case SC_Config_Methods:
            memcpy(&pwps_info->enrollee.config_methods, data, tlv_length);
            pwps_info->enrollee.config_methods =
                ntohs(pwps_info->enrollee.config_methods);
            break;
        case SC_Simple_Config_State:
            memcpy(&pwps_info->enrollee.simple_config_state, data, tlv_length);
            break;
        case SC_Manufacturer:
            memcpy(pwps_info->enrollee.manufacture, data, tlv_length);
            pwps_info->enrollee.manufacture_length = tlv_length;
            break;
        case SC_Model_Name:
            memcpy(pwps_info->enrollee.model_name, data, tlv_length);
            pwps_info->enrollee.model_name_length = tlv_length;
            break;
        case SC_Model_Number:
            memcpy(pwps_info->enrollee.model_number, data, tlv_length);
            pwps_info->enrollee.model_number_length = tlv_length;
            break;
        case SC_Serial_Number:
            memcpy(pwps_info->enrollee.serial_number, data, tlv_length);
            pwps_info->enrollee.serial_number_length = tlv_length;
            break;
        case SC_Primary_Device_Type:
            memcpy(pwps_info->enrollee.primary_device_type, data, tlv_length);
            break;
        case SC_Device_Name:
            memcpy(pwps_info->enrollee.device_name, data, tlv_length);
            pwps_info->enrollee.device_name_length = tlv_length;
            break;
        case SC_RF_Band:
            memcpy(&pwps_info->enrollee.rf_bands, data, tlv_length);
            break;
        case SC_Association_State:
            memcpy(&pwps_info->enrollee.association_state, data, tlv_length);
            break;
        case SC_Device_Password_ID:
            memcpy(&pwps_info->enrollee.device_password_id, data, tlv_length);
            pwps_info->enrollee.device_password_id =
                ntohs(pwps_info->enrollee.device_password_id);
            break;
        case SC_Configuration_Error:
            memcpy(&pwps_info->enrollee.configuration_error, data, tlv_length);
            pwps_info->enrollee.configuration_error =
                ntohs(pwps_info->enrollee.configuration_error);
            wps_printf(DEBUG_WPS_MSG, "SC_Configuration_Error(M1): %d\n",
                       pwps_info->enrollee.configuration_error);
            break;
        case SC_OS_Version:
            memcpy(&pwps_info->enrollee.os_version, data, tlv_length);
            pwps_info->enrollee.os_version =
                ntohl(pwps_info->enrollee.os_version);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown message_Type = 0x%x\n", tlv_type);
            break;
        }

        len = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    /* save the last tx message before saving the rx message into last message */
    memcpy(&pwps_info->last_tx_message,
           &pwps_info->last_message, sizeof(MESSAGE_BUFFER));

    wifi_intf_uap_set_state(WLAN_WPS_REGISTRAR_DEVICE_CONNECTING, 
                            (char *) pwps_info->enrollee.device_name,
                            pwps_info->enrollee.device_name_length, 
                            (unsigned char *) pwps_info->enrollee.mac_address, 
                            NULL);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Validate Authenticator
 *
 *  @param wps_frm_body     A pointer to Received WPS frame body
 *  @param wps_frm_body_len Length of Received WPS frame body
 *  @return                 WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_authenticator_validate(PWPS_INFO pwps_info,
                           u8 * wps_frm_body, u16 wps_frm_body_len)
{
    u8 hmacOut[32], *rx_auth;

    if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info))
        ) {
        rx_auth = pwps_info->registrar.authenticator;
    } else {
        rx_auth = pwps_info->enrollee.authenticator;
    }

    /* Generate 32-byte Authenticator */
    wps_authenticator_generate(pwps_info,
                               pwps_info->last_message.message,
                               pwps_info->last_message.length, wps_frm_body,
                               wps_frm_body_len - SZ_TLV_HEADER -
                               SZ_AUTHENTICATOR, hmacOut);

    if (memcmp(rx_auth, hmacOut, SZ_AUTHENTICATOR)) {
        wps_printf(MSG_ERROR, "Rx packet: Invalid Authenticator!\n");
        wps_hexdump(MSG_MSGDUMP, "RX'ed Authenticator",
                    (u8 *) rx_auth, SZ_AUTHENTICATOR);
        wps_hexdump(MSG_MSGDUMP, "Computed Authenticator",
                    (u8 *) hmacOut, SZ_AUTHENTICATOR);
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Derive KDK
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_derive_kdk(PWPS_INFO pwps_info)
{
    DH_PG_PARAMS params;
    u8 *agreed_key, *pub_key, *priv_key;
    u32 AgreedKeyLen;

    ENTER();

    if (pwps_info->role == WPS_ENROLLEE || (IS_DISCOVERY_ENROLLEE(pwps_info))
        ) {
        agreed_key = pwps_info->enrollee.agreed_key;
        pub_key = pwps_info->registrar.public_key;
        priv_key = pwps_info->enrollee.private_key;
    } else {
        agreed_key = pwps_info->registrar.agreed_key;
        pub_key = pwps_info->enrollee.public_key;
        priv_key = pwps_info->registrar.private_key;
    }

    /* DH Key Generation */
    params.generator = &GEN;
    params.generatorLen = 1;
    params.prime = DH_PRIME_1536;
    params.primeLen = sizeof(DH_PRIME_1536);

    MrvDH_Compute(agreed_key, pub_key, WPS_PUB_KEY_LEN,
                  priv_key, WPS_PRIV_KEY_LEN, &params);
    wps_hexdump(DEBUG_WPS_MSG, "Agree Key",
                (u8 *) agreed_key, WPS_AGREE_KEY_LEN);

    AgreedKeyLen = N8_Digits(agreed_key, WPS_AGREE_KEY_LEN);
    wps_printf(DEBUG_WPS_MSG, "Agree Key Length = %d\n", AgreedKeyLen);

    memset(DHKey, 0, sizeof(DHKey));
    Mrv_SHA256(&agreed_key[WPS_AGREE_KEY_LEN - AgreedKeyLen],
               AgreedKeyLen, DHKey);
    wps_hexdump(DEBUG_WPS_MSG, "DH Key", (u8 *) DHKey, 32);

    /* Derivation of KDK */
    memset(HashKdkIn, 0, sizeof(HashKdkIn));
    memcpy(HashKdkIn, pwps_info->enrollee.nonce, WPS_NONCE_SIZE);
    memcpy(HashKdkIn + 16, pwps_info->enrollee.mac_address,
           sizeof(pwps_info->enrollee.mac_address));
    memcpy(HashKdkIn + 16 + 6, pwps_info->registrar.nonce,
           sizeof(pwps_info->registrar.nonce));

    /* Generate KDK Key */
    memset(KDK, 0, sizeof(KDK));
    MrvHMAC_SHA256(DHKey, SHA256_DIGEST_SIZE,
                   HashKdkIn, sizeof(HashKdkIn), KDK, SHA256_DIGEST_SIZE);

    /* Generate Authentication Key, Key Wrap Key */
    memset(AKE_Key, 0, sizeof(AKE_Key));
    MrvKDF(KDK, SHA256_DIGEST_SIZE, AKE_KeyBits, AKE_Key);
    memcpy(pwps_info->auth_key, AKE_Key, AUTH_KEY_LEN);
    memcpy(pwps_info->key_wrap_key, AKE_Key + AUTH_KEY_LEN, KWK_LEN);
    memcpy(pwps_info->emsk, AKE_Key + AUTH_KEY_LEN + KWK_LEN, EMSK_LEN);

    wps_hexdump(DEBUG_WPS_MSG, "Auth Key",
                (u8 *) pwps_info->auth_key, sizeof(pwps_info->auth_key));

    wps_hexdump(DEBUG_WPS_MSG, "Key Wrap Key",
                (u8 *) pwps_info->key_wrap_key,
                sizeof(pwps_info->key_wrap_key));

    LEAVE();

    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS M2 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M2_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u16 msg_value_short, offset, message_len, message_length = 0;
    u32 msg_value_long;
    u8 *ptr;
    u8 msg_value_char;
    int ret;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info,
                                            (wps_s->bss_type ==
                                             BSS_TYPE_UAP) ? EAP_REQUEST :
                                            EAP_RESPONSE, pwps_info->peer_id,
                                            WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M2);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Registrar Nonce */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* UUID-R */
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    message_length += offset;

    /* Public Key */
    ptr += offset;
    offset = wps_attribute_public_key_prepare(pwps_info, WPS_REGISTRAR, ptr);
    message_length += offset;

    /* Authentication Type Flags */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Authentication_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.auth_type_flag);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encryption Type Flags */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Encryption_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.encry_type_flag);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Connection Type Flags */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Connection_Type_Flags);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = CONNECTION_TYPE_ESS;
    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.config_methods);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Manufacture */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Manufacturer);
    ptlv->length = pwps_info->registrar.manufacture_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.manufacture, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Name */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Model_Name);
    ptlv->length = pwps_info->registrar.model_name_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.model_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Number */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Model_Number);
    ptlv->length = pwps_info->registrar.model_number_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.model_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Serial Number */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Serial_Number);
    ptlv->length = pwps_info->registrar.serial_number_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.serial_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Name);
    ptlv->length = pwps_info->registrar.device_name_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* RF Bands */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_RF_Band);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, &pwps_info->registrar.rf_bands, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Association State */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Association_State);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(0x0001);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Configuration Error */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Device Password ID */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Password_ID);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.updated_device_password_id);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* OS Version */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_OS_Version);
    ptlv->length = SZ_OS_VERSION;
    ptr += SZ_TLV_HEADER;
    msg_value_long = htonl(pwps_info->registrar.os_version);
    memcpy(ptr, &msg_value_long, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Derive Keys */
    wps_derive_kdk(pwps_info);

    /* Authenticator */
    message_len = message_length;
    offset = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, (size_t) offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS M2 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M2_frame_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length;

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER) buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02) {
        ptlv =
            (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER +
                                SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len =
            (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    } else {
        ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type) {
        case SC_Version:
            memcpy(&pwps_info->registrar.version, data, tlv_length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
            if (pwps_info->registrar.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(M2) Unknown WPS Version = 0x%x\n",
                           pwps_info->registrar.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_M2)
                return WPS_STATUS_FAIL;
            break;
        case SC_Enrollee_Nonce:
            memcpy(pwps_info->enrollee.nonce, data, tlv_length);
            wps_hexdump(MSG_MSGDUMP, "Enrollee nonce", pwps_info->enrollee.nonce, sizeof(pwps_info->enrollee.nonce));
            break;
        case SC_Registrar_Nonce:
            memcpy(pwps_info->registrar.nonce, data, tlv_length);
            wps_hexdump(MSG_MSGDUMP, "registrar nonce", pwps_info->registrar.nonce, sizeof(pwps_info->registrar.nonce));
            break;
        case SC_UUID_R:
            memcpy(pwps_info->registrar.wps_uuid, data, tlv_length);
            pwps_info->registrar.wps_uuid_length = tlv_length;
            wps_hexdump(MSG_MSGDUMP, "registrar uuid", pwps_info->registrar.wps_uuid, pwps_info->registrar.wps_uuid_length);
            break;
        case SC_Public_Key:
            memcpy(pwps_info->registrar.public_key, data, tlv_length);
            break;
        case SC_Authenticator:
            memcpy(pwps_info->registrar.authenticator, data, tlv_length);
            break;
        case SC_Authentication_Type_Flags:
            memcpy(&pwps_info->registrar.auth_type_flag, data, tlv_length);
            pwps_info->registrar.auth_type_flag =
                ntohs(pwps_info->registrar.auth_type_flag);
            wps_printf(DEBUG_WPS_MSG, "Authentication_Type_Flags(M2) = 0x%04x\n",
                       pwps_info->registrar.auth_type_flag);
            if (!wps_process_authentication_type_flags(pwps_info)) {
                wps_printf(MSG_ERROR,
                           "Authentication type flag from Enrollee dont match with Registrar.\n");
            }
            break;
        case SC_Encryption_Type_Flags:
            memcpy(&pwps_info->registrar.encry_type_flag, data, tlv_length);
            pwps_info->registrar.encry_type_flag =
                ntohs(pwps_info->registrar.encry_type_flag);
            wps_printf(DEBUG_WPS_MSG, "Encryption_Type_Flags(M2) = 0x%04x\n",
                       pwps_info->registrar.encry_type_flag);
            if (!wps_process_encryption_type_flags(pwps_info)) {
                wps_printf(MSG_ERROR,
                           "Encryption type flag from Enrollee dont match with Registrar.\n");
            }
            break;
        case SC_Connection_Type_Flags:
            memcpy(&pwps_info->registrar.connection_type_flag, data,
                   tlv_length);
            break;
        case SC_Config_Methods:
            memcpy(&pwps_info->registrar.config_methods, data, tlv_length);
            pwps_info->registrar.config_methods =
                ntohs(pwps_info->registrar.config_methods);
            wps_printf(DEBUG_WPS_MSG, "Config_Methods(M2) = 0x%04x\n",
                       pwps_info->registrar.config_methods);
            break;
        case SC_Manufacturer:
            memcpy(pwps_info->registrar.manufacture, data, tlv_length);
            pwps_info->registrar.manufacture_length = tlv_length;
            wps_printf(DEBUG_WPS_MSG, "Registrar manufacture: %s\n", pwps_info->registrar.manufacture);
            break;
        case SC_Model_Name:
            memcpy(pwps_info->registrar.model_name, data, tlv_length);
            pwps_info->registrar.model_name_length = tlv_length;
            wps_printf(DEBUG_WPS_MSG, "Registrar model name: %s\n", pwps_info->registrar.manufacture);
            break;
        case SC_Model_Number:
            memcpy(pwps_info->registrar.model_number, data, tlv_length);
            pwps_info->registrar.model_number_length = tlv_length;
            wps_printf(DEBUG_WPS_MSG, "Registrar model num: %s\n", pwps_info->registrar.manufacture);
            break;
        case SC_Serial_Number:
            memcpy(pwps_info->registrar.serial_number, data, tlv_length);
            pwps_info->registrar.serial_number_length = tlv_length;
            wps_printf(DEBUG_WPS_MSG, "Registrar serial num: %s\n", pwps_info->registrar.manufacture);
            break;
        case SC_Primary_Device_Type:
            memcpy(pwps_info->registrar.primary_device_type, data, tlv_length);
            break;
        case SC_Device_Name:
            memcpy(pwps_info->registrar.device_name, data, tlv_length);
            pwps_info->registrar.device_name_length = tlv_length;
            wps_printf(DEBUG_WPS_MSG, "Registrar device name: %s\n", pwps_info->registrar.manufacture);
            break;
        case SC_RF_Band:
            memcpy(&pwps_info->registrar.rf_bands, data, tlv_length);
            wps_printf(DEBUG_WPS_MSG, "RegistrarRFbands(M2) = 0x%02x\n",
                       pwps_info->registrar.rf_bands);
            break;
        case SC_Association_State:
            memcpy(&pwps_info->registrar.association_state, data, tlv_length);
            wps_printf(DEBUG_WPS_MSG, "AssociationState(M2) = 0x%02x\n",
                       pwps_info->registrar.association_state);
            break;
        case SC_Configuration_Error:
            memcpy(&pwps_info->registrar.configuration_error, data, tlv_length);
            pwps_info->registrar.configuration_error =
                ntohs(pwps_info->registrar.configuration_error);
            wps_printf(DEBUG_WPS_MSG, "SC_Configuration_Error(M2): %d\n",
                       pwps_info->registrar.configuration_error);
            break;
        case SC_Device_Password_ID:
            memcpy(&pwps_info->registrar.device_password_id, data, tlv_length);
            break;
        case SC_OS_Version:
            memcpy(&pwps_info->registrar.os_version, data, tlv_length);
            pwps_info->registrar.os_version =
                ntohl(pwps_info->registrar.os_version);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown message_Type = 0x%x\n", tlv_type);
            break;
        }

        len = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    /* Derive Keys */
    wps_derive_kdk(pwps_info);

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len)
        != WPS_STATUS_SUCCESS) {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    memcpy(&pwps_info->last_tx_message,
           &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS M2D Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M2D_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u16 msg_value_short, offset, message_length = 0;
    u32 msg_value_long;
    u8 *ptr;
    u8 msg_value_char;
    int ret;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info, EAP_REQUEST,
                                            pwps_info->peer_id, WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M2D);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Registrar Nonce */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* UUID-R */
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    message_length += offset;

    /* Authentication Type Flags */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Authentication_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.auth_type_flag);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encryption Type Flags */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Encryption_Type_Flags);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.encry_type_flag);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Connection Type Flags */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Connection_Type_Flags);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = CONNECTION_TYPE_ESS;
    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.config_methods);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Manufacture */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Manufacturer);
    ptlv->length = pwps_info->registrar.manufacture_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.manufacture, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Name */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Model_Name);
    ptlv->length = pwps_info->registrar.model_name_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.model_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Number */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Model_Number);
    ptlv->length = pwps_info->registrar.model_number_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.model_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Serial Number */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Serial_Number);
    ptlv->length = pwps_info->registrar.serial_number_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.serial_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Name);
    ptlv->length = pwps_info->registrar.device_name_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* RF Bands */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_RF_Band);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, &pwps_info->registrar.rf_bands, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Association State */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Association_State);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(0x0001);
    memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Configuration Error */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Device Password ID */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Password_ID);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->registrar.device_password_id);
    memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* OS Version */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_OS_Version);
    ptlv->length = SZ_OS_VERSION;
    ptr += SZ_TLV_HEADER;
    msg_value_long = htonl(pwps_info->registrar.os_version);
    memcpy(ptr, &msg_value_long, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    peap_wps_frame->length += message_length;

    offset = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    pwps_info->restart_by_M2D = WPS_SET;

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS M1 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M2D_frame_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data;
    u16 len, tlv_type, tlv_length;

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER) buf;
    /**
     * Don't save received M2D frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02) {
        ptlv =
            (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER +
                                SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    } else {
        ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type) {
        case SC_Version:
            memcpy(&pwps_info->registrar.version, data, tlv_length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
            if (pwps_info->registrar.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(M2D) Unknown WPS Version = 0x%x\n",
                           pwps_info->registrar.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_M2D)
                return WPS_STATUS_FAIL;
            break;
        case SC_Enrollee_Nonce:
            memcpy(pwps_info->enrollee.nonce, data, tlv_length);
            break;
        case SC_Registrar_Nonce:
            memcpy(pwps_info->registrar.nonce, data, tlv_length);
            break;
        case SC_UUID_R:
            memcpy(pwps_info->registrar.wps_uuid, data, tlv_length);
            pwps_info->registrar.wps_uuid_length = tlv_length;
            break;
        case SC_Authentication_Type_Flags:
            memcpy(&pwps_info->registrar.auth_type_flag, data, tlv_length);
            pwps_info->registrar.auth_type_flag =
                ntohs(pwps_info->registrar.auth_type_flag);
            break;
        case SC_Encryption_Type_Flags:
            memcpy(&pwps_info->registrar.encry_type_flag, data, tlv_length);
            pwps_info->registrar.encry_type_flag =
                ntohs(pwps_info->registrar.encry_type_flag);
            break;
        case SC_Connection_Type_Flags:
            memcpy(&pwps_info->registrar.connection_type_flag, data,
                   tlv_length);
            break;
        case SC_Config_Methods:
            memcpy(&pwps_info->registrar.config_methods, data, tlv_length);
            pwps_info->registrar.config_methods =
                ntohs(pwps_info->registrar.config_methods);
            break;
        case SC_Manufacturer:
            memcpy(pwps_info->registrar.manufacture, data, tlv_length);
            pwps_info->registrar.manufacture_length = tlv_length;
            break;
        case SC_Model_Name:
            memcpy(pwps_info->registrar.model_name, data, tlv_length);
            pwps_info->registrar.model_name_length = tlv_length;
            break;
        case SC_Model_Number:
            memcpy(pwps_info->registrar.model_number, data, tlv_length);
            pwps_info->registrar.model_number_length = tlv_length;
            break;
        case SC_Serial_Number:
            memcpy(pwps_info->registrar.serial_number, data, tlv_length);
            pwps_info->registrar.serial_number_length = tlv_length;
            break;
        case SC_Primary_Device_Type:
            memcpy(pwps_info->registrar.primary_device_type, data, tlv_length);
            break;
        case SC_Device_Name:
            memcpy(pwps_info->registrar.device_name, data, tlv_length);
            pwps_info->registrar.device_name_length = tlv_length;
            break;
        case SC_RF_Band:
            memcpy(&pwps_info->registrar.rf_bands, data, tlv_length);
            break;
        case SC_Association_State:
            memcpy(&pwps_info->registrar.association_state, data, tlv_length);
            break;
        case SC_Configuration_Error:
            memcpy(&pwps_info->registrar.configuration_error, data, tlv_length);
            pwps_info->registrar.configuration_error =
                ntohs(pwps_info->registrar.configuration_error);
            wps_printf(DEBUG_WPS_MSG, "SC_Configuration_Error(M2D): %d\n",
                       pwps_info->registrar.configuration_error);
            break;
        case SC_Device_Password_ID:
            memcpy(&pwps_info->registrar.device_password_id, data, tlv_length);
            break;
        case SC_OS_Version:
            memcpy(&pwps_info->registrar.os_version, data, tlv_length);
            pwps_info->registrar.os_version =
                ntohl(pwps_info->registrar.os_version);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown message_Type = 0x%x\n", tlv_type);
            break;
        }

        len = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    pwps_info->restart_by_M2D = WPS_SET;

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS M3 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M3_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 RawPSK[32];
    u8 HASH[32];
    int ret;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    /* Generate PSK1 */
    memset(PSK1, 0, sizeof(PSK1));
    MrvHMAC_SHA256(pwps_info->auth_key, 32,
                   pwps_info->PIN, pwps_info->PINLen / 2,
                   RawPSK, SHA256_DIGEST_SIZE);
    memcpy(PSK1, RawPSK, PSK_LEN);      /* Only 16 Bytes (128 bits) needed */
    wps_hexdump(DEBUG_WPS_MSG, "PSK1", (u8 *) PSK1, sizeof(PSK1));

    /* Generate PSK2 */
    memset(PSK2, 0, sizeof(PSK2));
    MrvHMAC_SHA256(pwps_info->auth_key, 32,
                   &pwps_info->PIN[pwps_info->PINLen / 2],
                   pwps_info->PINLen / 2, RawPSK, SHA256_DIGEST_SIZE);
    memcpy(PSK2, RawPSK, PSK_LEN);      /* Only 16 Bytes (128 bits) needed */
    wps_hexdump(DEBUG_WPS_MSG, "PSK2", (u8 *) PSK2, sizeof(PSK2));

    wps_hexdump(DEBUG_WPS_MSG, "ES1",
                (u8 *) pwps_info->enrollee.e_s1,
                sizeof(pwps_info->enrollee.e_s1));

    /* Get E-Hash1 */
    memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    memcpy(HashArgu, pwps_info->enrollee.e_s1, 16);
    offset += 16;
    memcpy(HashArgu + offset, PSK1, PSK_LEN);
    offset += PSK_LEN;
    memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    MrvHMAC_SHA256(pwps_info->auth_key, 32, HashArgu, 416, HASH,
                   SHA256_DIGEST_SIZE);
    memcpy(pwps_info->enrollee.e_hash1, HASH, 32);
    wps_hexdump(DEBUG_WPS_MSG, "E-HASH1",
                (u8 *) pwps_info->enrollee.e_hash1,
                sizeof(pwps_info->enrollee.e_hash1));

    /* Get E-Hash2 */
    memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    memcpy(HashArgu, pwps_info->enrollee.e_s2, 16);
    offset += 16;
    memcpy(HashArgu + offset, PSK2, PSK_LEN);
    offset += PSK_LEN;
    memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    MrvHMAC_SHA256(pwps_info->auth_key, 32, HashArgu, 416, HASH,
                   SHA256_DIGEST_SIZE);
    memcpy(pwps_info->enrollee.e_hash2, HASH, 32);
    wps_hexdump(DEBUG_WPS_MSG, "E-HASH2",
                (u8 *) pwps_info->enrollee.e_hash2,
                sizeof(pwps_info->enrollee.e_hash2));

    message_len = 0;
    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info,
                                            (wps_s->bss_type ==
                                             BSS_TYPE_UAP) ? EAP_REQUEST :
                                            EAP_RESPONSE, pwps_info->peer_id,
                                            WPS_Msg);
    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M3);
    message_length += offset;

    /* Registrar Nonce */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* E-Hash1 */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_E_Hash1);
    ptlv->length = 0x20;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.e_hash1, 32);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* E-Hash2 */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_E_Hash2);
    ptlv->length = 0x20;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.e_hash2, 32);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Authenticator */
    message_len = message_length;
    offset = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;

    peap_wps_frame->length += message_length;
    offset = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, (size_t) offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS M3 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M3_frame_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length;

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER) buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02) {
        ptlv =
            (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER +
                                SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len =
            (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    } else {
        ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type) {
        case SC_Version:
            memcpy(&pwps_info->enrollee.version, data, tlv_length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
            if (pwps_info->enrollee.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(M3) Unknown WPS Version = 0x%x\n",
                           pwps_info->enrollee.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_M3)
                return WPS_STATUS_FAIL;
            break;
        case SC_Registrar_Nonce:
            if (memcmp(pwps_info->registrar.nonce, data, tlv_length) != 0) {
                wps_printf(DEBUG_WPS_MSG,
                           "@M3_process: SC_Registrar_Nonce Fail!!\n");
                return WPS_STATUS_FAIL;
            }
            wps_printf(DEBUG_WPS_MSG, "@M3_process: SC_Registrar_Nonce OK\n");
            memcpy(pwps_info->registrar.nonce, data, tlv_length);
            break;
        case SC_E_Hash1:
            memcpy(pwps_info->enrollee.e_hash1, data, tlv_length);
            wps_hexdump(DEBUG_WPS_MSG, "E-HASH1 Received",
                        (u8 *) pwps_info->enrollee.e_hash1, tlv_length);
            break;
        case SC_E_Hash2:
            memcpy(pwps_info->enrollee.e_hash2, data, tlv_length);
            wps_hexdump(DEBUG_WPS_MSG, "E-HASH2 Received",
                        (u8 *) pwps_info->enrollee.e_hash2, tlv_length);
            break;
        case SC_Authenticator:
            memcpy(pwps_info->enrollee.authenticator, data, tlv_length);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown message_Type = 0x%x\n", tlv_type);
            break;
        }

        len = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len)
        != WPS_STATUS_SUCCESS) {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    memcpy(&pwps_info->last_tx_message,
           &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS M4 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M4_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 RawPSK[32];
    u8 HASH[32];
    u8 *pEncry;
    int i, ret;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    wps_hexdump(DEBUG_WPS_MSG, "our PIN", (u8 *) pwps_info->PIN,
                pwps_info->PINLen);

    /* Generate PSK1 */
    memset(PSK1, 0, sizeof(PSK1));
    MrvHMAC_SHA256(pwps_info->auth_key, 32,
                   pwps_info->PIN, pwps_info->PINLen / 2,
                   RawPSK, SHA256_DIGEST_SIZE);
    memcpy(PSK1, RawPSK, 16);   /* Only 16 Bytes (128 bits) needed */
    wps_hexdump(DEBUG_WPS_MSG, "PSK1", (u8 *) PSK1, sizeof(PSK1));

    /* Generate PSK2 */
    memset(PSK2, 0, sizeof(PSK2));
    MrvHMAC_SHA256(pwps_info->auth_key, 32,
                   &pwps_info->PIN[pwps_info->PINLen / 2],
                   pwps_info->PINLen / 2, RawPSK, SHA256_DIGEST_SIZE);
    memcpy(PSK2, RawPSK, sizeof(PSK2)); /* Only 16 Bytes (128 bits) needed */
    wps_hexdump(DEBUG_WPS_MSG, "PSK2", (u8 *) PSK2, sizeof(PSK2));

    /* Get E-Hash1 */
    memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    memcpy(HashArgu, pwps_info->registrar.r_s1, 16);
    offset += 16;
    memcpy(HashArgu + offset, PSK1, PSK_LEN);
    offset += PSK_LEN;
    memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    MrvHMAC_SHA256(pwps_info->auth_key, 32, HashArgu, 416, HASH,
                   SHA256_DIGEST_SIZE);
    memcpy(pwps_info->registrar.r_hash1, HASH, 32);
    wps_hexdump(DEBUG_WPS_MSG, "R-HASH1",
                (u8 *) pwps_info->registrar.r_hash1,
                sizeof(pwps_info->registrar.r_hash1));

    /* Get E-Hash2 */
    memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    memcpy(HashArgu, pwps_info->registrar.r_s2, 16);
    offset += 16;
    memcpy(HashArgu + offset, PSK2, PSK_LEN);
    offset += PSK_LEN;
    memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    MrvHMAC_SHA256(pwps_info->auth_key, 32, HashArgu, 416, HASH,
                   SHA256_DIGEST_SIZE);
    memcpy(pwps_info->registrar.r_hash2, HASH, 32);
    wps_hexdump(DEBUG_WPS_MSG, "R-HASH2",
                (u8 *) pwps_info->registrar.r_hash2,
                sizeof(pwps_info->registrar.r_hash2));

    message_len = 0;
    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info,
                                            (wps_s->bss_type ==
                                             BSS_TYPE_UAP) ? EAP_REQUEST :
                                            EAP_RESPONSE, pwps_info->peer_id,
                                            WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M4);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* R-Hash1 */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_R_Hash1);
    ptlv->length = 0x20;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.r_hash1, 32);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* R-Hash2 */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_R_Hash2);
    ptlv->length = 0x20;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.r_hash2, 32);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Encrypted_Settings);
    ptlv->length = 0x40;
    ptr += SZ_TLV_HEADER;

    for (i = 0; i < 16; i++) {
        pwps_info->registrar.IV[i] = rand() % 10;
    }
    if (pwps_info->registrar.IV[0] == 0)
        pwps_info->registrar.IV[0] += 1;
    memcpy(ptr, pwps_info->registrar.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;

    /* R-SNonce1 */
    memset(EncryData, 0x00, sizeof(EncryData));
    pEncry = EncryData;
    ptlvE = (PTLV_DATA_HEADER) pEncry;
    ptlvE->type = htons(SC_R_SNonce1);
    ptlvE->length = 0x10;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->registrar.r_s1, 16);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

    /* Key Wrap Authenticator */
    memset(KWA, 0, sizeof(KWA));
    MrvHMAC_SHA256(pwps_info->auth_key, 32,
                   EncryData, 20, KWA, SHA256_DIGEST_SIZE);

    ptlvE = (PTLV_DATA_HEADER) pEncry;
    ptlvE->type = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = 0x8;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, KWA, 8);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);
    memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
    MrvAES_Wrap(EncryData, pEncry - EncryData, EncryAesOutput,
                pwps_info->key_wrap_key, 16, pwps_info->registrar.IV);
    memcpy(ptr, EncryAesOutput, pEncry - EncryData + 16);
    ptr += pEncry - EncryData + 16;
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Authenticator */
    message_len = message_length;
    offset = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, (size_t) offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS M4 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M4_frame_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, tlv_type, tlv_length, wps_frm_body_len, offset;
    u8 HASH[32];

    WPS_DATA *wps_s = &wps_global;
    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER) buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02) {
        ptlv =
            (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER +
                                SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len =
            (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    } else {
        ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type) {
        case SC_Version:
            memcpy(&pwps_info->registrar.version, data, tlv_length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
            if (pwps_info->registrar.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(M4) Unknown WPS Version = 0x%x\n",
                           pwps_info->registrar.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_M4)
                return WPS_STATUS_FAIL;
            break;
        case SC_Enrollee_Nonce:
            if (memcmp(pwps_info->enrollee.nonce, data, tlv_length) != 0) {
                wps_printf(DEBUG_WPS_MSG,
                           "@M4_process: SC_Enrollee_Nonce Fail!!\n");
                return WPS_STATUS_FAIL;
            }
            memcpy(pwps_info->enrollee.nonce, data, tlv_length);
            break;
        case SC_R_Hash1:
            memcpy(pwps_info->registrar.r_hash1, data, tlv_length);
            wps_hexdump(DEBUG_WPS_MSG, "R-HASH1 Received",
                        (u8 *) pwps_info->registrar.r_hash1, tlv_length);
            break;
        case SC_R_Hash2:
            memcpy(pwps_info->registrar.r_hash2, data, tlv_length);
            wps_hexdump(DEBUG_WPS_MSG, "R-HASH2 Received",
                        (u8 *) pwps_info->registrar.r_hash2, tlv_length);
            break;
        case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype;
                u8 *esdata;

                memcpy(pwps_info->registrar.IV, data, 16);
                pwps_info->registrar.encrypted_data_len = tlv_length - 16;
                memcpy(pwps_info->registrar.encrypted_data, data + 16,
                       pwps_info->registrar.encrypted_data_len);
                PTLV_DATA_HEADER pes =
                    (PTLV_DATA_HEADER) (pwps_info->registrar.wrap_raw_data);
                memset(pwps_info->registrar.wrap_raw_data, 0x00,
                       sizeof(pwps_info->registrar.wrap_raw_data));
                MrvAES_UnWrap(pwps_info->registrar.encrypted_data,
                              pwps_info->registrar.encrypted_data_len,
                              pwps_info->registrar.wrap_raw_data,
                              pwps_info->key_wrap_key, 16,
                              pwps_info->registrar.IV);

                while (((u8 *) pes - pwps_info->registrar.wrap_raw_data) <
                       (pwps_info->registrar.encrypted_data_len - 16)) {
                    estype = ntohs(pes->type);
                    pes->length = ntohs(pes->length);
                    esdata = (u8 *) pes;
                    esdata += SZ_TLV_HEADER;
                    switch (estype) {
                    case SC_R_SNonce1:
                        memcpy(pwps_info->registrar.r_s1, esdata, pes->length);
                        break;
                    case SC_Key_Wrap_Authenticator:
                        memcpy(pwps_info->key_wrap_authenticator, esdata,
                               pes->length);
                        break;
                    }
                    elen = pes->length + SZ_TLV_HEADER;
                    pes = (PTLV_DATA_HEADER) ((u8 *) pes + elen);
                }               /* while */

                break;
            }
        case SC_Authenticator:
            memcpy(pwps_info->registrar.authenticator, data, tlv_length);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown message_Type = 0x%x\n", tlv_type);
            break;
        }

        len = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    /* Get R-Hash1 */
    memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    memcpy(HashArgu, pwps_info->registrar.r_s1, 16);
    offset += 16;
    memcpy(HashArgu + offset, PSK1, 16);
    offset += PSK_LEN;
    memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    MrvHMAC_SHA256(pwps_info->auth_key, 32, HashArgu, 416,
                   HASH, SHA256_DIGEST_SIZE);
    wps_hexdump(DEBUG_WPS_MSG, "R-HASH1 computed", (u8 *) HASH, 32);
    if (memcmp(pwps_info->registrar.r_hash1, HASH, 32)) {
        wps_printf(DEBUG_WPS_MSG, "@M4_process: r_hash1 mis-match!!\n");
		
        if ((wps_s->bss_type == BSS_TYPE_UAP && pwps_info->role == WPS_ENROLLEE)
            ) {
            wps_check_for_ap_setup_locked_scenario(pwps_info);
        }
        return WPS_STATUS_FAIL;
    }

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len)
        != WPS_STATUS_SUCCESS) {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    memcpy(&pwps_info->last_tx_message,
           &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS M5 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M5_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 *pEncry;
    int i, ret;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info,
                                            (wps_s->bss_type ==
                                             BSS_TYPE_UAP) ? EAP_REQUEST :
                                            EAP_RESPONSE, pwps_info->peer_id,
                                            WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M5);
    message_length += offset;

    /* Registrar Nonce */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.nonce, 0x10);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Encrypted_Settings);
    ptlv->length = 0x40;
    ptr += SZ_TLV_HEADER;
    for (i = 0; i < 16; i++) {
        pwps_info->enrollee.IV[i] = rand() % 10;
    }
    if (pwps_info->enrollee.IV[0] == 0)
        pwps_info->enrollee.IV[0] += 1;
    memcpy(ptr, pwps_info->enrollee.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;

    /* E-SNonce1 */
    memset(EncryData, 0x00, sizeof(EncryData));
    pEncry = EncryData;
    ptlvE = (PTLV_DATA_HEADER) pEncry;
    ptlvE->type = htons(SC_E_SNonce1);
    ptlvE->length = 0x10;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->enrollee.e_s1, 16);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

    /* Key Wrap Authenticator */
    memset(KWA, 0, sizeof(KWA));
    MrvHMAC_SHA256(pwps_info->auth_key, 32,
                   EncryData, 20, KWA, SHA256_DIGEST_SIZE);

    ptlvE = (PTLV_DATA_HEADER) pEncry;
    ptlvE->type = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = 0x8;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, KWA, 8);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);
    memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
    MrvAES_Wrap(EncryData, pEncry - EncryData, EncryAesOutput,
                pwps_info->key_wrap_key, 16, pwps_info->enrollee.IV);
    memcpy(ptr, EncryAesOutput, pEncry - EncryData + 16);
    ptr += pEncry - EncryData + 16;
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Authenticator */
    message_len = message_length;
    offset = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, (size_t) offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS M5 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M5_frame_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length, offset;
    u8 HASH[32];

    WPS_DATA *wps_s = &wps_global;
    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER) buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02) {
        ptlv =
            (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER +
                                SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len =
            (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    } else {
        ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type) {
        case SC_Version:
            memcpy(&pwps_info->enrollee.version, data, tlv_length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
            if (pwps_info->enrollee.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(M5) Unknown WPS Version = 0x%x\n",
                           pwps_info->enrollee.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_M5)
                return WPS_STATUS_FAIL;
            break;
        case SC_Registrar_Nonce:
            if (memcmp(pwps_info->registrar.nonce, data, tlv_length) != 0) {
                wps_printf(DEBUG_WPS_MSG,
                           "@M5_process: SC_Registrar_Nonce Fail!!\n");
                return WPS_STATUS_FAIL;
            }
            wps_printf(DEBUG_WPS_MSG, "@M5_process: SC_Registrar_Nonce OK\n");
            memcpy(pwps_info->registrar.nonce, data, tlv_length);
            break;
        case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype;
                u8 *esdata;

                memcpy(pwps_info->enrollee.IV, data, 16);
                pwps_info->enrollee.encrypted_data_len = tlv_length - 16;
                memcpy(pwps_info->enrollee.encrypted_data, data + 16,
                       pwps_info->enrollee.encrypted_data_len);

                PTLV_DATA_HEADER pes =
                    (PTLV_DATA_HEADER) (pwps_info->enrollee.wrap_raw_data);
                memset(pwps_info->enrollee.wrap_raw_data, 0x00,
                       sizeof(pwps_info->enrollee.wrap_raw_data));
                MrvAES_UnWrap(pwps_info->enrollee.encrypted_data,
                              pwps_info->enrollee.encrypted_data_len,
                              pwps_info->enrollee.wrap_raw_data,
                              pwps_info->key_wrap_key, 16,
                              pwps_info->enrollee.IV);

                while (((u8 *) pes - pwps_info->enrollee.wrap_raw_data) <
                       (pwps_info->enrollee.encrypted_data_len - 16)) {
                    estype = ntohs(pes->type);
                    pes->length = ntohs(pes->length);
                    esdata = (u8 *) pes;
                    esdata += SZ_TLV_HEADER;
                    switch (estype) {
                    case SC_E_SNonce1:
                        memcpy(pwps_info->enrollee.e_s1, esdata, pes->length);
                        break;
                    case SC_Key_Wrap_Authenticator:
                        memcpy(pwps_info->key_wrap_authenticator, esdata,
                               pes->length);
                        break;
                    }
                    elen = pes->length + SZ_TLV_HEADER;
                    pes = (PTLV_DATA_HEADER) ((u8 *) pes + elen);
                }
                break;
            }
        case SC_Authenticator:
            memcpy(pwps_info->enrollee.authenticator, data, tlv_length);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown message_Type = 0x%x\n", tlv_type);
            break;
        }

        len = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    /* Get E-Hash1 */
    memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    memcpy(HashArgu, pwps_info->enrollee.e_s1, 16);
    offset += 16;
    memcpy(HashArgu + offset, PSK1, PSK_LEN);
    offset += PSK_LEN;
    memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    MrvHMAC_SHA256(pwps_info->auth_key, 32, HashArgu, 416,
                   HASH, SHA256_DIGEST_SIZE);
    wps_hexdump(DEBUG_WPS_MSG, "E-HASH1 computed", (u8 *) HASH, 32);
    if (memcmp(pwps_info->enrollee.e_hash1, HASH, 32)) {
        wps_printf(DEBUG_WPS_MSG, "@M5_process: e_hash1 mis-match!!\n");
        if ((wps_s->bss_type == BSS_TYPE_UAP && pwps_info->role == WPS_ENROLLEE)
            ) {
            wps_check_for_ap_setup_locked_scenario(pwps_info);
        }
        return WPS_STATUS_FAIL;
    }

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len)
        != WPS_STATUS_SUCCESS) {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    memcpy(&pwps_info->last_tx_message,
           &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS M6 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M6_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 *pEncry;
    int i, ret;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info,
                                            (wps_s->bss_type ==
                                             BSS_TYPE_UAP) ? EAP_REQUEST :
                                            EAP_RESPONSE, pwps_info->peer_id,
                                            WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M6);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Encrypted_Settings);
    ptlv->length = 0x40;
    ptr += SZ_TLV_HEADER;
    for (i = 0; i < 16; i++) {
        pwps_info->registrar.IV[i] = rand() % 10;
    }
    if (pwps_info->registrar.IV[0] == 0)
        pwps_info->registrar.IV[0] += 1;
    memcpy(ptr, pwps_info->registrar.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;

    /* R-SNonce2 */
    memset(EncryData, 0x00, sizeof(EncryData));
    pEncry = EncryData;
    ptlvE = (PTLV_DATA_HEADER) pEncry;
    ptlvE->type = SC_R_SNonce2;
    ptlvE->type = htons(ptlvE->type);
    ptlvE->length = 0x10;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->registrar.r_s2, 16);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

    /* Key Wrap Authenticator */
    memset(KWA, 0, sizeof(KWA));
    MrvHMAC_SHA256(pwps_info->auth_key, 32,
                   EncryData, 20, KWA, SHA256_DIGEST_SIZE);

    ptlvE = (PTLV_DATA_HEADER) pEncry;
    ptlvE->type = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = 0x8;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, KWA, 8);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);
    memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
    MrvAES_Wrap(EncryData, pEncry - EncryData, EncryAesOutput,
                pwps_info->key_wrap_key, 16, pwps_info->registrar.IV);
    memcpy(ptr, EncryAesOutput, pEncry - EncryData + 16);
    ptr += pEncry - EncryData + 16;
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Authenticator */
    message_len = message_length;
    offset = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, (size_t) offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS M6 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M6_frame_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, tlv_type, tlv_length, wps_frm_body_len, offset;
    u8 HASH[32];

    WPS_DATA *wps_s = &wps_global;
    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER) buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02) {
        ptlv =
            (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER +
                                SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len =
            (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    } else {
        ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type) {
        case SC_Version:
            memcpy(&pwps_info->registrar.version, data, tlv_length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
            if (pwps_info->registrar.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(M6) Unknown WPS Version = 0x%x\n",
                           pwps_info->registrar.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_M6)
                return WPS_STATUS_FAIL;
            break;
        case SC_Enrollee_Nonce:
            if (memcmp(pwps_info->enrollee.nonce, data, tlv_length) != 0) {
                wps_printf(DEBUG_WPS_MSG,
                           "@M6_process: SC_Enrollee_Nonce Fail!!\n");
                return WPS_STATUS_FAIL;
            }
            memcpy(pwps_info->enrollee.nonce, data, tlv_length);
            break;
        case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype;
                u8 *esdata;

                memcpy(pwps_info->registrar.IV, data, 16);
                pwps_info->registrar.encrypted_data_len = tlv_length - 16;
                memcpy(pwps_info->registrar.encrypted_data, data + 16,
                       pwps_info->registrar.encrypted_data_len);

                PTLV_DATA_HEADER pes =
                    (PTLV_DATA_HEADER) (pwps_info->registrar.wrap_raw_data);
                memset(pwps_info->registrar.wrap_raw_data, 0x00,
                       sizeof(pwps_info->registrar.wrap_raw_data));
                MrvAES_UnWrap(pwps_info->registrar.encrypted_data,
                              pwps_info->registrar.encrypted_data_len,
                              pwps_info->registrar.wrap_raw_data,
                              pwps_info->key_wrap_key, 16,
                              pwps_info->registrar.IV);

                while (((u8 *) pes - pwps_info->registrar.wrap_raw_data) <
                       (pwps_info->registrar.encrypted_data_len - 16)) {
                    estype = ntohs(pes->type);
                    pes->length = ntohs(pes->length);
                    esdata = (u8 *) pes;
                    esdata += SZ_TLV_HEADER;
                    switch (estype) {
                    case SC_R_SNonce2:
                        memcpy(pwps_info->registrar.r_s2, esdata, pes->length);
                        break;
                    case SC_Key_Wrap_Authenticator:
                        memcpy(pwps_info->key_wrap_authenticator, esdata,
                               pes->length);
                        break;
                    }
                    elen = pes->length + SZ_TLV_HEADER;
                    pes = (PTLV_DATA_HEADER) ((u8 *) pes + elen);
                }
                break;
            }
        case SC_Authenticator:
            memcpy(pwps_info->registrar.authenticator, data, tlv_length);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown message_Type = 0x%x\n", tlv_type);
            break;
        }

        len = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    /* Get R-Hash2 */
    memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    memcpy(HashArgu, pwps_info->registrar.r_s2, 16);
    offset += 16;
    memcpy(HashArgu + offset, PSK2, 16);
    offset += PSK_LEN;
    memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    MrvHMAC_SHA256(pwps_info->auth_key, 32, HashArgu, 416,
                   HASH, SHA256_DIGEST_SIZE);
    wps_hexdump(DEBUG_WPS_MSG, "R-HASH2 computed", (u8 *) HASH, 32);
    if (memcmp(pwps_info->registrar.r_hash2, HASH, 32)) {
        wps_printf(DEBUG_WPS_MSG, "@M6_process: r_hash1 mis-match!!\n");
        if ((wps_s->bss_type == BSS_TYPE_UAP && pwps_info->role == WPS_ENROLLEE)
            ) {
            wps_check_for_ap_setup_locked_scenario(pwps_info);
        }
        return WPS_STATUS_FAIL;
    }

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len)
        != WPS_STATUS_SUCCESS) {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    memcpy(&pwps_info->last_tx_message,
           &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

int
wps_add_ap_settings_to_registrar(PWPS_INFO pwps_info, u8 * pEncry)
{
    int ap_setting_len = 0;
    u16 msg_value_short;
    PTLV_DATA_HEADER ptlvC;

    /* SSID */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_SSID);
    ptlvC->length = pwps_info->enrollee.cred_data[0].ssid_length;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->enrollee.cred_data[0].ssid, ptlvC->length);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* AP's MAC Address */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_MAC_Address);
    ptlvC->length = 6;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->enrollee.mac_address, 6);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Authentication Type */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Authentication_Type);
    ptlvC->length = 2;
    pEncry += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.cred_data[0].auth_type);
    memcpy(pEncry, &msg_value_short, 2);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Encryption Type */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Encryption_Type);
    ptlvC->length = 2;
    pEncry += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.cred_data[0].encry_type);
    memcpy(pEncry, &msg_value_short, 2);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Network Key Index */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Network_Key_Index);
    ptlvC->length = 1;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, &pwps_info->enrollee.cred_data[0].network_key_index, 1);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Network Key */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Network_Key);
    ptlvC->length = pwps_info->enrollee.cred_data[0].network_key_len;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->enrollee.cred_data[0].network_key, ptlvC->length);
    pEncry += ptlvC->length;
    ap_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    wps_printf(DEBUG_WPS_MSG, "AP Setting len: %d\n", ap_setting_len);
    return ap_setting_len;
}

int
MrvAES_Wrap_Ext(u8 * pPlainTxt, u32 TextLen, u8 * pCipTxt,
                u8 * pKEK, u32 KeyLen, u8 * IV)
{
    u32 OrigLen = TextLen;
    int i;

    if (TextLen % 32 == 0) {
        wps_hexdump(DEBUG_WPS_MSG, "M8_preEncry", (u8 *) pPlainTxt, TextLen);
        MrvAES_Wrap(pPlainTxt, TextLen, pCipTxt, pKEK, KeyLen, IV);
        TextLen += 16;
    } else {
        if (TextLen % 16 == 0 && TextLen % 32 != 0)
            TextLen = TextLen - TextLen % 32 + 32;
        else if (TextLen % 16 != 0)
            TextLen = TextLen - TextLen % 16 + 16;

        /* Padding the value of # of paddings */
        for (i = 0; i < TextLen - OrigLen; i++) {
            *(pPlainTxt + OrigLen + i) = TextLen - OrigLen;
        }

        wps_hexdump(DEBUG_WPS_MSG, "M8_preEncry", (u8 *) pPlainTxt, TextLen);
        MrvAES_Wrap(EncryData, TextLen, pCipTxt, pKEK, KeyLen, IV);
    }

    return TextLen;
}

int
MrvAES_UnWrap_Ext(u8 * pCipTxt, u32 TextLen, u8 * pPlainTxt, u8 * pKEK,
                  u32 KeyLen, u8 * IV)
{
    u8 *ptr;
    int i, pad;

    wps_hexdump(DEBUG_WPS_MSG, "M8_Decry i/p", (u8 *) pCipTxt, TextLen);

    /* Decrypt */
    MrvAES_UnWrap(pCipTxt, TextLen, pPlainTxt, pKEK, KeyLen, IV);

    /* Remove padding */
    ptr = &pPlainTxt[TextLen - 1];

    pad = *ptr;

    if (pad > TextLen) {
        return WPS_STATUS_FAIL;
    }

    for (i = 0; i < pad; i++) {
        if (*ptr-- != pad) {
            return WPS_STATUS_FAIL;
        }
    }

    return TextLen - pad;
}

/** 
 *  @brief  Prepare and Send WPS M7 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M7_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE;
    u16 offset, message_len, message_length = 0;
    u8 *ptr;
    u8 *pEncry;
    int i, ret, enc_setting_len = 0;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info,
                                            (wps_s->bss_type ==
                                             BSS_TYPE_UAP) ? EAP_REQUEST :
                                            EAP_RESPONSE, pwps_info->peer_id,
                                            WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M7);
    message_length += offset;

    /* Registrar Nonce */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Registrar_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Encrypted_Settings);
    ptlv->length = 0x0;
    ptr += SZ_TLV_HEADER;
    for (i = 0; i < 16; i++) {
        pwps_info->enrollee.IV[i] = rand() % 10;
    }
    if (pwps_info->enrollee.IV[0] == 0)
        pwps_info->enrollee.IV[0] += 1;
    memcpy(ptr, pwps_info->enrollee.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;
    ptlv->length += WPS_NONCE_SIZE;

    /* E-SNonce2 */
    memset(EncryData, 0x00, sizeof(EncryData));
    pEncry = EncryData;
    ptlvE = (PTLV_DATA_HEADER) pEncry;
    ptlvE->type = htons(SC_E_SNonce2);
    ptlvE->length = 0x10;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->enrollee.e_s2, 16);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

    if (wps_s->bss_type == BSS_TYPE_UAP) {
        /* Report Current AP settings to Registrar */
        pEncry += wps_add_ap_settings_to_registrar(pwps_info, pEncry);
    }

    /* Key Wrap Authenticator */
    memset(KWA, 0, sizeof(KWA));
    MrvHMAC_SHA256(pwps_info->auth_key, 32,
                   EncryData, pEncry - EncryData, KWA, SHA256_DIGEST_SIZE);

    ptlvE = (PTLV_DATA_HEADER) pEncry;
    ptlvE->type = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = 0x8;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, KWA, 8);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);
    memset(EncryAesOutput, 0, sizeof(EncryAesOutput));

    enc_setting_len = MrvAES_Wrap_Ext(EncryData, pEncry - EncryData,
                                      EncryAesOutput, pwps_info->key_wrap_key,
                                      16, pwps_info->enrollee.IV);
    memcpy(ptr, EncryAesOutput, enc_setting_len);
    ptr += enc_setting_len;
    ptlv->length += enc_setting_len;
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* XXX: Add the optional "SETTING DELAY TIME" here if needed */

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Authenticator */
    message_len = message_length;
    offset = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    if (wps_s->bss_type == BSS_TYPE_UAP && pwps_info->role == WPS_ENROLLEE) {
        pwps_info->register_completed = WPS_SET;
    }
    /* call eapol tx function */
    WPS_EAPOL_TX_AND_SAVE(ret, pwps_info, wps_s, pwps_info->buffer, (size_t) offset);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS M7 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M7_frame_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length, offset;
    u8 HASH[32];

    WPS_DATA *wps_s = &wps_global;
    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER) buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02) {
        ptlv =
            (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER +
                                SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len =
            (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    } else {
        ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type) {
        case SC_Version:
            memcpy(&pwps_info->enrollee.version, data, tlv_length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
            if (pwps_info->enrollee.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(M7) Unknown WPS Version = 0x%x\n",
                           pwps_info->enrollee.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_M7)
                return WPS_STATUS_FAIL;
            break;
        case SC_Registrar_Nonce:
            if (memcmp(pwps_info->registrar.nonce, data, tlv_length) != 0) {
                wps_printf(DEBUG_WPS_MSG,
                           "@M7_process: SC_Registrar_Nonce Fail!!\n");
                return WPS_STATUS_FAIL;
            }
            wps_printf(DEBUG_WPS_MSG, "@M7_process: SC_Registrar_Nonce OK\n");
            memcpy(pwps_info->registrar.nonce, data, tlv_length);
            break;
        case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype;
                u8 *esdata;
                CREDENTIAL_DATA *pCred =
                    (CREDENTIAL_DATA *) & pwps_info->enrollee.cred_data[0];

                memcpy(pwps_info->enrollee.IV, data, 16);
                pwps_info->enrollee.encrypted_data_len = tlv_length - 16;
                memcpy(pwps_info->enrollee.encrypted_data, data + 16,
                       pwps_info->enrollee.encrypted_data_len);
                PTLV_DATA_HEADER pes =
                    (PTLV_DATA_HEADER) (pwps_info->enrollee.wrap_raw_data);
                memset(pwps_info->enrollee.wrap_raw_data, 0x00,
                       sizeof(pwps_info->enrollee.wrap_raw_data));
                MrvAES_UnWrap(pwps_info->enrollee.encrypted_data,
                              pwps_info->enrollee.encrypted_data_len,
                              pwps_info->enrollee.wrap_raw_data,
                              pwps_info->key_wrap_key, 16,
                              pwps_info->enrollee.IV);

                while (((u8 *) pes - pwps_info->enrollee.wrap_raw_data) <
                       (pwps_info->enrollee.encrypted_data_len - 16)) {
                    estype = ntohs(pes->type);
                    pes->length = ntohs(pes->length);
                    esdata = (u8 *) pes;
                    esdata += SZ_TLV_HEADER;

                    switch (estype) {
                    case SC_E_SNonce2:
                        memcpy(pwps_info->enrollee.e_s2, esdata, pes->length);
                        break;
                    case SC_Key_Wrap_Authenticator:
                        memcpy(pwps_info->key_wrap_authenticator, esdata,
                               pes->length);
                        break;
                    case SC_SSID:
                        wps_printf(DEBUG_WPS_MSG, "SC_SSID\n");
                        pCred->ssid_length =
                            MIN(pes->length, sizeof(pCred->ssid));
                        memcpy(pCred->ssid, esdata, pCred->ssid_length);
                        wps_printf(DEBUG_WPS_MSG, "SSID : %s\n", pCred->ssid);
                        break;

                    case SC_MAC_Address:
                        wps_printf(DEBUG_WPS_MSG, "SC_MAC_Address\n");
                        memcpy(pCred->mac_address, esdata, ETH_ALEN);
                        break;

                    case SC_Authentication_Type:
                        wps_printf(DEBUG_WPS_MSG, "SC_Authentication_Type\n");
                        memcpy(&pCred->auth_type, esdata, pes->length);
                        pCred->auth_type = ntohs(pCred->auth_type);
                        wps_printf(DEBUG_WPS_MSG,
                                   "Authentication_Type(M7) = 0x%04x\n",
                                   pCred->auth_type);
                        break;

                    case SC_Encryption_Type:
                        wps_printf(DEBUG_WPS_MSG, "SC_Encryption_Type\n");
                        memcpy(&pCred->encry_type, esdata, pes->length);
                        pCred->encry_type = ntohs(pCred->encry_type);
                        wps_printf(DEBUG_WPS_MSG,
                                   "Encryption_Type(M7) = 0x%04x\n",
                                   pCred->encry_type);
                        break;

                    case SC_Network_Key:
                        wps_hexdump(DEBUG_WPS_MSG, "SC_Network_Key",
                                    (u8 *) esdata, pes->length);
                        memcpy(pCred->network_key, esdata, pes->length);
                        pCred->network_key_len = pes->length;
                        break;

                    }
                    elen = pes->length + SZ_TLV_HEADER;
                    pes = (PTLV_DATA_HEADER) ((u8 *) pes + elen);
                }
                break;
            }
        case SC_Authenticator:
            memcpy(pwps_info->enrollee.authenticator, data, tlv_length);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown message_Type = 0x%x\n", tlv_type);
            break;
        }

        len = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    /* Get E-Hash2 */
    memset(HashArgu, 0, sizeof(HashArgu));
    offset = 0;
    memcpy(HashArgu, pwps_info->enrollee.e_s2, 16);
    offset += 16;
    memcpy(HashArgu + offset, PSK2, PSK_LEN);
    offset += PSK_LEN;
    memcpy(HashArgu + offset, pwps_info->enrollee.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    memcpy(HashArgu + offset, pwps_info->registrar.public_key, WPS_PUB_KEY_LEN);
    offset += WPS_PUB_KEY_LEN;
    MrvHMAC_SHA256(pwps_info->auth_key, 32, HashArgu, 416,
                   HASH, SHA256_DIGEST_SIZE);
    wps_hexdump(DEBUG_WPS_MSG, "E-HASH2 computed", (u8 *) HASH, 32);

    if (memcmp(pwps_info->enrollee.e_hash2, HASH, 32)) {
        wps_printf(DEBUG_WPS_MSG, "@M7_process: e_hash2 mis-match!!\n");
        if ((wps_s->bss_type == BSS_TYPE_UAP && pwps_info->role == WPS_ENROLLEE)
            ) {
            wps_check_for_ap_setup_locked_scenario(pwps_info);
        }
        return WPS_STATUS_FAIL;
    }

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len)
        != WPS_STATUS_SUCCESS) {
        return WPS_STATUS_FAIL;
    }
    /* save the last tx message before saving the rx message into last message */
    memcpy(&pwps_info->last_tx_message,
           &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS M8 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M8_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv, ptlvE = NULL, ptlvC;
    u16 msg_value_short, offset, message_len, message_length = 0;
    u8 *ptr;
    u8 *pEncry;
    u8 datalength = 0;
    int i, ret, enc_setting_len = 0;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);
    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;
    offset = wps_eap_message_header_prepare(pwps_info,
                                            (wps_s->bss_type ==
                                             BSS_TYPE_UAP) ? EAP_REQUEST :
                                            EAP_RESPONSE, pwps_info->peer_id,
                                            WPS_Msg);

    /* Version */
    ptr += offset;
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;

    /* Message Type */
    ptr += offset;
    offset = wps_attribute_message_type_prepare(ptr, WPS_M8);
    message_length += offset;

    /* Enrollee Nonce */
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Enrollee_Nonce);
    ptlv->length = 0x10;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->enrollee.nonce, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Encrypted Settings */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Encrypted_Settings);
    ptr += SZ_TLV_HEADER;
    for (i = 0; i < 16; i++) {
        pwps_info->registrar.IV[i] = rand() % 10;
    }
    if (pwps_info->registrar.IV[0] == 0)
        pwps_info->registrar.IV[0] += 1;
    memcpy(ptr, pwps_info->registrar.IV, WPS_NONCE_SIZE);
    ptr += WPS_NONCE_SIZE;

    /* Credential */
    memset(EncryData, 0x00, sizeof(EncryData));
    pEncry = EncryData;

    if (wps_s->bss_type == BSS_TYPE_UAP) {

        ptlvE = (PTLV_DATA_HEADER) pEncry;
        ptlvE->type = htons(SC_Credential);
        ptlvE->length = 0;
        pEncry += SZ_TLV_HEADER;
    }

    /* ----- Credential Start ----- */
    /* Network Index */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Network_Index);
    ptlvC->length = 1;
    pEncry += SZ_TLV_HEADER;
    *pEncry = 0x1;
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* SSID */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_SSID);
    ptlvC->length = pwps_info->registrar.cred_data[0].ssid_length;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->registrar.cred_data[0].ssid, ptlvC->length);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Authentication Type */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Authentication_Type);
    ptlvC->length = 2;
    pEncry += SZ_TLV_HEADER;
    /* For legacy enrollee, don't use the new mixed mode auth type */
    if (!pwps_info->enrollee.version2 &&
        (pwps_info->registrar.cred_data[0].auth_type ==
         AUTHENTICATION_TYPE_WPA_MIXED)) {
        msg_value_short = htons(AUTHENTICATION_TYPE_WPA2PSK);
    } else {
        msg_value_short = htons(pwps_info->registrar.cred_data[0].auth_type);
    }
    memcpy(pEncry, &msg_value_short, 2);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Encryption Type */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Encryption_Type);
    ptlvC->length = 2;
    pEncry += SZ_TLV_HEADER;
    if (pwps_info->enrollee.version2) {
        msg_value_short = htons(pwps_info->registrar.cred_data[0].encry_type);
    } else
        if (pwps_info->registrar.cred_data[0].encry_type ==
            (ENCRYPTION_TYPE_AES | ENCRYPTION_TYPE_TKIP)) {

        if (pwps_info->enrollee.encry_type_flag & ENCRYPTION_TYPE_AES)
            msg_value_short = htons(ENCRYPTION_TYPE_AES);
        else if (pwps_info->enrollee.encry_type_flag & ENCRYPTION_TYPE_TKIP)
            msg_value_short = htons(ENCRYPTION_TYPE_TKIP);
        else {
            wps_printf(MSG_ERROR,
                       " wps_eap_M8_frame_prepare: No suitable Encryption type supported.\n");
        }
    } else {
        msg_value_short = htons(pwps_info->registrar.cred_data[0].encry_type);
    }
    memcpy(pEncry, &msg_value_short, 2);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Network Key Index */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Network_Key_Index);
    ptlvC->length = 1;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, &pwps_info->registrar.cred_data[0].network_key_index, 1);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* Network Key */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_Network_Key);
    ptlvC->length = pwps_info->registrar.cred_data[0].network_key_len;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->registrar.cred_data[0].network_key,
           ptlvC->length);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    /* MAC Address */
    ptlvC = (PTLV_DATA_HEADER) pEncry;
    ptlvC->type = htons(SC_MAC_Address);
    ptlvC->length = 6;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, pwps_info->enrollee.mac_address, 6);
    pEncry += ptlvC->length;
    enc_setting_len += (SZ_TLV_HEADER + ptlvC->length);
    ptlvC->length = htons(ptlvC->length);

    if (wps_s->bss_type == BSS_TYPE_UAP) {
        ptlvE->length = htons(enc_setting_len);
    }
    /* ----- Credential End ----- */

    /* Key Wrap Authenticator */
    memset(KWA, 0, sizeof(KWA));
    MrvHMAC_SHA256(pwps_info->auth_key, 32,
                   EncryData, pEncry - EncryData, KWA, SHA256_DIGEST_SIZE);

    ptlvE = (PTLV_DATA_HEADER) pEncry;
    ptlvE->type = htons(SC_Key_Wrap_Authenticator);
    ptlvE->length = SZ_KWA;
    pEncry += SZ_TLV_HEADER;
    memcpy(pEncry, KWA, SZ_KWA);
    pEncry += ptlvE->length;
    ptlvE->length = htons(ptlvE->length);

    wps_printf(DEBUG_WPS_MSG, "M8 : pEncry-EncryData = 0x%x\n",
               pEncry - EncryData);
    wps_hexdump(DEBUG_WPS_MSG, "M8_prepare Key Wrap Key",
                (u8 *) pwps_info->key_wrap_key,
                sizeof(pwps_info->key_wrap_key));
    memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
    datalength = pEncry - EncryData;

    wps_printf(DEBUG_WPS_MSG, "datalength(pEncry-EncryData) = %d\n", datalength);

    if (datalength % 32 == 0) {
        wps_hexdump(DEBUG_WPS_MSG, "M8_preEncry", (u8 *) EncryData, datalength);
        memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
        MrvAES_Wrap(EncryData, datalength, EncryAesOutput,
                    pwps_info->key_wrap_key, 16, pwps_info->registrar.IV);
        memcpy(ptr, EncryAesOutput, datalength + 16);
        ptr += datalength + 16;
        ptlv->length = WPS_NONCE_SIZE + datalength + 16;
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptlv->length = htons(ptlv->length);
    } else {
        if (datalength % 16 == 0 && datalength % 32 != 0)
            datalength = datalength - datalength % 32 + 32;
        else if (datalength % 16 != 0)
            datalength = datalength - datalength % 16 + 16;

        /* Padding the value of # of paddings */
        for (i = 0; i < datalength - (pEncry - EncryData); i++) {
            *(EncryData + (pEncry - EncryData) + i) =
                datalength - (pEncry - EncryData);
        }

        wps_hexdump(DEBUG_WPS_MSG, "M8_preEncry", (u8 *) EncryData, datalength);
        memset(EncryAesOutput, 0, sizeof(EncryAesOutput));
        MrvAES_Wrap(EncryData, datalength, EncryAesOutput,
                    pwps_info->key_wrap_key, 16, pwps_info->registrar.IV);
        memcpy(ptr, EncryAesOutput, datalength);
        ptr += datalength;
        ptlv->length = WPS_NONCE_SIZE + datalength;
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptlv->length = htons(ptlv->length);
    }

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Authenticator */
    message_len = message_length;
    offset = wps_attribute_authenticator_prepare(pwps_info, message_len, ptr);
    message_length += offset;
    ptr += offset;

    peap_wps_frame->length += message_length;
    offset = peap_wps_frame->length;
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) offset);

//    wps_write_to_config_file(pwps_info);

	if (IS_DISCOVERY_REGISTRAR(pwps_info)) {
		wfd_update_persistent_record(pwps_info);
	}
	
    // TODO - revisit how to get registrar to report "success"
    // for now, just mark the 'valid data' used by enrollee to report success.
    pwps_info->wps_valid_data = WPS_SET;


    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

static inline int
wps_get_sizeof_ssid(u8 * ssid, u8 ssid_len)
{
    u16 ssid_length = 0, i = 0;
    for (i = 0; i < ssid_len; i++) {
        if (ssid[i] != 0)
            ssid_length++;
        else
            return ssid_length;
    }
    return ssid_length;

}

int
wps_process_ap_settings_from_registrar(PWPS_INFO pwps_info, u8 * ptr, u32 len)
{
    u16 estype;
    u8 *esdata;
    int ret = WPS_STATUS_SUCCESS;
    CREDENTIAL_DATA *pCred = (CREDENTIAL_DATA *)
        & pwps_info->registrar.cred_data[0];
    ENTER();

    wps_hexdump(DEBUG_WPS_MSG, "M8_AP_Settings", ptr, len);
    /* We received AP settings from Registrar. */
    pwps_info->read_ap_config_only = WPS_CANCEL;

    wps_printf(DEBUG_WPS_MSG,
               "Resetting AP config read only variable. AP configuration would be modified!\n");

    while (len > 0) {
        PTLV_DATA_HEADER pes = (PTLV_DATA_HEADER) ptr;
        estype = ntohs(pes->type);
        pes->length = ntohs(pes->length);
        esdata = (u8 *) pes;
        esdata += SZ_TLV_HEADER;

        switch (estype) {
        case SC_Key_Wrap_Authenticator:
            wps_printf(DEBUG_WPS_MSG, "SC_Key_Wrap_Authenticator\n");
            memcpy(pwps_info->key_wrap_authenticator, esdata, pes->length);
            break;
        case SC_Network_Index:
            wps_printf(DEBUG_WPS_MSG, "SC_Network_Index\n");
            memcpy(&pCred->network_index, esdata, pes->length);
            break;
        case SC_SSID:
            wps_printf(DEBUG_WPS_MSG, "SC_SSID\n");
            pCred->ssid_length =
                MIN(pes->length, wps_get_sizeof_ssid(esdata, pes->length));
            memcpy(pCred->ssid, esdata, pCred->ssid_length);
            wps_printf(DEBUG_WPS_MSG, "SSID length: %d\n", pCred->ssid_length);
            wps_printf(DEBUG_WPS_MSG, "SSID : %s\n", pCred->ssid);
            break;
        case SC_Authentication_Type:
            wps_printf(DEBUG_WPS_MSG, "SC_Authentication_Type\n");
            memcpy(&pCred->auth_type, esdata, pes->length);
            pCred->auth_type = ntohs(pCred->auth_type);
            wps_printf(DEBUG_WPS_MSG, "Authentication_Type(M8) = 0x%04x\n",
                       pCred->auth_type);
            break;
        case SC_Encryption_Type:
            wps_printf(DEBUG_WPS_MSG, "SC_Encryption_Type\n");
            memcpy(&pCred->encry_type, esdata, pes->length);
            pCred->encry_type = ntohs(pCred->encry_type);
            wps_printf(DEBUG_WPS_MSG, "Encryption_Type(M8) = 0x%04x\n",
                       pCred->encry_type);
            break;
        case SC_Network_Key_Index:
            wps_printf(DEBUG_WPS_MSG, "SC_Network_Key_Index\n");
            memcpy(&pCred->network_key_index, esdata, pes->length);
            wps_printf(DEBUG_WPS_MSG, "Network Key Index = %d\n",
                       pCred->network_key_index);
            break;
        case SC_Network_Key:
            wps_printf(DEBUG_WPS_MSG, "SC_Network_Key\n");
            wps_hexdump(DEBUG_WPS_MSG, "SC_Network_Key",
                        (u8 *) esdata, pes->length);
            memcpy(pCred->network_key, esdata, pes->length);
            pCred->network_key_len = pes->length;
            break;
        case SC_MAC_Address:
            wps_printf(DEBUG_WPS_MSG, "SC_MAC_Address\n");
            memcpy(pCred->mac_address, esdata, pes->length);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown msg_Type = 0x%x\n", pes->type);
            break;
        }
        len -= pes->length + SZ_TLV_HEADER;
        ptr += pes->length + SZ_TLV_HEADER;
    }

    if (pwps_info->enrollee.version >= WPS_VERSION_2DOT0) {
        switch (pCred->encry_type) {
        case ENCRYPTION_TYPE_WEP:
            if (wps_non_interactive)
                wps_printf(MSG_ERROR, "Invalid WSC2.0 credential. Encryption WEP!\n");
            pwps_info->read_ap_config_only = WPS_SET;
            ret = WPS_STATUS_FAIL;
            break;
        case ENCRYPTION_TYPE_TKIP:
            if (pCred->auth_type == AUTHENTICATION_TYPE_WPAPSK) {
                wps_printf(MSG_ERROR,
                        "WPA-TKIP Encryption received. Modifying to WPA-WPA2 mixed.\n");
                pCred->auth_type = AUTHENTICATION_TYPE_WPA_MIXED;
                ret = WPS_STATUS_SUCCESS;
            } else {
                pwps_info->read_ap_config_only = WPS_SET;
                ret = WPS_STATUS_FAIL;
            }
            break;
        default:
            break;
        }
    }
    wps_printf(DEBUG_WPS_MSG, "calling change ==== auth:0x%x\n",
               pwps_info->registrar.cred_data[0].auth_type);
    LEAVE();
    return ret;
}

/** 
 *  @brief  Process received WPS M8 Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_M8_frame_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    PEAP_FRAME_HEADER peap;
    u8 *plast_byte, *data, *wps_frm_body = NULL;
    u16 len, wps_frm_body_len, tlv_type, tlv_length;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    int ret;
    int cred_ind, num_invalid_cred = 0;

    ENTER();

    size = ntohs(size);
    peap = (PEAP_FRAME_HEADER) buf;
    /**
     * Save received frame for Authenticator
     */
    /* Flags = 0x02 : Length field (LF) */
    if (peap->flags & 0x02) {
        ptlv =
            (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER +
                                SZ_EAP_MESSAGE_LENGTH);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len =
            (size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER - SZ_EAP_MESSAGE_LENGTH);
    } else {
        ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
        wps_frm_body = (u8 *) ptlv;
        wps_frm_body_len = (size - SZ_EAP_WPS_FRAME_HEADER);
        wps_hexdump(MSG_MSGDUMP, "ptlv", (u8 *) ptlv,
                    size - SZ_EAP_WPS_FRAME_HEADER);
    }

    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        switch (tlv_type) {
        case SC_Version:
            wps_printf(DEBUG_WPS_MSG, "SC_Version\n");
            memcpy(&pwps_info->registrar.version, data, tlv_length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, tlv_length);
            if (pwps_info->registrar.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(M8) Unknown WPS Version = 0x%x\n",
                           pwps_info->registrar.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "SC_Message_Type = 0x%x\n", *data);
            if (*data != WPS_M8)
                return WPS_STATUS_FAIL;
            break;
        case SC_Enrollee_Nonce:
            wps_printf(DEBUG_WPS_MSG, "SC_Enrollee_Nonce\n");
            if (memcmp(pwps_info->enrollee.nonce, data, tlv_length) != 0) {
                wps_printf(DEBUG_WPS_MSG,
                           "@M8_process: SC_Enrollee_Nonce Fail\n");
                return WPS_STATUS_FAIL;
            }
            memcpy(pwps_info->enrollee.nonce, data, tlv_length);
            break;
        case SC_Encrypted_Settings:
            {
                u16 elen = 0;
                u16 estype;
                u8 *esdata;

                num_cred = 0;
                memset(pwps_info->registrar.cred_data,
                       0x00, MAX_NUM_CRDENTIAL * sizeof(CREDENTIAL_DATA));

                wps_printf(DEBUG_WPS_MSG, "SC_Encrypted_Settings\n");
                memcpy(pwps_info->registrar.IV, data, 16);
                pwps_info->registrar.encrypted_data_len = tlv_length - 16;
                memcpy(pwps_info->registrar.encrypted_data,
                       data + 16, pwps_info->registrar.encrypted_data_len);
                wps_hexdump(DEBUG_WPS_MSG, "encrypted_data",
                            (u8 *) pwps_info->registrar.encrypted_data,
                            pwps_info->registrar.encrypted_data_len);

                PTLV_DATA_HEADER pes =
                    (PTLV_DATA_HEADER) (pwps_info->registrar.wrap_raw_data);
                memset(pwps_info->registrar.wrap_raw_data, 0x00,
                       sizeof(pwps_info->registrar.wrap_raw_data));

                wps_hexdump(DEBUG_WPS_MSG, "M8_process Key Wrap Key",
                            (u8 *) pwps_info->key_wrap_key,
                            sizeof(pwps_info->key_wrap_key));

                pwps_info->registrar.encrypted_data_len =
                    MrvAES_UnWrap_Ext(pwps_info->registrar.encrypted_data,
                                      pwps_info->registrar.encrypted_data_len,
                                      pwps_info->registrar.wrap_raw_data,
                                      pwps_info->key_wrap_key, 16,
                                      pwps_info->registrar.IV);

                wps_hexdump(DEBUG_WPS_MSG, "M8_process Wrap Raw Data",
                            (u8 *) pwps_info->registrar.wrap_raw_data,
                            pwps_info->registrar.encrypted_data_len);

                if (wps_s->bss_type == BSS_TYPE_UAP) {
                    ret =
                        wps_process_ap_settings_from_registrar(pwps_info,
                                                               (u8 *) pes,
                                                               (pwps_info->
                                                                registrar.
                                                                encrypted_data_len));
                    if (ret != WPS_STATUS_SUCCESS)
                        return WPS_STATUS_FAIL;
                    else
                        break;
                }

                while (((u8 *) pes - pwps_info->registrar.wrap_raw_data) <
                       (pwps_info->registrar.encrypted_data_len - 16)) {
                    estype = ntohs(pes->type);
                    pes->length = ntohs(pes->length);
                    esdata = (u8 *) pes;
                    esdata += SZ_TLV_HEADER;

                    switch (estype) {
                    case SC_Key_Wrap_Authenticator:
                        wps_printf(DEBUG_WPS_MSG, "SC_Key_Wrap_Authenticator\n");
                        memcpy(pwps_info->key_wrap_authenticator, esdata,
                               pes->length);
                        break;
                    case SC_Credential:
                        {
                            PTLV_DATA_HEADER pcre = (PTLV_DATA_HEADER) (esdata);
                            u16 clen;
                            int cretype = 0;
                            u8 *credata;
                            CREDENTIAL_DATA *pCred;

                            wps_printf(DEBUG_WPS_MSG, "SC_Credential\n");

                            num_cred++;
                            wps_printf(DEBUG_WPS_MSG,
                                       "Num of SC_Credential received = %d\n",
                                       num_cred);
                            if (num_cred >= MAX_NUM_CRDENTIAL)
                                num_cred = MAX_NUM_CRDENTIAL;
                            wps_printf(DEBUG_WPS_MSG,
                                       "Num of SC_Credential saved = %d\n",
                                       num_cred);

                            pCred =
                                (CREDENTIAL_DATA *) & pwps_info->registrar.
                                cred_data[num_cred - 1];

                            while (((u8 *) pcre - esdata) < pes->length) {
                                cretype = ntohs(pcre->type);
                                pcre->length = ntohs(pcre->length);
                                credata = (u8 *) pcre;
                                credata += SZ_TLV_HEADER;

                                switch (cretype) {
                                case SC_Network_Index:
                                    wps_printf(DEBUG_WPS_MSG,
                                               "SC_Network_Index\n");
                                    memcpy(&pCred->network_index, credata,
                                           pcre->length);
                                    break;
                                case SC_SSID:
                                    wps_printf(DEBUG_WPS_MSG, "SC_SSID\n");
                                    pCred->ssid_length =
                                        MIN(pcre->length, sizeof(pCred->ssid));
                                    memcpy(pCred->ssid, credata,
                                           pCred->ssid_length);
                                    wps_printf(DEBUG_WPS_MSG, "SSID : %s\n",
                                               pCred->ssid);
                                    wps_printf(DEBUG_WPS_MSG, "SSID length: %d\n",
                                               pCred->ssid_length);
                                    break;
                                case SC_Authentication_Type:
                                    wps_printf(DEBUG_WPS_MSG,
                                               "SC_Authentication_Type\n");
                                    memcpy(&pCred->auth_type, credata,
                                           pcre->length);
                                    pCred->auth_type = ntohs(pCred->auth_type);
                                    wps_printf(DEBUG_WPS_MSG,
                                               "Authentication_Type(M8) = 0x%04x\n",
                                               pCred->auth_type);
                                    break;
                                case SC_Encryption_Type:
                                    wps_printf(DEBUG_WPS_MSG,
                                               "SC_Encryption_Type\n");
                                    memcpy(&pCred->encry_type, credata,
                                           pcre->length);
                                    pCred->encry_type =
                                        ntohs(pCred->encry_type);
                                    wps_printf(DEBUG_WPS_MSG,
                                               "Encryption_Type(M8) = 0x%04x\n",
                                               pCred->encry_type);
                                    break;
                                case SC_Network_Key_Index:
                                    wps_printf(DEBUG_WPS_MSG,
                                               "SC_Network_Key_Index\n");
                                    memcpy(&pCred->network_key_index, credata,
                                           pcre->length);
                                    break;
                                case SC_WEP_Transmit_Key:
                                    wps_printf(DEBUG_WPS_MSG,
                                               "SC_WEP_Transmit_Key\n");
                                    memcpy(&pCred->wep_tx_key_index, credata,
                                           pcre->length);
                                    break;
                                case SC_Network_Key:
                                    wps_printf(DEBUG_WPS_MSG, "SC_Network_Key\n");
                                    wps_hexdump(DEBUG_WPS_MSG, "SC_Network_Key",
                                                (u8 *) credata, pcre->length);
                                    memcpy(pCred->network_key, credata,
                                           pcre->length);
                                    pCred->network_key_len = pcre->length;
                                    break;
                                case SC_MAC_Address:
                                    wps_printf(DEBUG_WPS_MSG, "SC_MAC_Address\n");
                                    memcpy(pCred->mac_address, credata,
                                           pcre->length);

                                    if ((pwps_info->registrar.version2 >=
                                         WPS_VERSION_2DOT0) &&
                                        memcmp(pCred->mac_address,
                                               pwps_info->enrollee.mac_address,
                                               6) != 0) {
                                        wps_printf(DEBUG_WPS_MSG,
                                                   "@M8_process: pCred->MAC Address Fail\n");
                                        /* XXX: Actually we should return &
                                           NACK with conf. error code=13 */
                                        return WPS_STATUS_FAIL;
                                    }
                                    break;
                                case SC_RF_Band:       /* optional, for
                                                           multi-band */
                                    wps_printf(DEBUG_WPS_MSG, "SC_RF_Band\n");
                                    memcpy(&pCred->rf_bands, credata,
                                           pcre->length);
                                    break;
                                }
                                clen = pcre->length + SZ_TLV_HEADER;
                                pcre = (PTLV_DATA_HEADER) ((u8 *) pcre + clen);
                            }   /* while */
                        }
                        break;
                    }
                    elen = pes->length + SZ_TLV_HEADER;
                    pes = (PTLV_DATA_HEADER) ((u8 *) pes + elen);
                }
                if (pwps_info->enrollee.version >= WPS_VERSION_2DOT0) {
                    for (cred_ind = 0; cred_ind < num_cred; cred_ind++) {
                        CREDENTIAL_DATA *pCred;
                        pCred = (CREDENTIAL_DATA *)
                            & pwps_info->registrar.cred_data[cred_ind];
                        /* XXX: Add OPEN check here if needed */
                        if (pCred->encry_type == ENCRYPTION_TYPE_WEP
                            || pCred->encry_type == ENCRYPTION_TYPE_TKIP) {
                            wps_printf(DEBUG_WPS_MSG,
                                       "@M8_process: Invalid WSC2.0 credential %d\n",
                                       pCred->encry_type);
                            num_invalid_cred++;
                        }
                    }

                    if (num_invalid_cred == num_cred) {
                        pwps_info->invalid_credential = WPS_SET;
                        /* All Received credentials are invalid, return error */
                        wps_printf(DEBUG_WPS_MSG,
                                   "@M8_process: No valid wsc2 credentials found\n");
                        return WPS_STATUS_FAIL;
                    }
                }
                break;
            }
        case SC_Authenticator:
            memcpy(pwps_info->registrar.authenticator, data, tlv_length);
            break;
        default:
            wps_printf(DEBUG_WPS_MSG, "Unknown message_Type = 0x%x\n", tlv_type);
            break;
        }

        len = tlv_length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    if (wps_authenticator_validate(pwps_info, wps_frm_body, wps_frm_body_len)
        != WPS_STATUS_SUCCESS) {
        return WPS_STATUS_FAIL;
    }

    /* save the last tx message before saving the rx message into last message */
    memcpy(&pwps_info->last_tx_message,
           &pwps_info->last_message, sizeof(MESSAGE_BUFFER));
    /**
     * Save received frame for Authenticator
     */
    WPS_SAVE_PKT(pwps_info, wps_frm_body, wps_frm_body_len);

    /* WARNING: Current drops of WPS code have moved this to the code that
     *          processes the final EAP_FAIL message.  Be careful when
     *          porting so we don't end up requiring EAP_FAIL in order to
     *          save the security info. */ 
    wps_write_to_config_file(pwps_info);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS Done Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_done_message_prepare(PWPS_INFO pwps_info)
{
    int offset;
    int ret;
    u8 *ptr = pwps_info->buffer;
    u16 message_length = 0;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    offset = wps_message_common_attribute_prepare(pwps_info,
                                                  pwps_info->peer_id,
                                                  (wps_s->bss_type ==
                                                   BSS_TYPE_UAP) ? EAP_REQUEST :
                                                  EAP_RESPONSE, WPS_Done,
                                                  WPS_DONE);

    message_length += offset;
    ptr += offset;

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Note The frame length field has been converted to network order in
       function wps_message_common_attribute_prepare() */
    /* Update EAP header len */
    peap_wps_frame->length = htons(message_length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) message_length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS Done Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_done_message_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *data;
    u16 len;

    ENTER();

    size = ntohs(size);
    ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    /**
     * Save received frame for Authenticator
     */
    memcpy(pwps_info->last_message.message,
           (u8 *) (buf + SZ_EAP_WPS_FRAME_HEADER),
           (size - SZ_EAP_WPS_FRAME_HEADER));
    pwps_info->last_message.length = (size - SZ_EAP_WPS_FRAME_HEADER);
    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);

        switch (ptlv->type) {
        case SC_Version:
            memcpy(&pwps_info->enrollee.version, data, ptlv->length);
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, ptlv->length);
            if (pwps_info->enrollee.version2 > WPS_VERSION) {
                wps_printf(MSG_WARNING, "(DONE) Unknown WPS Version = 0x%x\n",
                           pwps_info->enrollee.version2);
            }
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_DONE)
                return WPS_STATUS_FAIL;
            break;
        case SC_Enrollee_Nonce:
            memcpy(pwps_info->enrollee.nonce, data, ptlv->length);
            break;
        case SC_Registrar_Nonce:
            memcpy(pwps_info->registrar.nonce, data, ptlv->length);
            break;
        }

        len = ptlv->length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS Start Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_request_start_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    int len;
    int ret;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    len = wps_eap_message_header_prepare(pwps_info,
                                         EAP_REQUEST, pwps_info->id, WPS_Start);

    /* convert to network order */
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) len);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS Start Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_request_start_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    int status = WPS_STATUS_SUCCESS;
    PEAP_FRAME_HEADER peap_wps_frame;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) buf;

    if (memcmp(peap_wps_frame->vendor_id,
               wps_vendor_id, sizeof(wps_vendor_id)) != 0) {
        return WPS_STATUS_FAIL;
    }

    if (memcmp(peap_wps_frame->vendor_type,
               wps_vendor_type, sizeof(wps_vendor_type)) != 0) {
        return WPS_STATUS_FAIL;
    }

    if (peap_wps_frame->op_code != WPS_Start) {
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return status;
}

/** 
 *  @brief  Prepare and Send WPS NACK Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param id           Frame identifier
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_nack_message_prepare(PWPS_INFO pwps_info, u8 id)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    PTLV_DATA_HEADER ptlv;
    u8 *ptr;
    u16 msg_value_short, message_length = 0;
    int ret, offset = 0;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    pwps_info->nack_error_count++;

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    ptr = pwps_info->buffer;

    offset = wps_message_common_attribute_prepare(pwps_info, id,
                                                  ((wps_s->bss_type ==
                                                    BSS_TYPE_UAP)
                                                  )? EAP_REQUEST : EAP_RESPONSE,
                                                  WPS_Nack, WPS_NACK);

    /* Configuration_Error */
    message_length += offset;
    ptr += offset;
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    if (pwps_info->role == WPS_ENROLLEE &&
        wps_s->bss_type == BSS_TYPE_UAP &&
        pwps_info->wps_ap_setup_locked == WPS_SET)
        msg_value_short = htons(CONFIG_ERROR_AP_SETUP_LOCKED);
    else
        msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    memcpy(ptr, &msg_value_short, 2);
    message_length += (SZ_TLV_HEADER + ptlv->length);
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Note The frame length field has been converted to network order in
       function wps_message_common_attribute_prepare() We need to convert it
       back here */
    peap_wps_frame->length = htons(message_length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) message_length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS ACK Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_ack_message_prepare(PWPS_INFO pwps_info)
{
    u16 message_length = 0;
    int ret, offset;
    u8 *ptr = pwps_info->buffer;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);

    ENTER();

    offset = wps_message_common_attribute_prepare(pwps_info,
                                                  pwps_info->peer_id,
                                                  (wps_s->bss_type ==
                                                   BSS_TYPE_UAP) ? EAP_REQUEST :
                                                  EAP_RESPONSE, WPS_Ack,
                                                  WPS_ACK);

    message_length += offset;
    ptr += offset;

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    /* Note The frame length field has been converted to network order in
       function wps_message_common_attribute_prepare() */

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) message_length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

int
wps_eap_frag_ack_frame_prepare(PWPS_INFO pwps_info)
{
    int len;
    int ret;
    PEAP_FRAME_HEADER peap_wps_frame;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;

    /** Increment Peer ID for Brodcom stations;*/
    if (wps_s->bss_type == BSS_TYPE_UAP) {
        pwps_info->peer_id += 1;
    }

    len = wps_eap_message_header_prepare(pwps_info,
                                         (wps_s->bss_type ==
                                          BSS_TYPE_UAP) ? EAP_REQUEST :
                                         EAP_RESPONSE, pwps_info->peer_id,
                                         WPS_Frag_Ack);

    /* convert to network order */
    peap_wps_frame->length = htons(peap_wps_frame->length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) len);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send EAP_FAIL Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eap_fail_frame_prepare(PWPS_INFO pwps_info)
{
    PEAP_FRAME_HEADER peap_wps_frame;
    u16 length;
    int ret;

    ENTER();

    peap_wps_frame = (PEAP_FRAME_HEADER) pwps_info->buffer;
    peap_wps_frame->code = EAP_FAILURE;
    peap_wps_frame->identifier = pwps_info->peer_id;
    length = 4;
    peap_wps_frame->length = htons(length);

    /* call eapol tx function */
    ret = wps_eapol_txPacket((u8 *) pwps_info->buffer, (size_t) length);

    LEAVE();

    if (ret < 0)
        return WPS_STATUS_FAIL;
    else
        return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send EAPOL_START Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_eapol_start_prepare(PWPS_INFO pwps_info)
{
    ENTER();

    if (wps_eapol_txStart() < 0) {
        LEAVE();
        return WPS_STATUS_FAIL;
    }

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Prepare and Send WPS NACK Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_nack_message_remap(PWPS_INFO pwps_info)
{
    ENTER();

    wps_nack_message_prepare(pwps_info, pwps_info->peer_id);

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS ACK Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_ack_message_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *data;
    u16 len;

    ENTER();

    size = ntohs(size);
    ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    /**
     * Save received frame for Authenticator
     */
    memcpy(pwps_info->last_message.message,
           (u8 *) (buf + SZ_EAP_WPS_FRAME_HEADER),
           (size - SZ_EAP_WPS_FRAME_HEADER));
    pwps_info->last_message.length = (size - SZ_EAP_WPS_FRAME_HEADER);
    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);

        switch (ptlv->type) {
        case SC_Version:
            if (pwps_info->role == WPS_ENROLLEE
                || (IS_DISCOVERY_ENROLLEE(pwps_info))
                ) {
                memcpy(&pwps_info->registrar.version, data, ptlv->length);
            } else if (pwps_info->role == WPS_REGISTRAR
                       || (IS_DISCOVERY_REGISTRAR(pwps_info))
                ) {
                memcpy(&pwps_info->enrollee.version, data, ptlv->length);
            }
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, ptlv->length);
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_ACK)
                return WPS_STATUS_FAIL;
            break;
        case SC_Enrollee_Nonce:
            memcpy(pwps_info->enrollee.nonce, data, ptlv->length);
            break;
        case SC_Registrar_Nonce:
            memcpy(pwps_info->registrar.nonce, data, ptlv->length);
            break;
        }

        len = ptlv->length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Process received WPS NACK Message Frame
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_nack_message_process(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *data;
    u16 len;

    ENTER();

    size = ntohs(size);
    ptlv = (PTLV_DATA_HEADER) (buf + SZ_EAP_WPS_FRAME_HEADER);
    data = (u8 *) ptlv;
    plast_byte = (u8 *) (buf + size);

    /**
     * Save received frame for Authenticator
     */
    memcpy(pwps_info->last_message.message,
           (u8 *) (buf + SZ_EAP_WPS_FRAME_HEADER),
           (size - SZ_EAP_WPS_FRAME_HEADER));
    pwps_info->last_message.length = (size - SZ_EAP_WPS_FRAME_HEADER);
    data += SZ_TLV_HEADER;

    while ((void *) ptlv < (void *) plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);

        switch (ptlv->type) {
        case SC_Version:
            if (pwps_info->role == WPS_ENROLLEE
                || (IS_DISCOVERY_ENROLLEE(pwps_info))
                ) {
                memcpy(&pwps_info->registrar.version, data, ptlv->length);
            } else if (pwps_info->role == WPS_REGISTRAR
                       || (IS_DISCOVERY_REGISTRAR(pwps_info))
                ) {
                memcpy(&pwps_info->enrollee.version, data, ptlv->length);
            }
            break;
        case SC_Vendor_Extension:
            wps_process_attrib_vendor_ext(pwps_info, data, ptlv->length);
            break;
        case SC_Message_Type:
            wps_printf(DEBUG_WPS_MSG, "Message_Type = 0x%x\n", *data);
            if (*data != WPS_NACK)
                return WPS_STATUS_FAIL;
            break;
        case SC_Enrollee_Nonce:
            memcpy(pwps_info->enrollee.nonce, data, ptlv->length);
            break;
        case SC_Registrar_Nonce:
            memcpy(pwps_info->registrar.nonce, data, ptlv->length);
            break;
        case SC_Configuration_Error:
            wps_printf(DEBUG_WPS_MSG, "SC_Configuration_Error(NACK): %d\n",
                       ntohs(*(u16 *) data));
            break;
        }

        len = ptlv->length + SZ_TLV_HEADER;
        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Dummy function for function table
 *
 *  @param pwps_info    A pointer to WPS_INFO structure
 *  @param buf          A pointer to EAP frame
 *  @param size         Frame size
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_dummy(PWPS_INFO pwps_info, u8 * buf, u16 size)
{
    ENTER();
    LEAVE();
    return WPS_STATUS_SUCCESS;
}

/** 
 *  @brief  Generate PIN value with random number generator
 *
 *  @return         PIN value
 */
u32
get_wps_pin(PWPS_INFO pwps_info)
{
    u32 wps_pin = 0x12345670;

    ENTER();
/*
    srand((u32) time(NULL));

    if (pwps_info->PINLen == 4) {
        wps_pin = rand() % 10000;
        if (wps_pin < 1000)
            wps_pin += 1000;
    } else {
        wps_pin = rand() % 10000000;
        if (wps_pin < 1000000)
            wps_pin += 1000000;
        wps_pin = wps_pin * 10 + ComputeChecksum(wps_pin);
    }
*/
    LEAVE();
    return wps_pin;
}

/** 
 *  @brief  Prepare Selected registrar config methods attribute.
 *
 *  @param  PWPS_IFO    A pointer to WPS_INFO structure
 *  @return             selected registrar config method value
 */
short
wps_selected_registrar_config_method_prepare(PWPS_INFO pwps_info)
{

    u16 msg_value_short = 0, config_methods;
    WPS_DATA *wps_s = (WPS_DATA *) & wps_global;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg;
    ENTER();

    pwps_info = wps_get_private_info();

    en_reg =
        ((pwps_info->role ==
          WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    config_methods = en_reg->config_methods;

    if (config_methods & CONFIG_METHOD_KEYPAD) {
        wps_printf(DEBUG_WLAN, "Device is Rich UI device.\n");
        msg_value_short |= CONFIG_METHOD_KEYPAD;
    } else {
        wps_printf(DEBUG_WLAN, "Device is Low UI device.\n");
    }
    if (config_methods & CONFIG_METHOD_DISPLAY)
        msg_value_short |= CONFIG_METHOD_DISPLAY;
    if (config_methods & CONFIG_METHOD_LABEL)
        msg_value_short |= CONFIG_METHOD_LABEL;
    if (en_reg->device_password_id == DEVICE_PASSWORD_PUSH_BUTTON) {
        if (wps_s->bss_type == BSS_TYPE_UAP && pwps_info->role == WPS_ENROLLEE) {
            wps_printf(MSG_ERROR,
                       "PBC configuration method is not allowed for AP-configuration mode.ERROR!!\n");

        } else {
            msg_value_short |= CONFIG_METHOD_PUSHBUTTON;
            msg_value_short |= CONFIG_METHOD_VIRTUAL_PBC;
            wps_printf(DEBUG_WLAN,
                       "Push Button config method enabled on Registrar.\n");
        }
    }
    return msg_value_short;

}

/** 
 *  @brief  Prepare for Attribute needed for beacon
 *
 *  @param selectedRegistrar    WPS_START_REG_DISCOVERY_PHASE or WPS_END_REG_DISCOVERY_PHASE
 *  @param ptr                  A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
int
wps_ap_beacon_prepare(u8 selectedRegistrar, u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 msg_value_short;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg;
    ENTER();

    pwps_info = wps_get_private_info();

    en_reg =
        ((pwps_info->role ==
          WPS_ENROLLEE) ? &pwps_info->enrollee : &pwps_info->registrar);

    offset = 0;

    /* OUI */
    ptr += offset;
    memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    ptr += message_length;

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Simple Config State */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Simple_Config_State);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;

    //msg_value_char = SC_CONFIGURED_STATE;
    msg_value_char = pwps_info->wps_device_state;

    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (selectedRegistrar == 1) {
        /* Selected Registrar */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Selected_Registrar);
        ptlv->length = 1;
        ptr += SZ_TLV_HEADER;
        *ptr = selectedRegistrar;
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Device Password ID */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Device_Password_ID);
        ptlv->length = 2;
        ptr += SZ_TLV_HEADER;

        msg_value_short = htons(en_reg->updated_device_password_id);
        memcpy(ptr, &msg_value_short, 2);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Selected Registrar Config Methods */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_SelectedRegistrarConfigMethods);
        ptlv->length = 2;
        ptr += SZ_TLV_HEADER;
        msg_value_short =
            htons(wps_selected_registrar_config_method_prepare(pwps_info));
        memcpy(ptr, &msg_value_short, 2);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

    }

    /* UUID */
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_UUID_E);
    message_length += offset;
    ptr += offset;

    if (pwps_info->wps_ap_setup_locked == WPS_SET) {

        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_AP_Setup_Locked);
        ptlv->length = 1;
        ptr += SZ_TLV_HEADER;
        msg_value_char = pwps_info->wps_ap_setup_locked;
        memcpy(ptr, &msg_value_char, 1);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);
    }
    if (en_reg->version >= WPS_VERSION_2DOT0) {

        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        if (selectedRegistrar == 1) {
            /* Authorized MAC sub-ele */
            offset = wps_subele_authorized_mac_prepare(pwps_info, ptr);
            ptr += offset;
        }
        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

    }

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Name);
    ptlv->length = pwps_info->registrar.device_name_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    LEAVE();
    return message_length;
}

/** 
 *  @brief  Prepare for Attribute needed for probe request frame
 *
 *  @param ptr      A pointer to buffer which store this attribute
 *  @return         Length of Attribute TLV
 */
/* XXX: Actually we should do this for both Enrollee & Registrar */
int
wps_sta_probe_request_prepare(u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 msg_value_short;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg;

    ENTER();

    pwps_info = wps_get_private_info();
    en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
              &pwps_info->enrollee : &pwps_info->registrar);
    offset = 0;

    /* OUI */
    ptr += offset;
    memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    ptr += message_length;

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Request Type */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Request_Type);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    // TODO: Change For WSTA Registrar
    msg_value_char =
        ((pwps_info->role ==
          WPS_REGISTRAR) ? REQ_TYPE_REGISTRAR : REQ_TYPE_ENROLLEE);
    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(pwps_info->enrollee.config_methods);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* UUID */
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* RF Bands */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_RF_Band);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, &pwps_info->enrollee.rf_bands, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Association State */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Association_State);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(0x0);       /* Not Associated */
    memcpy(ptr, &msg_value_short, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Configuration Error */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Configuration_Error);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    msg_value_short = htons(CONFIG_ERROR_NO_ERROR);
    memcpy(ptr, &msg_value_short, 2);
    message_length += (SZ_TLV_HEADER + ptlv->length);
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Device Password ID */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Password_ID);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;

    msg_value_short = htons(pwps_info->enrollee.updated_device_password_id);
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {

        /* Manufacture */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Manufacturer);
        ptlv->length = pwps_info->enrollee.manufacture_length;
        ptr += SZ_TLV_HEADER;
        memcpy(ptr, pwps_info->enrollee.manufacture, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Model Name */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Model_Name);
        ptlv->length = pwps_info->enrollee.model_name_length;
        ptr += SZ_TLV_HEADER;
        memcpy(ptr, pwps_info->enrollee.model_name, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Model Number */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Model_Number);
        ptlv->length = pwps_info->enrollee.model_number_length;
        ptr += SZ_TLV_HEADER;
        memcpy(ptr, pwps_info->enrollee.model_number, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Device Name */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Device_Name);
        ptlv->length = pwps_info->enrollee.device_name_length;
        ptr += SZ_TLV_HEADER;
        memcpy(ptr, pwps_info->enrollee.device_name, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    LEAVE();
    return message_length;
}

/** 
 *  @brief  Prepare for Attribute needed for (Re)Assoc request frame
 *
 *  @param ptr      A pointer to buffer which store this attribute
 *  @return         Length of Attribute TLV
 */
int
wps_sta_assoc_request_prepare(u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg;

    ENTER();

    pwps_info = wps_get_private_info();
    en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
              &pwps_info->enrollee : &pwps_info->registrar);
    offset = 0;

    memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    ptr += sizeof(wps_wifi_oui);

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Request Type */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Request_Type);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    // TODO: Change For WSTA Registrar
    msg_value_char =
        ((pwps_info->role ==
          WPS_REGISTRAR) ? REQ_TYPE_REGISTRAR : REQ_TYPE_ENROLLEE);
    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }

    }

    LEAVE();
    return message_length;
}

/** 
 *  @brief  Prepare for Attribute needed for probe response frame
 *
 *  @param selectedRegistrar    WPS_START_REG_DISCOVERY_PHASE or WPS_END_REG_DISCOVERY_PHASE
 *  @param ptr                  A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
int
wps_ap_assoc_response_prepare(u8 selectedRegistrar, u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;

    pwps_info = wps_get_private_info();
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);
    ENTER();

    offset = 0;

    /* OUI */
    ptr += offset;
    memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    ptr += message_length;

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Response Type */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Response_Type);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = RESP_TYPE_AP;
    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        if (selectedRegistrar == 1) {
            /* Authorized MAC sub-ele */
            offset = wps_subele_authorized_mac_prepare(pwps_info, ptr);
            ptr += offset;
        }
        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }
    }
    LEAVE();
    return message_length;
}

/** 
 *  @brief  Prepare for Attribute needed for probe response frame
 *
 *  @param selectedRegistrar    WPS_START_REG_DISCOVERY_PHASE or WPS_END_REG_DISCOVERY_PHASE
 *  @param ptr                  A pointer to buffer which store this attribute
 *  @return             Length of Attribute TLV
 */
int
wps_ap_probe_response_prepare(u8 selectedRegistrar, u8 * ptr)
{
    PTLV_DATA_HEADER ptlv;
    u8 msg_value_char;
    u16 msg_value_short;
    u16 offset, message_length = 0;
    PWPS_INFO pwps_info;

    pwps_info = wps_get_private_info();
    PTLV_DATA_HEADER wfa_ven_tlv;
    MESSAGE_ENROLLEE_REGISTRAR *en_reg = ((pwps_info->role == WPS_ENROLLEE) ?
                                          &pwps_info->enrollee : &pwps_info->
                                          registrar);
    ENTER();

    offset = 0;

    /* OUI */
    ptr += offset;
    memcpy(ptr, wps_wifi_oui, sizeof(wps_wifi_oui));
    message_length += sizeof(wps_wifi_oui);
    ptr += message_length;

    /* Version */
    offset = wps_attribute_version_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Simple Config State */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Simple_Config_State);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    //msg_value_char = SC_CONFIGURED_STATE;
    msg_value_char = pwps_info->wps_device_state;

    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (pwps_info->wps_ap_setup_locked == WPS_SET) {

        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_AP_Setup_Locked);
        ptlv->length = 1;
        ptr += SZ_TLV_HEADER;
        msg_value_char = pwps_info->wps_ap_setup_locked;
        memcpy(ptr, &msg_value_char, 1);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);
    }
    if (selectedRegistrar == 1) {

        /* Selected Registrar */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Selected_Registrar);
        ptlv->length = 1;
        ptr += SZ_TLV_HEADER;
        *ptr = selectedRegistrar;
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Device Password ID */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_Device_Password_ID);
        ptlv->length = 2;
        ptr += SZ_TLV_HEADER;

        msg_value_short = htons(en_reg->updated_device_password_id);
        memcpy(ptr, &msg_value_short, ptlv->length);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);

        /* Selected Registrar Config Methods */
        ptlv = (PTLV_DATA_HEADER) ptr;
        ptlv->type = htons(SC_SelectedRegistrarConfigMethods);
        ptlv->length = 2;
        ptr += SZ_TLV_HEADER;
        msg_value_short =
            htons(wps_selected_registrar_config_method_prepare(pwps_info));
        memcpy(ptr, &msg_value_short, 2);
        message_length += SZ_TLV_HEADER + ptlv->length;
        ptr += ptlv->length;
        ptlv->length = htons(ptlv->length);
    }

    /* Response Type */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Response_Type);
    ptlv->length = 1;
    ptr += SZ_TLV_HEADER;
    msg_value_char = RESP_TYPE_AP;
    memcpy(ptr, &msg_value_char, 1);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* UUID */
    offset = wps_attribute_uuid_prepare(pwps_info, ptr);
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_UUID_E);
    message_length += offset;
    ptr += offset;

    /* Manufacture */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Manufacturer);
    ptlv->length = pwps_info->registrar.manufacture_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.manufacture, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Name */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Model_Name);
    ptlv->length = pwps_info->registrar.model_name_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.model_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Model Number */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Model_Number);
    ptlv->length = pwps_info->registrar.model_number_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.model_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Serial Number */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Serial_Number);
    ptlv->length = pwps_info->registrar.serial_number_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.serial_number, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Primary Device Type */
    offset = wps_attribute_primary_device_type_prepare(pwps_info, ptr);
    message_length += offset;
    ptr += offset;

    /* Device Name */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Device_Name);
    ptlv->length = pwps_info->registrar.device_name_length;
    ptr += SZ_TLV_HEADER;
    memcpy(ptr, pwps_info->registrar.device_name, ptlv->length);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    /* Config Methods */
    ptlv = (PTLV_DATA_HEADER) ptr;
    ptlv->type = htons(SC_Config_Methods);
    ptlv->length = 2;
    ptr += SZ_TLV_HEADER;
    {
        if (IS_DISCOVERY_REGISTRAR(pwps_info))
            /* do not use PBC */
            msg_value_short =
                htons(pwps_info->registrar.
                      config_methods & ~CONFIG_METHOD_PUSHBUTTON);
        else
            msg_value_short = htons(pwps_info->registrar.config_methods);
    }
    memcpy(ptr, &msg_value_short, 2);
    message_length += SZ_TLV_HEADER + ptlv->length;
    ptr += ptlv->length;
    ptlv->length = htons(ptlv->length);

    if (en_reg->version >= WPS_VERSION_2DOT0) {
        wfa_ven_tlv = (PTLV_DATA_HEADER) ptr;
        /* Vendor Extension */
        offset = wps_attribute_vendor_ext_prepare(pwps_info, ptr);
        ptr += offset;

        /* WFA Vendor Extension ID */
        memcpy(ptr, wfa_vendor_ext_id, WPS_VENDOR_EXT_ID_LEN);
        ptr += WPS_VENDOR_EXT_ID_LEN;

        /* Version2 sub-ele */
        offset = wps_subele_version2_prepare(pwps_info, ptr);
        ptr += offset;

        if (selectedRegistrar == 1) {
            /* Authorized MAC sub-ele */
            offset = wps_subele_authorized_mac_prepare(pwps_info, ptr);
            ptr += offset;
        }
        /* Set Vendor Extension Attr len */
        wfa_ven_tlv->length = ptr - ((u8 *) wfa_ven_tlv + SZ_TLV_HEADER);
        message_length += SZ_TLV_HEADER + wfa_ven_tlv->length;
        wfa_ven_tlv->length = htons(wfa_ven_tlv->length);

        if (pwps_info->proto_ext_test) {
            offset = wps_attribute_dummy_prepare(pwps_info, ptr);
            ptr += offset;
            message_length += offset;
        }
    }

    LEAVE();
    return message_length;
}

/** 
 *  @brief  Parsing Device Password ID 
 *
 *  @param message      A pointer to buffer for parsing
 *  @param size         Length of buffer
 *  @return             Device Password ID
 */
u16
wps_probe_response_device_password_id_parser(u8 * message, size_t size)
{
    u16 device_password_id = 0xffff;
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *data;
    u16 len;

    ENTER();

    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    data = (u8 *) ptlv;
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *) ptlv < (void *) plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);

        switch (ptlv->type) {
        case SC_Version:
            break;
        case SC_Response_Type:
            break;
        case SC_UUID_E:
            break;
        case SC_UUID_R:
            break;
        case SC_Simple_Config_State:
            break;
        case SC_Manufacturer:
            break;
        case SC_Model_Name:
            break;
        case SC_Model_Number:
            break;
        case SC_Serial_Number:
            break;
        case SC_Primary_Device_Type:
            break;
        case SC_Device_Name:
            break;
        case SC_Config_Methods:
            break;
        case SC_Selected_Registrar:
            wps_printf(DEBUG_WLAN, "SC_Selected_Registrar: %d\n", *data);
            break;
        case SC_Device_Password_ID:
            wps_printf(DEBUG_WLAN, "SC_Device_Password_ID\n");
            memcpy(&device_password_id, data, sizeof(u16));
            device_password_id = ntohs(device_password_id);
            wps_printf(DEBUG_WLAN, "device_password_id = 0x%x\n",
                       device_password_id);
            break;
        default:
            break;
        }

        len = ptlv->length + SZ_TLV_HEADER;

        /* Convert back to network byte order for other parser function */
        ptlv->type = htons(ptlv->type);
        ptlv->length = htons(ptlv->length);

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);

        data = (u8 *) ptlv;
        data += SZ_TLV_HEADER;
    }                           /* while */

    LEAVE();
    return device_password_id;
}

/** 
 *  @brief  Parsing UUID_E in WPS IE 
 *
 *  @param message      A pointer to buffer for parsing
 *  @param size         Length of buffer
 *  @param uuid_e       A pointer to returned buffer
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_probe_response_uuid_parser(u8 * message, size_t size, u8 * uuid_e)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 len;

    ENTER();

    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *) ptlv < (void *) plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);

        if (ptlv->type == SC_UUID_E) {
            wps_printf(DEBUG_WLAN, "SC_UUID_E found !\n");
            ptr = (u8 *) ptlv + SZ_TLV_HEADER;
            memcpy(uuid_e, ptr, ptlv->length);
            LEAVE();
            return WPS_STATUS_SUCCESS;
        }

        len = ptlv->length + SZ_TLV_HEADER;

        /* Convert back to network byte order for other parser function */
        ptlv->type = htons(ptlv->type);
        ptlv->length = htons(ptlv->length);

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);
    }                           /* while */

    LEAVE();
    return WPS_STATUS_FAIL;
}

/** 
 *  @brief  Parsing Config State in probe response
 *
 *  @param message      	A pointer to buffer for parsing
 *  @param size         	Length of buffer
 *  @param conf_state       A pointer to returned buffer
 *  @return             	WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */

int
wps_probe_response_conf_state_parser(u8 * message, size_t size, u8 * conf_state)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 tlv_type, tlv_len;

    ENTER();
    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_len = ntohs(ptlv->length);

        if (tlv_type == SC_Simple_Config_State) {
            wps_printf(DEBUG_WLAN, "SC_CONF_STATE found !\n");
            ptr = (u8 *) ptlv + SZ_TLV_HEADER;
            *conf_state = *ptr;
            LEAVE();
            return WPS_STATUS_SUCCESS;
        }

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + tlv_len + SZ_TLV_HEADER);
    }                           /* while */

    LEAVE();
    return WPS_STATUS_FAIL;
}

/** 
 *  @brief  Parsing Selected Registrar config methods in probe response
 *
 *  @param message      	A pointer to buffer for parsing
 *  @param size         	Length of buffer
 *  @param config_method    A pointer to return buffer
 *  @return             	WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */

int
wps_probe_response_selected_registrar_config_method_parser(u8 * message,
                                                           size_t size,
                                                           u16 * config_method)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 tlv_type, tlv_len;

    ENTER();
    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_len = ntohs(ptlv->length);

        if (tlv_type == SC_SelectedRegistrarConfigMethods) {
            wps_printf(DEBUG_WLAN, "Selected Registrar config methods found !\n");
            ptr = (u8 *) ptlv + SZ_TLV_HEADER;
            memcpy(config_method, ptr, 2);
            LEAVE();
            return WPS_STATUS_SUCCESS;
        }

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + tlv_len + SZ_TLV_HEADER);
    }                           /* while */

    LEAVE();
    return WPS_STATUS_FAIL;
}

/** 
 *  @brief  Parsing Response Type in WPS IE 
 *
 *  @param message      A pointer to buffer for parsing
 *  @param size         Length of buffer
 *  @param resp_type    A pointer to value
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_probe_response_resp_type_parser(u8 * message, size_t size, u8 * resp_type)
{
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 len, tlv_type, tlv_length;

    ENTER();

    /* Beginning from Version, skip IE_ID/Length/SC_OUI field */
    ptlv = (PTLV_DATA_HEADER) (message + 6);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *) ptlv < (void *) plast_byte) {
        tlv_type = ntohs(ptlv->type);
        tlv_length = ntohs(ptlv->length);

        if (tlv_type == SC_Response_Type) {
            wps_printf(DEBUG_WLAN, "SC_Response_Type found !\n");
            ptr = (u8 *) ptlv + SZ_TLV_HEADER;
            memcpy(resp_type, ptr, tlv_length);
            LEAVE();
            return WPS_STATUS_SUCCESS;
        }

        len = tlv_length + SZ_TLV_HEADER;

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);
    }                           /* while */

    LEAVE();
    return WPS_STATUS_FAIL;
}

/** 
 *  @brief  Parsing WPS2 Authorized MAC Attribute
 *
 *  @param message      A pointer to buffer for parsing
 *  @param size         Length of buffer
 *  @param mac_addr     A pointer to enrollee mac address
 *  @return             WPS_STATUS_SUCCESS on success, WPS_STATUS_FAIL on fail
 */
int
wps_probe_response_authorized_enrollee_mac_parser(PWPS_INFO pwps_info,
                                                  u8 * message, u8 size)
{
    int ret = WPS_STATUS_SUCCESS;
    PTLV_DATA_HEADER ptlv;
    u8 *plast_byte, *ptr;
    u16 len;

    ENTER();

    wps_hexdump(DEBUG_WLAN, "WPS MAC Parser:", message, size);

    /* 
     * skip IE_ID [1]/Length[1]/SC_OUI field[4]
     * Beginning from Version 104a[5], Simple config state 1044[5],
     * 1+1+4+5+5=16.
     */
    /* TODO */
    ptlv = (PTLV_DATA_HEADER) (message + 16);
    plast_byte = (u8 *) (message + (u8) size);

    while ((void *) ptlv < (void *) plast_byte) {
        ptlv->type = ntohs(ptlv->type);
        ptlv->length = ntohs(ptlv->length);
        ptr = (u8 *) ptlv + SZ_TLV_HEADER;
        if (ptlv->type == SC_Vendor_Extension) {

            ret = wps_process_attrib_vendor_ext(pwps_info, ptr, ptlv->length);
            LEAVE();
            return ret;
        }

        len = ptlv->length + SZ_TLV_HEADER;

        /* Convert back to network byte order for other parser function */
        ptlv->type = htons(ptlv->type);
        ptlv->length = htons(ptlv->length);

        ptlv = (PTLV_DATA_HEADER) ((u8 *) ptlv + len);
    }                           /* while */

    LEAVE();
    return ret;
}
